/* 
* DevExpress PhoneJS and ChartJS
* Version: 13.1.1
* Build date: Apr 30, 2013
*
* Copyright (c) 2012 - 2013 Developer Express Inc. ALL RIGHTS RESERVED
* EULA: http://phonejs.devexpress.com/EULA, http://chartjs.devexpress.com/EULA
*/

"use strict";

// Module core, file devexpress.js

(function($, global, undefined) {
    if (parseFloat($.fn.jquery) < 1.8)
        throw Error("Your version of jQuery is too old. Please upgrade jQuery to 1.8.0 or later.");
    var Class = function() {
            var wrapOverridden = function(baseProto, methodName, method) {
                    return function() {
                            var prevCallBase = this.callBase;
                            this.callBase = baseProto[methodName];
                            try {
                                return method.apply(this, arguments)
                            }
                            finally {
                                this.callBase = prevCallBase
                            }
                        }
                };
            var clonePrototype = function(obj) {
                    var func = function(){};
                    func.prototype = obj.prototype;
                    return new func
                };
            var classImpl = function(){};
            var redefine = function(members) {
                    for (var name in members) {
                        var overridden = $.isFunction(this.prototype[name]) && $.isFunction(members[name]);
                        this.prototype[name] = overridden ? wrapOverridden(this.parent.prototype, name, members[name]) : members[name]
                    }
                    return this
                };
            var include = function() {
                    var classObj = this;
                    $.each(arguments, function() {
                        if (this.ctor)
                            classObj._includedCtors.push(this.ctor);
                        for (var name in this) {
                            if (name === "ctor")
                                continue;
                            if (name in classObj.prototype)
                                throw Error("Member name collision: " + name);
                            classObj.prototype[name] = this[name]
                        }
                    });
                    return classObj
                };
            var subclassOf = function(parentClass) {
                    if (this.parent === parentClass)
                        return true;
                    if (!this.parent || !this.parent.subclassOf)
                        return false;
                    return this.parent.subclassOf(parentClass)
                };
            classImpl.inherit = function(members) {
                var inheritor = function() {
                        if (!this || this.constructor !== inheritor)
                            throw Error("A class must be instantiated using the 'new' keyword");
                        var instance = this,
                            ctor = instance.ctor;
                        if (ctor)
                            ctor.apply(instance, arguments);
                        $.each(instance.constructor._includedCtors, function() {
                            this.call(instance)
                        })
                    };
                inheritor.prototype = clonePrototype(this);
                inheritor.inherit = this.inherit;
                inheritor.redefine = redefine;
                inheritor.include = include;
                inheritor.subclassOf = subclassOf;
                inheritor.parent = this;
                inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
                inheritor.prototype.constructor = inheritor;
                inheritor.redefine(members);
                return inheritor
            };
            return classImpl
        }();
    var enqueue = function() {
            var tasks = [],
                busy = false;
            var exec = function() {
                    while (tasks.length) {
                        var task = tasks.shift(),
                            result = task();
                        if (result === undefined)
                            continue;
                        if (result.then) {
                            busy = true;
                            $.when(result).always(exec);
                            return
                        }
                        throw Error();
                    }
                    busy = false
                };
            return function(task) {
                    tasks.push(task);
                    if (!busy)
                        exec()
                }
        }();
    var parseUrl = function() {
            var a = document.createElement("a"),
                props = ["protocol", "hostname", "port", "pathname", "search", "hash"];
            var normalizePath = function(value) {
                    if (value.charAt(0) !== "/")
                        value = "/" + value;
                    return value
                };
            return function(url) {
                    a.href = url;
                    var result = {};
                    $.each(props, function() {
                        result[this] = a[this]
                    });
                    result.pathname = normalizePath(result.pathname);
                    return result
                }
        }();
    global.DevExpress = global.DevExpress || {};
    var enqueueAsync = function(task) {
            var deferred = $.Deferred();
            setTimeout(function() {
                deferred.resolve(task())
            }, 60);
            return deferred
        };
    $.extend(global.DevExpress, {
        abstract: function() {
            throw Error("Not implemented");
        },
        Class: Class,
        enqueue: enqueue,
        enqueueAsync: enqueueAsync,
        parseUrl: parseUrl
    })
})(jQuery, this);

// Module core, file inflector.js

(function($, DX, undefined) {
    var _normalize = function(text) {
            if (text === undefined || text === null)
                return "";
            return String(text)
        };
    var _ucfirst = function(text) {
            return _normalize(text).charAt(0).toUpperCase() + text.substr(1)
        };
    var _chop = function(text) {
            return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/)
        };
    var dasherize = function(text) {
            return $.map(_chop(text), function(p) {
                    return p.toLowerCase()
                }).join("-")
        };
    var underscore = function(text) {
            return dasherize(text).replace(/-/g, "_")
        };
    var camelize = function(text, upperFirst) {
            return $.map(_chop(text), function(p, i) {
                    p = p.toLowerCase();
                    if (upperFirst || i > 0)
                        p = _ucfirst(p);
                    return p
                }).join("")
        };
    var humanize = function(text) {
            return _ucfirst(dasherize(text).replace(/-/g, " "))
        };
    var titleize = function(text) {
            return $.map(_chop(text), function(p) {
                    return _ucfirst(p.toLowerCase())
                }).join(" ")
        };
    DX.inflector = {
        dasherize: dasherize,
        camelize: camelize,
        humanize: humanize,
        titleize: titleize,
        underscore: underscore
    }
})(jQuery, DevExpress);

// Module core, file support.js

(function($, DX, window) {
    var cssPrefixes = ["", "Webkit", "Moz", "O", "ms"],
        styles = document.createElement("dx").style;
    var transitionEndEventNames = {
            WebkitTransition: 'webkitTransitionEnd',
            MozTransition: 'transitionend',
            OTransition: 'oTransitionEnd',
            msTransition: 'MsTransitionEnd',
            transition: 'transitionend'
        };
    var styleProp = function(prop) {
            prop = DX.inflector.camelize(prop, true);
            for (var i = 0, cssPrefixesCount = cssPrefixes.length; i < cssPrefixesCount; i++) {
                var specific = cssPrefixes[i] + prop;
                if (specific in styles)
                    return specific
            }
        };
    var supportProp = function(prop) {
            return !!styleProp(prop)
        };
    DX.support = {
        touch: "ontouchstart" in window,
        transform3d: supportProp("perspective"),
        transition: supportProp("transition"),
        transitionEndEventName: transitionEndEventNames[styleProp("transition")],
        animation: supportProp("animation"),
        winJS: "WinJS" in window,
        styleProp: styleProp,
        supportProp: supportProp
    }
})(jQuery, DevExpress, this);

// Module core, file browser.js

(function($, DX, global, undefined) {
    var webkitRegExp = /(webkit)[ \/]([\w.]+)/,
        operaRegExp = /(opera)(?:.*version)?[ \/]([\w.]+)/,
        ieRegExp = /(msie) ([\w.]+)/,
        mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))?/;
    var ua = navigator.userAgent.toLowerCase();
    var browser = function() {
            var result = {},
                matches = webkitRegExp.exec(ua) || operaRegExp.exec(ua) || ieRegExp.exec(ua) || ua.indexOf("compatible") < 0 && mozillaRegExp.exec(ua) || [],
                browserName = matches[1],
                browserVersion = matches[2];
            if (browserName) {
                result[browserName] = true;
                result.version = browserVersion
            }
            return result
        }();
    DX.browser = browser
})(jQuery, DevExpress, this);

// Module core, file position.js

(function($, DX, undefined) {
    var horzRe = /left|right/,
        vertRe = /top|bottom/,
        collisionRe = /fit|flip/;
    var splitPair = function(raw) {
            switch (typeof raw) {
                case"string":
                    return raw.split(/\s+/, 2);
                case"object":
                    return [raw.x || raw.h, raw.y || raw.v];
                case"number":
                    return [raw];
                default:
                    return raw
            }
        };
    var normalizeAlign = function(raw) {
            var result = {
                    h: "center",
                    v: "center"
                };
            var pair = splitPair(raw);
            if (pair)
                $.each(pair, function() {
                    var w = String(this).toLowerCase();
                    if (horzRe.test(w))
                        result.h = w;
                    else if (vertRe.test(w))
                        result.v = w
                });
            return result
        };
    var normalizeOffset = function(raw) {
            var pair = splitPair(raw),
                h = parseInt(pair && pair[0], 10),
                v = parseInt(pair && pair[1], 10);
            if (!isFinite(h))
                h = 0;
            if (!isFinite(v))
                v = h;
            return {
                    h: h,
                    v: v
                }
        };
    var normalizeCollision = function(raw) {
            var pair = splitPair(raw),
                h = String(pair && pair[0]).toLowerCase(),
                v = String(pair && pair[1]).toLowerCase();
            if (!collisionRe.test(h))
                h = "none";
            if (!collisionRe.test(v))
                v = h;
            return {
                    h: h,
                    v: v
                }
        };
    var getAlignFactor = function(align) {
            switch (align) {
                case"center":
                    return 0.5;
                case"right":
                case"bottom":
                    return 1;
                default:
                    return 0
            }
        };
    var inverseAlign = function(align) {
            switch (align) {
                case"left":
                    return "right";
                case"right":
                    return "left";
                case"top":
                    return "bottom";
                case"bottom":
                    return "top";
                default:
                    return align
            }
        };
    var initMyLocation = function(data) {
            data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset
        };
    var decolliders = {
            fit: function(data, bounds) {
                if (data.myLocation > bounds.max)
                    data.myLocation = bounds.max;
                if (data.myLocation < bounds.min)
                    data.myLocation = bounds.min
            },
            flip: function(data, bounds) {
                if (data.myAlign === "center" && data.atAlign === "center")
                    return;
                if (data.myLocation < bounds.min || data.myLocation > bounds.max) {
                    var inverseData = $.extend({}, data, {
                            myAlign: inverseAlign(data.myAlign),
                            atAlign: inverseAlign(data.atAlign),
                            offset: -data.offset
                        });
                    initMyLocation(inverseData);
                    if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || inverseData.myLocation > data.myLocation)
                        data.myLocation = inverseData.myLocation
                }
            }
        };
    var scrollbarWidth;
    var position = function(what, options) {
            var $what = $(what);
            if (!options)
                return $what.offset();
            var my = normalizeAlign(options.my),
                at = normalizeAlign(options.at),
                of = options.of || window,
                offset = normalizeOffset(options.offset),
                collision = normalizeCollision(options.collision);
            var h = {
                    mySize: $what.outerWidth(),
                    myAlign: my.h,
                    atAlign: at.h,
                    offset: offset.h,
                    collision: collision.h
                };
            var v = {
                    mySize: $what.outerHeight(),
                    myAlign: my.v,
                    atAlign: at.v,
                    offset: offset.v,
                    collision: collision.v
                };
            if (of.preventDefault) {
                h.atLocation = of.pageX;
                v.atLocation = of.pageY;
                h.atSize = 0;
                v.atSize = 0
            }
            else {
                of = $(of);
                if ($.isWindow(of[0])) {
                    h.atLocation = of.scrollLeft();
                    v.atLocation = of.scrollTop();
                    h.atSize = window.innerWidth;
                    v.atSize = window.innerHeight
                }
                else if (of[0].nodeType === 9) {
                    h.atLocation = 0;
                    v.atLocation = 0;
                    h.atSize = of.width();
                    v.atSize = of.height()
                }
                else {
                    var o = of.offset();
                    h.atLocation = o.left;
                    v.atLocation = o.top;
                    h.atSize = of.outerWidth();
                    v.atSize = of.outerHeight()
                }
            }
            initMyLocation(h);
            initMyLocation(v);
            var bounds = function() {
                    var win = $(window),
                        left = win.scrollLeft(),
                        top = win.scrollTop();
                    if (scrollbarWidth === undefined)
                        scrollbarWidth = calculateScrollbarWidth();
                    var hScrollbar = document.width > document.documentElement.clientWidth,
                        vScrollbar = document.height > document.documentElement.clientHeight,
                        hZoomLevel = DX.support.touch ? document.documentElement.clientWidth / (vScrollbar ? window.innerWidth - scrollbarWidth : window.innerWidth) : 1,
                        vZoomLevel = DX.support.touch ? document.documentElement.clientHeight / (hScrollbar ? window.innerHeight - scrollbarWidth : window.innerHeight) : 1;
                    return {
                            h: {
                                min: left,
                                max: left + win.width() / hZoomLevel - h.mySize
                            },
                            v: {
                                min: top,
                                max: top + win.height() / vZoomLevel - v.mySize
                            }
                        }
                }();
            if (decolliders[h.collision])
                decolliders[h.collision](h, bounds.h);
            if (decolliders[v.collision])
                decolliders[v.collision](v, bounds.v);
            $what.offset({
                left: Math.round(h.myLocation),
                top: Math.round(v.myLocation)
            })
        };
    DX.position = position;
    var calculateScrollbarWidth = function() {
            var $scrollDiv = $("<div>").css({
                    width: 100,
                    height: 100,
                    overflow: "scroll",
                    position: "absolute",
                    top: -9999
                }).appendTo($("body")),
                result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
            $scrollDiv.remove();
            return result
        }
})(jQuery, DevExpress);

// Module core, file action.js

(function($, DX, undefined) {
    var actionExecutors = {};
    var registerExecutor = function(name, executor) {
            if ($.isPlainObject(name)) {
                $.each(name, registerExecutor);
                return
            }
            actionExecutors[name] = executor
        };
    var unregisterExecutor = function(name) {
            var args = $.makeArray(arguments);
            $.each(args, function() {
                delete actionExecutors[this]
            })
        };
    registerExecutor({
        func: {execute: function(e) {
                if ($.isFunction(e.action)) {
                    e.result = e.action.apply(e.context, e.args);
                    e.handled = true
                }
            }},
        url: {execute: function(e) {
                if (typeof e.action === "string" && e.action.charAt(0) !== "#")
                    document.location = e.action
            }},
        hash: {execute: function(e) {
                if (typeof e.action === "string" && e.action.charAt(0) === "#")
                    document.location.hash = e.action
            }}
    });
    var Action = DX.Class.inherit({
            ctor: function(action, config) {
                config = config || {};
                this._action = action || $.noop;
                this._context = config.context || window;
                this._beforeExecute = config.beforeExecute || $.noop;
                this._afterExecute = config.afterExecute || $.noop;
                this._component = config.component
            },
            execute: function() {
                var e = {
                        action: this._action,
                        args: Array.prototype.slice.call(arguments),
                        context: this._context,
                        component: this._component,
                        canceled: false,
                        handled: false
                    };
                if (!this._validateAction(e))
                    return;
                this._beforeExecute.call(this._context, e);
                if (e.canceled)
                    return;
                var result = this._executeAction(e);
                this._afterExecute.call(this._context, e);
                return result
            },
            _validateAction: function(e) {
                $.each(actionExecutors, function(index, executor) {
                    if (executor.validate)
                        executor.validate(e);
                    if (e.canceled)
                        return false
                });
                return !e.canceled
            },
            _executeAction: function(e) {
                var result;
                $.each(actionExecutors, function(index, executor) {
                    if (executor.execute)
                        executor.execute(e);
                    if (e.handled) {
                        result = e.result;
                        return false
                    }
                });
                return result
            }
        });
    $.extend(DX, {
        registerActionExecutor: registerExecutor,
        unregisterActionExecutor: unregisterExecutor,
        Action: Action
    });
    DX.__internals = {actionExecutors: actionExecutors}
})(jQuery, DevExpress);

// Module core, file utils.js

(function($, DX, undefined) {
    var PI = Math.PI,
        LN10 = Math.LN10;
    var cos = Math.cos,
        sin = Math.sin,
        abs = Math.abs,
        log = Math.log,
        floor = Math.floor,
        ceil = Math.ceil,
        max = Math.max,
        min = Math.min,
        pow = Math.pow,
        isNaN = window.isNaN,
        Number = window.Number,
        NaN = window.NaN;
    var dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'];
    var isDefined = function(object) {
            return object !== null && object !== undefined
        };
    var isString = function(object) {
            return $.type(object) === 'string'
        };
    var isNumber = function(object) {
            return $.isNumeric(object)
        };
    var isObject = function(object) {
            return $.type(object) === 'object'
        };
    var isArray = function(object) {
            return $.type(object) === 'array'
        };
    var isDate = function(object) {
            return $.type(object) === 'date'
        };
    var isFunction = function(object) {
            return $.type(object) === 'function'
        };
    var toMilliseconds = function(value) {
            switch (value) {
                case'millisecond':
                    return 1;
                case'second':
                    return toMilliseconds('millisecond') * 1000;
                case'minute':
                    return toMilliseconds('second') * 60;
                case'hour':
                    return toMilliseconds('minute') * 60;
                case'day':
                    return toMilliseconds('hour') * 24;
                case'week':
                    return toMilliseconds('day') * 7;
                case'month':
                    return toMilliseconds('day') * 30;
                case'quarter':
                    return toMilliseconds('month') * 3;
                case'year':
                    return toMilliseconds('day') * 365;
                default:
                    return 0
            }
        };
    var convertDateUnitToMilliseconds = function(dateUnit, count) {
            return toMilliseconds(dateUnit) * count
        };
    var convertMillisecondsToDateUnits = function(value) {
            var i,
                dateUnitCount,
                dateUnitInterval,
                dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'],
                result = {};
            for (i = dateUnitIntervals.length - 1; i >= 0; i--) {
                dateUnitInterval = dateUnitIntervals[i];
                dateUnitCount = Math.floor(value / toMilliseconds(dateUnitInterval));
                if (dateUnitCount > 0) {
                    result[dateUnitInterval + 's'] = dateUnitCount;
                    value -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount)
                }
            }
            return result
        };
    var convertDateTickIntervalToMilliseconds = function(tickInterval) {
            var milliseconds = 0;
            if (isObject(tickInterval))
                $.each(tickInterval, function(key, value) {
                    milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value)
                });
            if (isString(tickInterval))
                milliseconds = convertDateUnitToMilliseconds(tickInterval, 1);
            return milliseconds
        };
    var getDatesDifferences = function(date1, date2) {
            var differences,
                counter = 0;
            differences = {
                year: date1.getFullYear() !== date2.getFullYear(),
                month: date1.getMonth() !== date2.getMonth(),
                day: date1.getDate() !== date2.getDate(),
                hour: date1.getHours() !== date2.getHours(),
                minute: date1.getMinutes() !== date2.getMinutes(),
                second: date1.getSeconds() !== date2.getSeconds()
            };
            $.each(differences, function(key, value) {
                if (value)
                    counter++
            });
            differences.count = counter;
            return differences
        };
    var getFraction = function(value) {
            var valueString,
                indexPoint;
            if (isNumber(value)) {
                valueString = value.toFixed(20);
                indexPoint = valueString.indexOf('.');
                return valueString.substr(indexPoint + 1, valueString.length - indexPoint + 1)
            }
            return ''
        };
    var getSignificantDigitPosition = function(value) {
            var fraction = getFraction(value),
                i;
            if (fraction)
                for (i = 0; i < fraction.length; i++)
                    if (fraction.charAt(i) !== '0')
                        return i + 1;
            return 0
        };
    var addSubValues = function(value1, value2, isSub) {
            return value1 + (isSub ? -1 : 1) * value2
        };
    var isExponential = function(value) {
            return isNumber(value) && value.toString().indexOf('e') !== -1
        };
    var addInterval = function(value, interval, isNegative) {
            var result = null,
                intervalObject;
            if (isDate(value)) {
                intervalObject = isString(interval) ? getDateIntervalByString(interval.toLowerCase()) : interval;
                result = new Date(value.getTime());
                if (intervalObject.years)
                    result.setFullYear(addSubValues(result.getFullYear(), intervalObject.years, isNegative));
                if (intervalObject.quarters)
                    result.setMonth(addSubValues(result.getMonth(), 3 * intervalObject.quarters, isNegative));
                if (intervalObject.months)
                    result.setMonth(addSubValues(result.getMonth(), intervalObject.months, isNegative));
                if (intervalObject.weeks)
                    result.setDate(addSubValues(result.getDate(), 7 * intervalObject.weeks, isNegative));
                if (intervalObject.days)
                    result.setDate(addSubValues(result.getDate(), intervalObject.days, isNegative));
                if (intervalObject.hours)
                    result.setHours(addSubValues(result.getHours(), intervalObject.hours, isNegative));
                if (intervalObject.minutes)
                    result.setMinutes(addSubValues(result.getMinutes(), intervalObject.minutes, isNegative));
                if (intervalObject.seconds)
                    result.setSeconds(addSubValues(result.getSeconds(), intervalObject.seconds, isNegative));
                if (intervalObject.milliseconds)
                    result.setMilliseconds(addSubValues(value.getMilliseconds(), intervalObject.milliseconds, isNegative))
            }
            else
                result = addSubValues(value, interval, isNegative);
            return result
        };
    var getDateUnitInterval = function(tickInterval) {
            var maxInterval = -1,
                i;
            if (isString(tickInterval))
                return tickInterval;
            if (isObject(tickInterval)) {
                $.each(tickInterval, function(key, value) {
                    for (i = 0; i < dateUnitIntervals.length; i++)
                        if (value && (key === dateUnitIntervals[i] + 's' || key === dateUnitIntervals[i]) && maxInterval < i)
                            maxInterval = i
                });
                return dateUnitIntervals[maxInterval]
            }
            return ''
        };
    var correctDateWithUnitBeginning = function(date, dateInterval) {
            var dayMonth,
                firstQuarterMonth,
                dateUnitInterval = getDateUnitInterval(dateInterval);
            switch (dateUnitInterval) {
                case'second':
                    date.setMilliseconds(0);
                    break;
                case'minute':
                    date.setSeconds(0, 0);
                    break;
                case'hour':
                    date.setMinutes(0, 0, 0);
                    break;
                case'year':
                    date.setMonth(0);
                case'month':
                    date.setDate(1);
                case'day':
                    date.setHours(0, 0, 0, 0);
                    break;
                case'week':
                    dayMonth = date.getDate();
                    if (date.getDay() !== 0)
                        dayMonth += 7 - date.getDay();
                    date.setDate(dayMonth);
                    date.setHours(0, 0, 0, 0);
                    break;
                case'quarter':
                    firstQuarterMonth = DX.formatHelper.getFirstQuarterMonth(date.getMonth());
                    if (date.getMonth() !== firstQuarterMonth)
                        date.setMonth(firstQuarterMonth);
                    date.setDate(1);
                    date.setHours(0, 0, 0, 0);
                    break
            }
        };
    var roundValue = function(value, precision) {
            if (isNumber(value))
                if (isExponential(value))
                    return Number(value.toExponential(precision));
                else
                    return Number(value.toFixed(precision))
        };
    var getPrecision = function(value) {
            var stringFraction,
                stringValue = value.toString(),
                pointIndex = stringValue.indexOf('.');
            if (pointIndex !== -1) {
                stringFraction = stringValue.substring(pointIndex + 1);
                return stringFraction.length
            }
            return 0
        };
    var applyPrecisionByMinDelta = function(min, delta, value) {
            var minPrecision = getPrecision(min),
                deltaPrecision = getPrecision(delta);
            return roundValue(value, minPrecision < deltaPrecision ? deltaPrecision : minPrecision)
        };
    var adjustValue = function(value) {
            var fraction = getFraction(value),
                nextValue,
                i;
            if (fraction)
                for (i = 1; i <= fraction.length; i++) {
                    nextValue = roundValue(value, i);
                    if (nextValue !== 0 && fraction[i - 2] && fraction[i - 1] && fraction[i - 2] === fraction[i - 1])
                        return nextValue
                }
            return value
        };
    var getDateIntervalByString = function(intervalString) {
            var result = {};
            switch (intervalString) {
                case'year':
                    result.years = 1;
                    break;
                case'month':
                    result.months = 1;
                    break;
                case'quarter':
                    result.months = 3;
                    break;
                case'week':
                    result.days = 7;
                    break;
                case'day':
                    result.days = 1;
                    break;
                case'hour':
                    result.hours = 1;
                    break;
                case'minute':
                    result.minutes = 1;
                    break;
                case'second':
                    result.seconds = 1;
                    break;
                case'millisecond':
                    result.milliseconds = 1;
                    break
            }
            return result
        };
    var normalizeAngle = function(angle) {
            return (angle % 360 + 360) % 360
        };
    var convertAngleToRendererSpace = function(angle) {
            return 90 - angle
        };
    var degreesToRadians = function(value) {
            return PI * value / 180
        };
    var getCosAndSin = function(angle) {
            var angleInRadians = degreesToRadians(angle);
            return {
                    cos: cos(angleInRadians),
                    sin: sin(angleInRadians)
                }
        };
    var DECIMAL_ORDER_THRESHOLD = 1E-14;
    var getDecimalOrder = function(number) {
            var n = abs(number),
                cn;
            if (!isNaN(n)) {
                if (n > 0) {
                    n = log(n) / LN10;
                    cn = ceil(n);
                    return cn - n < DECIMAL_ORDER_THRESHOLD ? cn : floor(n)
                }
                return 0
            }
            return NaN
        };
    var getAppropriateFormat = function(start, end, count) {
            var order = max(getDecimalOrder(start), getDecimalOrder(end)),
                precision = -getDecimalOrder(abs(end - start) / count),
                format;
            if (!isNaN(order) && !isNaN(precision)) {
                if (abs(order) <= 4) {
                    format = 'fixedPoint';
                    precision < 0 && (precision = 0);
                    precision > 4 && (precision = 4)
                }
                else {
                    format = 'exponential';
                    precision += order - 1;
                    precision > 3 && (precision = 3)
                }
                return {
                        format: format,
                        precision: precision
                    }
            }
            return null
        };
    var logger = function() {
            var info = function() {
                    if (window.console && arguments[0])
                        console.info(arguments[0])
                };
            var warn = function() {
                    if (window.console && arguments[0])
                        console.warn(arguments[0])
                };
            var error = function() {
                    if (window.console && arguments[0])
                        console.error(arguments[0])
                };
            return {
                    info: info,
                    warn: warn,
                    error: error
                }
        }();
    var debug = function() {
            function assert(condition, message) {
                if (!condition)
                    throw new Error(message);
            }
            function assertParam(parameter, message) {
                assert(parameter !== null && parameter !== undefined, message)
            }
            return {
                    assert: assert,
                    assertParam: assertParam
                }
        }();
    var windowResizeCallbacks = function() {
            var prevSize,
                callbacks = $.Callbacks(),
                jqWindow = $(window);
            var formatSize = function() {
                    return [jqWindow.width(), jqWindow.height()].join()
                };
            var handleResize = function() {
                    var now = formatSize();
                    if (now === prevSize)
                        return;
                    prevSize = now;
                    callbacks.fire()
                };
            jqWindow.on("resize", handleResize);
            prevSize = formatSize();
            return callbacks
        }();
    var createMarkupFromString = function(str) {
            var tempElement = $("<div />");
            if (window.WinJS)
                WinJS.Utilities.setInnerHTMLUnsafe(tempElement.get(0), str);
            else
                tempElement.append(str);
            return tempElement.contents()
        };
    var numClipRect = 1;
    var numPattern = 1;
    var getNextClipId = function() {
            return 'DevExpress_' + numClipRect++
        };
    var getNextPatternId = function() {
            return 'DevExpressPattern_' + numPattern++
        };
    var extendFromDataAttributes = function(target, $el, overrideExistingValues) {
            target = target || {};
            var source = {};
            var prefix = "data-dx-";
            var attributes = $el.get(0).attributes;
            for (var i = 0; i < attributes.length; i++) {
                var name = attributes[i].name;
                if (name.indexOf(prefix) === 0) {
                    var propertyName = DX.inflector.camelize(name.substr(prefix.length));
                    source[propertyName] = attributes[i].value
                }
            }
            return extendFromObject(target, source, overrideExistingValues)
        };
    var extendFromObject = function(target, source, overrideExistingValues) {
            target = target || {};
            for (var prop in source)
                if (source.hasOwnProperty(prop)) {
                    var value = source[prop];
                    if (!(prop in target) || overrideExistingValues)
                        target[prop] = value
                }
            return target
        };
    function Clone(){}
    var clone = function(obj) {
            Clone.prototype = obj;
            return new Clone
        };
    var executeAsync = function(action, context) {
            var deferred = $.Deferred(),
                normalizedContext = context || this;
            setTimeout(function() {
                var result = action.call(normalizedContext);
                if (result && result.done && $.isFunction(result.done))
                    result.done(function() {
                        deferred.resolveWith(normalizedContext)
                    });
                else
                    deferred.resolveWith(normalizedContext)
            }, 0);
            return deferred.promise()
        };
    DX.utils = {
        dateUnitIntervals: dateUnitIntervals,
        isDefined: isDefined,
        isString: isString,
        isNumber: isNumber,
        isObject: isObject,
        isArray: isArray,
        isDate: isDate,
        isFunction: isFunction,
        normalizeAngle: normalizeAngle,
        convertAngleToRendererSpace: convertAngleToRendererSpace,
        degreesToRadians: degreesToRadians,
        getCosAndSin: getCosAndSin,
        getDecimalOrder: getDecimalOrder,
        getAppropriateFormat: getAppropriateFormat,
        getFraction: getFraction,
        adjustValue: adjustValue,
        convertMillisecondsToDateUnits: convertMillisecondsToDateUnits,
        convertDateTickIntervalToMilliseconds: convertDateTickIntervalToMilliseconds,
        convertDateUnitToMilliseconds: convertDateUnitToMilliseconds,
        getDateUnitInterval: getDateUnitInterval,
        getDatesDifferences: getDatesDifferences,
        correctDateWithUnitBeginning: correctDateWithUnitBeginning,
        roundValue: roundValue,
        isExponential: isExponential,
        applyPrecisionByMinDelta: applyPrecisionByMinDelta,
        getSignificantDigitPosition: getSignificantDigitPosition,
        addInterval: addInterval,
        getDateIntervalByString: getDateIntervalByString,
        logger: logger,
        debug: debug,
        windowResizeCallbacks: windowResizeCallbacks,
        createMarkupFromString: createMarkupFromString,
        getNextClipId: getNextClipId,
        getNextPatternId: getNextPatternId,
        extendFromDataAttributes: extendFromDataAttributes,
        extendFromObject: extendFromObject,
        clone: clone,
        executeAsync: executeAsync
    }
})(jQuery, DevExpress);

// Module core, file translator.js

(function($, DX, undefined) {
    var support = DX.support,
        TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/,
        TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
    var locate = function($element) {
            var result,
                position;
            if (support.transform3d) {
                var translate = getTranslate($element);
                result = {
                    left: translate.x,
                    top: translate.y
                }
            }
            else {
                position = $element.position();
                result = {
                    left: position.left,
                    top: position.top
                }
            }
            return result
        };
    var move = function($element, position) {
            if (!support.transform3d) {
                $element.css(position);
                return
            }
            var translate = getTranslate($element),
                left = position.left,
                top = position.top;
            if (left !== undefined)
                translate.x = left;
            if (top !== undefined)
                translate.y = top;
            $element.css("transform", getTranslateCss(translate))
        };
    var getTranslate = function($element) {
            var transformValue = $element.css("transform"),
                matrix = transformValue.match(TRANSFORM_MATRIX_REGEX),
                is3D = matrix && matrix[1];
            if (matrix) {
                matrix = matrix[2].split(",");
                if (is3D === "3d")
                    matrix = matrix.slice(12, 15);
                else {
                    matrix.push(0);
                    matrix = matrix.slice(4, 7)
                }
            }
            else
                matrix = [0, 0, 0];
            return {
                    x: parseFloat(matrix[0]),
                    y: parseFloat(matrix[1]),
                    z: parseFloat(matrix[2])
                }
        };
    var parseTranslate = function(translateString) {
            var result = translateString.match(TRANSLATE_REGEX);
            if (!result || !result[1])
                return;
            result = result[1].split(",");
            result = {
                x: parseFloat(result[0]),
                y: parseFloat(result[1]),
                z: parseFloat(result[2])
            };
            return result
        };
    var getTranslateCss = function(translate) {
            return "translate3d(" + (translate.x || 0) + "px, " + (translate.y || 0) + "px, " + (translate.z || 0) + "px)"
        };
    DX.translator = {
        move: move,
        locate: locate,
        parseTranslate: parseTranslate,
        getTranslate: getTranslate,
        getTranslateCss: getTranslateCss
    }
})(jQuery, DevExpress);

// Module core, file devices.js

(function($, DX, undefined) {
    var knownUATable = {
            iPhone: "iPhone",
            iPhone5: "iPhone 5",
            iPad: "iPad",
            iPadMini: "iPad Mini",
            androidPhone: "Android Mobile",
            androidTablet: "Android",
            win8: "MSAppHost",
            win8Phone: "Windows Phone 8",
            msSurface: "MSIE ARM Tablet PC",
            desktop: "desktop"
        };
    var desktopDevice = {
            phone: false,
            tablet: false,
            android: false,
            ios: false,
            win8: false,
            platform: "desktop"
        };
    var fromUA = function(ua) {
            var ipad = /ipad/i.test(ua),
                iphone = /iphone|ipod/i.test(ua),
                android = /android/i.test(ua),
                win8Phone = /windows phone 8/i.test(ua),
                msSurface = /msie(.*)arm(.*)tablet\spc/i.test(ua),
                win8 = /msapphost/i.test(ua) || win8Phone || msSurface;
            if (!ipad && !iphone && !android && !win8 && !win8Phone && !msSurface)
                return $.extend({}, desktopDevice);
            var phone = iphone || android && /mobile/i.test(ua) || win8Phone,
                tablet = !phone && !win8 && !win8Phone,
                name = android ? "android" : win8 ? "win8" : "ios";
            return {
                    phone: phone,
                    tablet: tablet,
                    android: android,
                    ios: ipad || iphone,
                    win8: name === "win8",
                    platform: name
                }
        };
    var forcedDeviceName;
    var forceDevice = function(name) {
            forcedDeviceName = name
        };
    var getDevice = function(deviceName) {
            var ua;
            deviceName = forcedDeviceName || deviceName || window.sessionStorage && (sessionStorage.getItem("dx-simulator-device") || sessionStorage.getItem("dx-device"));
            if (deviceName) {
                ua = knownUATable[deviceName];
                if (!ua)
                    throw Error("Unknown device");
            }
            else
                ua = navigator.userAgent;
            return fromUA(ua)
        };
    var androidVersion = function(userAgent) {
            userAgent = userAgent || window.navigator.userAgent;
            var matches = /Android (\d\.\d(?:\.\d)?)/.exec(userAgent);
            if (matches && matches.length === 2)
                return matches[1]
        };
    var current = function(deviceName) {
            if (deviceName)
                forceDevice(deviceName);
            return getDevice(deviceName)
        };
    DX.devices = {
        androidVersion: androidVersion,
        current: current,
        fromUA: function() {
            return fromUA(navigator.userAgent)
        }
    }
})(jQuery, DevExpress);

// Module core, file fx.js

(function($, DX, undefined) {
    var translator = DX.translator,
        support = DX.support,
        devices = DX.devices,
        transitionEndEventName = support.transitionEndEventName;
    var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/,
        SIMULATED_TRANSITIONEND_TIMEOUT_DATA_KEY = "dxSimulatedTransitionTimeoutKey",
        ANIM_DATA_KEY = "dxAnimData",
        TRANSFORM_PROP = "transform",
        BACKFACEVISIBILITY_PROP = "backfaceVisibility",
        FRAME_ANIMATION_STEP_TIME = 1000 / 60;
    var TransitionAnimationStrategy = {
            animate: function($element, config) {
                var deferred = $.Deferred(),
                    transitionEndFired = $.Deferred(),
                    simulatedTransitionEndFired = $.Deferred();
                $element.one(transitionEndEventName, function() {
                    transitionEndFired.reject()
                });
                $element.data(SIMULATED_TRANSITIONEND_TIMEOUT_DATA_KEY, setTimeout(function() {
                    simulatedTransitionEndFired.reject()
                }, config.duration + config.delay));
                $.when(transitionEndFired, simulatedTransitionEndFired).fail($.proxy(function() {
                    this._clearTransition($element);
                    deferred.resolveWith($element, [config, $element])
                }, this));
                translator.getTranslate($element);
                $element.css({
                    transitionProperty: "all",
                    transitionDelay: config.delay + "ms",
                    transitionDuration: config.duration + "ms",
                    transitionTimingFunction: config.easing
                });
                setProps($element, config.to);
                if (!config.duration)
                    $element.trigger(transitionEndEventName);
                return deferred.promise()
            },
            _clearTransition: function($element) {
                $element.css("transition", "none")
            },
            stop: function($element, jumpToEnd) {
                var config = $element.data(ANIM_DATA_KEY);
                if (!config)
                    return;
                if (jumpToEnd)
                    $element.trigger(transitionEndEventName);
                else {
                    $.each(config.to, function(key) {
                        $element.css(key, $element.css(key))
                    });
                    clearTimeout($element.data(SIMULATED_TRANSITIONEND_TIMEOUT_DATA_KEY));
                    $element.off(transitionEndEventName);
                    this._clearTransition($element)
                }
            }
        };
    var requestAnimationFrame = function() {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
                    window.setTimeout(callback, FRAME_ANIMATION_STEP_TIME)
                }
        }();
    var FrameAnimationStrategy = {
            animate: function($element, config) {
                var deferred = $.Deferred(),
                    animationData = $element.data(ANIM_DATA_KEY),
                    self = this;
                if (!animationData)
                    return deferred.reject().promise();
                $.each(config.to, function(prop) {
                    if (config.from[prop] === undefined)
                        config.from[prop] = self._normalizeValue($element.css(prop))
                });
                if (config.to[TRANSFORM_PROP]) {
                    config.from[TRANSFORM_PROP] = self._parseTransform(config.from[TRANSFORM_PROP]);
                    config.to[TRANSFORM_PROP] = self._parseTransform(config.to[TRANSFORM_PROP])
                }
                animationData.frameAnimation = {
                    to: config.to,
                    from: config.from,
                    currentValue: config.from,
                    easing: convertTransitionTimingFuncToJQueryEasing(config.easing),
                    duration: config.duration,
                    startTime: (new Date).valueOf(),
                    finish: function() {
                        this.currentValue = this.to;
                        this.draw();
                        deferred.resolve()
                    },
                    draw: function() {
                        var currentValue = $.extend({}, this.currentValue);
                        if (currentValue[TRANSFORM_PROP])
                            currentValue[TRANSFORM_PROP] = $.map(currentValue[TRANSFORM_PROP], function(value, prop) {
                                if (prop === "translate")
                                    return translator.getTranslateCss(value);
                                else if (prop === "scale")
                                    return "scale(" + value + ")";
                                else if (prop.substr(0, prop.length - 1) === "rotate")
                                    return prop + "(" + value + "deg)"
                            }).join(" ");
                        $element.css(currentValue)
                    }
                };
                if (config.delay) {
                    animationData.frameAnimation.startTime += config.delay;
                    animationData.frameAnimation.delayTimeout = setTimeout(function() {
                        self._animationStep($element)
                    }, config.delay)
                }
                else
                    self._animationStep($element);
                return deferred.promise()
            },
            _parseTransform: function(transformString) {
                var result = {};
                $.each(transformString.match(/(\w|\d)+\([^\)]*\)\s*/g), function(i, part) {
                    var translateData = translator.parseTranslate(part),
                        scaleData = part.match(/scale\((.+?)\)/),
                        rotateData = part.match(/(rotate.)\((.+)deg\)/);
                    if (translateData)
                        result.translate = translateData;
                    if (scaleData && scaleData[1])
                        result.scale = parseFloat(scaleData[1]);
                    if (rotateData && rotateData[1])
                        result[rotateData[1]] = parseFloat(rotateData[2])
                });
                return result
            },
            stop: function($element, jumpToEnd) {
                var animationData = $element.data(ANIM_DATA_KEY),
                    frameAnimation = animationData && animationData.frameAnimation;
                if (!frameAnimation)
                    return;
                clearTimeout(frameAnimation.delayTimeout);
                if (jumpToEnd)
                    frameAnimation.finish()
            },
            _animationStep: function($element) {
                var animationData = $element.data(ANIM_DATA_KEY),
                    frameAnimation = animationData && animationData.frameAnimation;
                if (!frameAnimation)
                    return;
                var now = (new Date).valueOf();
                if (now >= frameAnimation.startTime + frameAnimation.duration) {
                    frameAnimation.finish();
                    return
                }
                frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
                frameAnimation.draw();
                requestAnimationFrame($.proxy(function() {
                    this._animationStep($element)
                }, this))
            },
            _calcStepValue: function(frameAnimation, currentDuration) {
                var calcValueRecursively = function(from, to) {
                        var result = $.isArray(to) ? [] : {};
                        var calcEasedValue = function(propName) {
                                var x = currentDuration / frameAnimation.duration,
                                    t = currentDuration,
                                    b = 1 * from[propName],
                                    c = to[propName] - from[propName],
                                    d = frameAnimation.duration;
                                return $.easing[frameAnimation.easing](x, t, b, c, d)
                            };
                        $.each(to, function(propName, endPropValue) {
                            if (typeof endPropValue === "string" && parseFloat(endPropValue, 10) === false)
                                return true;
                            result[propName] = typeof endPropValue === "object" ? calcValueRecursively(from[propName], endPropValue) : calcEasedValue(propName)
                        });
                        return result
                    };
                return calcValueRecursively(frameAnimation.from, frameAnimation.to)
            },
            _normalizeValue: function(value) {
                var numericValue = parseFloat(value, 10);
                if (numericValue === false)
                    return value;
                return numericValue
            }
        };
    var animationStrategies = {
            transition: support.transition ? TransitionAnimationStrategy : FrameAnimationStrategy,
            frame: FrameAnimationStrategy
        };
    var getAnimationStrategy = function(config) {
            return animationStrategies[config && config.strategy || "transition"]
        };
    var TransitionTimingFuncMap = {
            linear: "cubic-bezier(0, 0, 1, 1)",
            ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
            "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
            "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
            "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
        };
    var convertTransitionTimingFuncToJQueryEasing = function(cssTransitionEasing) {
            cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
            var bezCoeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
            if (!bezCoeffs)
                return "linear";
            bezCoeffs = bezCoeffs.slice(1, 5);
            $.each(bezCoeffs, function(index, value) {
                bezCoeffs[index] = parseFloat(value)
            });
            var easingName = "cubicbezier_" + bezCoeffs.join("_").replace(/\./g, "p");
            if (!$.isFunction($.easing[easingName])) {
                var polynomBezier = function(x1, y1, x2, y2) {
                        var Cx = 3 * x1,
                            Bx = 3 * (x2 - x1) - Cx,
                            Ax = 1 - Cx - Bx,
                            Cy = 3 * y1,
                            By = 3 * (y2 - y1) - Cy,
                            Ay = 1 - Cy - By;
                        var bezierX = function(t) {
                                return t * (Cx + t * (Bx + t * Ax))
                            };
                        var bezierY = function(t) {
                                return t * (Cy + t * (By + t * Ay))
                            };
                        var findXfor = function(t) {
                                var x = t,
                                    i = 0,
                                    z;
                                while (i < 14) {
                                    z = bezierX(x) - t;
                                    if (Math.abs(z) < 1e-3)
                                        break;
                                    x = x - z / derivativeX(x);
                                    i++
                                }
                                return x
                            };
                        var derivativeX = function(t) {
                                return Cx + t * (2 * Bx + t * 3 * Ax)
                            };
                        return function(t) {
                                return bezierY(findXfor(t))
                            }
                    };
                $.easing[easingName] = function(x, t, b, c, d) {
                    return c * polynomBezier(bezCoeffs[0], bezCoeffs[1], bezCoeffs[2], bezCoeffs[3])(t / d) + b
                }
            }
            return easingName
        };
    var NoneAnimationConfigurator = {setup: function($element, config){}};
    var SlideAnimationConfigurator = {
            setup: function($element, config) {
                var animStrategy = getAnimationStrategy(config);
                if (!support.transform3d || animStrategy !== TransitionAnimationStrategy && animStrategy !== FrameAnimationStrategy)
                    return;
                this._setupConfig($element, config.from);
                this._setupConfig($element, config.to)
            },
            _setupConfig: function($element, config) {
                var translate = translator.getTranslate($element),
                    left = config.left,
                    top = config.top;
                if (left !== undefined) {
                    translate.x = left;
                    delete config.left
                }
                if (top !== undefined) {
                    translate.y = top;
                    delete config.top
                }
                config[TRANSFORM_PROP] = translator.getTranslateCss(translate)
            }
        };
    var FadeAnimationConfigurator = {setup: function($element, config) {
                var from = config.from,
                    fromOpacity = $.isPlainObject(from) ? $element.css("opacity") : String(from),
                    toOpacity = String(config.to);
                config.from = {opacity: fromOpacity};
                config.to = {opacity: toOpacity}
            }};
    var PopAnimationConfigurator = {
            setup: function($element, config) {
                if (!support.transform3d)
                    return;
                var from = config.from,
                    to = config.to,
                    fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity"),
                    toOpacicy = "opacity" in to ? to.opacity : 1,
                    fromScale = "scale" in from ? from.scale : 0,
                    toScale = "scale" in to ? to.scale : 1;
                config.from = {opacity: fromOpacity};
                config.from[TRANSFORM_PROP] = this._getCssTransform(fromScale);
                config.to = {opacity: toOpacicy};
                config.to[TRANSFORM_PROP] = this._getCssTransform(toScale)
            },
            _getCssTransform: function(scale) {
                return "scale(" + scale + ")"
            }
        };
    var FlipAnimationConfigurator = {
            DIRECTIONS: ["left", "right", "top", "bottom"],
            setup: function($element, config) {
                if (!support.transform3d)
                    return;
                var from = config.from,
                    to = config.to,
                    direction = this._normalizeDirection(to.direction),
                    directionFactor = this._getDirectionFactor(direction),
                    axis = this._getAxis(direction),
                    fromRotate = "rotate" in from ? from.rotate : -directionFactor * 180,
                    toRotate = "rotate" in to ? to.rotate : directionFactor * 180,
                    fromScale = "scale" in from ? from.scale : directionFactor === 1 ? 1 : 0.8,
                    toScale = "scale" in to ? to.scale : directionFactor === 1 ? 0.8 : 1;
                config.from[TRANSFORM_PROP] = this._getCssTransform(axis, fromRotate, fromScale);
                config.from[BACKFACEVISIBILITY_PROP] = "hidden";
                config.to[TRANSFORM_PROP] = this._getCssTransform(axis, toRotate, toScale);
                config.to[BACKFACEVISIBILITY_PROP] = "hidden"
            },
            _normalizeDirection: function(direction) {
                var index = $.inArray(this.DIRECTIONS);
                if (index !== -1)
                    return direction;
                return "left"
            },
            _getAxis: function(direction) {
                if (direction === "left" || direction === "right")
                    return "Y";
                if (direction === "top" || direction === "bottom")
                    return "X"
            },
            _getDirectionFactor: function(direction) {
                if (direction === "left" || direction === "top")
                    return -1;
                if (direction === "right" || direction === "bottom")
                    return 1
            },
            _getCssTransform: function(axis, rotate, scale) {
                return "rotate" + axis + "(" + rotate + "deg) scale(" + scale + ")"
            }
        };
    var animationConfigurators = {
            none: NoneAnimationConfigurator,
            slide: SlideAnimationConfigurator,
            fade: FadeAnimationConfigurator,
            pop: PopAnimationConfigurator,
            flip: FlipAnimationConfigurator
        };
    var getAnimationConfigurator = function(type) {
            var result = animationConfigurators[type];
            if (!result)
                throw Error("Unknown animation type \"" + type + "\"");
            return result
        };
    var defaultConfig = {
            type: "none",
            from: {},
            to: {},
            duration: 400,
            complete: $.noop,
            easing: "ease",
            delay: 0
        };
    var animate = function(element, config) {
            var $element = $(element);
            config = $.extend(true, {}, defaultConfig, config);
            getAnimationConfigurator(config.type).setup($element, config);
            stop($element);
            setProps($element, config.from);
            return executeAnimation($element, config).done(config.complete)
        };
    var setProps = function($element, props) {
            $.each(props, function(key, value) {
                $element.css(key, value)
            })
        };
    var executeAnimation = function($element, config) {
            var deferred = $.Deferred();
            $element.data(ANIM_DATA_KEY, config);
            if (DX.fx.off)
                config.duration = 0;
            getAnimationStrategy(config).animate($element, config).done(function() {
                $element.removeData(ANIM_DATA_KEY);
                deferred.resolveWith(this, [$element, config])
            });
            return deferred.promise()
        };
    var animating = function($element) {
            return !!$element.data(ANIM_DATA_KEY)
        };
    var stop = function(element, jumpToEnd) {
            var $element = $(element);
            getAnimationStrategy($element.data(ANIM_DATA_KEY)).stop($element, jumpToEnd);
            $element.removeData(ANIM_DATA_KEY)
        };
    DX.fx = {
        off: false,
        animationTypes: animationConfigurators,
        animate: animate,
        animating: animating,
        stop: stop
    };
    DX.fx.__internals = {convertTransitionTimingFuncToJQueryEasing: convertTransitionTimingFuncToJQueryEasing}
})(jQuery, DevExpress);

// Module core, file endpointSelector.js

(function($, DX, undefined) {
    var location = window.location,
        DXPROXY_HOST = "dxproxy.devexpress.com:8000",
        WIN_JS = location.protocol === "ms-appx:",
        IS_DXPROXY = location.host === DXPROXY_HOST,
        IS_LOCAL = isLocalHostName(location.hostname);
    function isLocalHostName(url) {
        return /^(localhost$|127\.)/i.test(url)
    }
    var extractProxyAppId = function() {
            return location.pathname.split("/")[1]
        };
    var formatProxyUrl = function(localUrl) {
            var urlData = DX.parseUrl(localUrl);
            if (!isLocalHostName(urlData.hostname))
                return localUrl;
            return "http://" + DXPROXY_HOST + "/" + extractProxyAppId() + "_" + urlData.port + urlData.pathname + urlData.search
        };
    var EndpointSelector = DX.EndpointSelector = function(config) {
            this.config = config
        };
    EndpointSelector.prototype = {urlFor: function(key) {
            var bag = this.config[key];
            if (!bag)
                throw Error("Unknown endpoint key");
            if (IS_DXPROXY)
                return formatProxyUrl(bag.local);
            if (bag.production)
                if (WIN_JS && !Debug.debuggerEnabled || !WIN_JS && !IS_LOCAL)
                    return bag.production;
            return bag.local
        }}
})(jQuery, DevExpress);

// Module core, file formatHelper.js

(function($, DX, undefined) {
    var utils = DX.utils;
    DX.NumericFormat = {
        currency: 'C',
        fixedpoint: 'N',
        exponential: '',
        percent: 'P',
        decimal: 'D'
    };
    DX.LargeNumberFormatPostfixes = {
        1: 'K',
        2: 'M',
        3: 'B',
        4: 'T'
    };
    var MAX_LARGE_NUMBER_POWER = 4,
        DECIMAL_BASE = 10;
    DX.LargeNumberFormatPowers = {
        largenumber: 'auto',
        thousands: 1,
        millions: 2,
        billions: 3,
        trillions: 4
    };
    DX.DateTimeFormat = {
        longdate: 'D',
        longtime: 'T',
        monthandday: 'M',
        monthandyear: 'Y',
        quarterandyear: 'qq',
        shortdate: 'd',
        shorttime: 't',
        millisecond: 'fff',
        second: 'T',
        minute: 't',
        hour: 't',
        day: 'dd',
        week: 'dd',
        month: 'MMMM',
        quarter: 'qq',
        year: 'yyyy',
        longdatelongtime: 'D',
        shortdateshorttime: 'd'
    };
    DX.formatHelper = {
        romanDigits: ['I', 'II', 'III', 'IV'],
        _addFormatSeparator: function(format1, format2) {
            var separator = ' ';
            if (format2)
                return format1 + separator + format2;
            return format1
        },
        _getDateTimeFormatPattern: function(dateTimeFormat) {
            return Globalize.findClosestCulture().calendar.patterns[DX.DateTimeFormat[dateTimeFormat.toLowerCase()]]
        },
        _isDateFormatContains: function(format) {
            var result = false;
            $.each(DX.DateTimeFormat, function(key, value) {
                result = key === format.toLowerCase();
                return !result
            });
            return result
        },
        getQuarter: function(month) {
            return Math.floor(month / 3)
        },
        getQuarterString: function(date, format) {
            var resultQuarter = '',
                quarter = this.getQuarter(date.getMonth());
            switch (format) {
                case'q':
                    resultQuarter = this.romanDigits[quarter];
                    break;
                case'qq':
                    resultQuarter = 'Q' + this.romanDigits[quarter];
                    break;
                case'Q':
                    resultQuarter = (quarter + 1).toString();
                    break;
                case'QQ':
                    resultQuarter = 'Q' + (quarter + 1).toString();
                    break
            }
            return resultQuarter
        },
        getFirstQuarterMonth: function(month) {
            return this.getQuarter(month) * 3
        },
        _formatCustomString: function(value, format) {
            var regExp = /qq|q|QQ|Q/g,
                quarterFormat,
                result = '',
                index = 0;
            while (index < format.length) {
                quarterFormat = regExp.exec(format);
                if (!quarterFormat || quarterFormat.index > index)
                    result += Globalize.format(value, format.substring(index, quarterFormat ? quarterFormat.index : format.length));
                if (quarterFormat) {
                    result += this.getQuarterString(value, quarterFormat[0]);
                    index = quarterFormat.index + quarterFormat[0].length
                }
                else
                    index = format.length
            }
            return result
        },
        _parseNumberFormatString: function(format) {
            var formatList,
                formatObject = {};
            if (!format || typeof format !== 'string')
                return;
            formatList = format.toLowerCase().split(' ');
            $.each(formatList, function(index, value) {
                if (value in DX.NumericFormat)
                    formatObject.formatType = value;
                else if (value in DX.LargeNumberFormatPowers)
                    formatObject.power = DX.LargeNumberFormatPowers[value]
            });
            if (formatObject.power && !formatObject.formatType)
                formatObject.formatType = 'fixedpoint';
            if (formatObject.formatType)
                return formatObject
        },
        _calculateNumberPower: function(value, base, minPower, maxPower) {
            var number = Math.abs(value);
            var power = 0;
            if (number > 1)
                while (number && number >= base && (maxPower === undefined || power < maxPower)) {
                    power++;
                    number = number / base
                }
            else if (number > 0 && number < 1)
                while (number < 1 && (minPower === undefined || power > minPower)) {
                    power--;
                    number = number * base
                }
            return power
        },
        _getNumberByPower: function(number, power, base) {
            var result = number;
            while (power > 0) {
                result = result / base;
                power--
            }
            while (power < 0) {
                result = result * base;
                power++
            }
            return result
        },
        _formatNumber: function(value, formatObject, precision) {
            var powerPostfix;
            if (formatObject.power === 'auto')
                formatObject.power = this._calculateNumberPower(value, 1000, 0, MAX_LARGE_NUMBER_POWER);
            if (formatObject.power)
                value = this._getNumberByPower(value, formatObject.power, 1000);
            powerPostfix = DX.LargeNumberFormatPostfixes[formatObject.power] || '';
            return this._formatNumberCore(value, formatObject.formatType, precision) + powerPostfix
        },
        _formatNumberExponential: function(value, precision) {
            var power = this._calculateNumberPower(value, DECIMAL_BASE),
                number = this._getNumberByPower(value, power, DECIMAL_BASE),
                powString;
            precision = precision === undefined ? 1 : precision;
            if (number.toFixed(precision || 0) >= DECIMAL_BASE) {
                power++;
                number = number / DECIMAL_BASE
            }
            powString = (power >= 0 ? '+' : '') + power.toString();
            return this._formatNumberCore(number, 'fixedpoint', precision) + 'E' + powString
        },
        _formatNumberCore: function(value, format, precision) {
            if (format === 'exponential')
                return this._formatNumberExponential(value, precision);
            else
                return Globalize.format(value, DX.NumericFormat[format] + (utils.isNumber(precision) ? precision : 0))
        },
        _formatDate: function(date, format, formatString) {
            var resultFormat = DX.DateTimeFormat[format.toLowerCase()];
            format = format.toLowerCase();
            if (format === 'quarterandyear')
                resultFormat = this.getQuarterString(date, resultFormat) + ' yyyy';
            if (format === 'quarter')
                return this.getQuarterString(date, resultFormat);
            if (format === 'longdatelongtime')
                return this._formatDate(date, 'longdate') + ' ' + this._formatDate(date, 'longtime');
            if (format === 'shortdateshorttime')
                return this._formatDate(date, 'shortDate') + ' ' + this._formatDate(date, 'shortTime');
            return Globalize.format(date, resultFormat)
        },
        format: function(value, format, precision) {
            if (format && format.format)
                if (format.dateType)
                    return this._formatDateEx(value, format);
                else if (utils.isNumber(value) && isFinite(value))
                    return this._formatNumberEx(value, format);
            return this._format(value, format, precision)
        },
        _format: function(value, format, precision) {
            var numberFormatObject;
            if (!utils.isString(format) || format === '' || !utils.isNumber(value) && !utils.isDate(value))
                return utils.isDefined(value) ? value.toString() : '';
            numberFormatObject = this._parseNumberFormatString(format);
            if (utils.isNumber(value) && numberFormatObject)
                return this._formatNumber(value, numberFormatObject, precision);
            if (utils.isDate(value) && this._isDateFormatContains(format))
                return this._formatDate(value, format);
            if (!numberFormatObject && !this._isDateFormatContains(format))
                return this._formatCustomString(value, format)
        },
        _formatNumberEx: function(value, formatInfo) {
            var self = this,
                numericFormatType = DX.NumericFormat[formatInfo.format.toLowerCase()],
                numberFormat = Globalize.culture().numberFormat,
                currencyFormat = formatInfo.currencyCulture && Globalize.cultures[formatInfo.currencyCulture] ? Globalize.cultures[formatInfo.currencyCulture].numberFormat.currency : numberFormat.currency,
                percentFormat = numberFormat.percent,
                formatSettings = self._getUnitFormatSettings(value, formatInfo),
                unit = formatSettings.unit,
                precision = formatSettings.precision,
                showTrailingZeros = formatSettings.showTrailingZeros,
                floatingSymbol = numberFormat["."],
                number,
                isNegative,
                pattern,
                currentFormat,
                regexParts = /n|\$|-|%/g,
                result = "";
            value = self._applyUnitToValue(value, unit);
            number = Math.abs(value);
            isNegative = value < 0;
            switch (numericFormatType) {
                case"D":
                    pattern = "n";
                    number = Math[isNegative ? "ceil" : "floor"](number);
                    if (precision > 0) {
                        var str = "" + number;
                        for (var i = str.length; i < precision; i += 1)
                            str = "0" + str;
                        number = str
                    }
                    if (isNegative)
                        number = "-" + number;
                    break;
                case"N":
                    currentFormat = numberFormat;
                case"C":
                    currentFormat = currentFormat || currencyFormat;
                case"P":
                    currentFormat = currentFormat || percentFormat;
                    pattern = isNegative ? currentFormat.pattern[0] : currentFormat.pattern[1] || "n";
                    number = Globalize.format(number * (numericFormatType === "P" ? 100 : 1), "N" + precision);
                    if (!showTrailingZeros)
                        number = self._excludeTrailingZeros(number, floatingSymbol);
                    break;
                default:
                    throw"Illegal numeric format: '" + numericFormatType + "'";
            }
            for (; ; ) {
                var lastIndex = regexParts.lastIndex,
                    matches = regexParts.exec(pattern);
                result += pattern.slice(lastIndex, matches ? matches.index : pattern.length);
                if (matches)
                    switch (matches[0]) {
                        case"-":
                            if (/[1-9]/.test(number))
                                result += numberFormat["-"];
                            break;
                        case"$":
                            result += currencyFormat.symbol;
                            break;
                        case"%":
                            result += percentFormat.symbol;
                            break;
                        case"n":
                            result += number + unit;
                            break
                    }
                else
                    break
            }
            return (formatInfo.plus && value > 0 ? "+" : '') + result
        },
        _excludeTrailingZeros: function(strValue, floatingSymbol) {
            var floatingIndex = strValue.indexOf(floatingSymbol),
                stopIndex,
                i;
            if (floatingIndex < 0)
                return strValue;
            stopIndex = strValue.length;
            for (i = stopIndex - 1; i >= floatingIndex && (strValue[i] === '0' || i === floatingIndex); i--)
                stopIndex--;
            return strValue.substring(0, stopIndex)
        },
        _getUnitFormatSettings: function(value, formatInfo) {
            var unit = formatInfo.unit || '',
                precision = formatInfo.precision || 0,
                showTrailingZeros = true,
                significantDigits = formatInfo.significantDigits || 1,
                absValue;
            if (unit.toLowerCase() === 'auto') {
                showTrailingZeros = false;
                absValue = Math.abs(value);
                if (significantDigits < 1)
                    significantDigits = 1;
                if (absValue >= 1000000000) {
                    unit = 'B';
                    absValue /= 1000000000
                }
                else if (absValue >= 1000000) {
                    unit = 'M';
                    absValue /= 1000000
                }
                else if (absValue >= 1000) {
                    unit = 'K';
                    absValue /= 1000
                }
                else
                    unit = '';
                if (absValue == 0)
                    precision = 0;
                else if (absValue < 1) {
                    precision = significantDigits;
                    var smallValue = Math.pow(10, -significantDigits);
                    while (absValue < smallValue) {
                        smallValue /= 10;
                        precision++
                    }
                }
                else if (absValue >= 100)
                    precision = significantDigits - 3;
                else if (absValue >= 10)
                    precision = significantDigits - 2;
                else
                    precision = significantDigits - 1
            }
            if (precision < 0)
                precision = 0;
            return {
                    unit: unit,
                    precision: precision,
                    showTrailingZeros: showTrailingZeros
                }
        },
        _applyUnitToValue: function(value, unit) {
            if (unit == 'B')
                return value.toFixed(1) / 1000000000;
            if (unit == 'M')
                return value / 1000000;
            if (unit == 'K')
                return value / 1000;
            return value
        },
        _formatDateEx: function(value, formatInfo) {
            var self = this,
                quarterPrefix = 'Q',
                format = formatInfo.format,
                dateType = formatInfo.dateType,
                calendar = Globalize.culture().calendars.standard,
                time = undefined,
                index,
                dateStr;
            format = format.toLowerCase();
            if (dateType !== 'num' || format === 'dayofweek')
                switch (format) {
                    case'monthyear':
                        return self._formatDate(value, 'monthandyear');
                    case'quarteryear':
                        return self.getQuarterString(value, 'QQ') + ' ' + value.getFullYear();
                    case'daymonthyear':
                        return self._formatDate(value, dateType + 'Date');
                    case'datehour':
                        time = new Date(value.getTime());
                        time.setMinutes(0);
                        dateStr = self._formatDate(value, dateType + 'Date');
                        return dateStr + ' ' + self._formatDate(time, 'shorttime');
                    case'datehourminute':
                        dateStr = self._formatDate(value, dateType + 'Date');
                        return dateStr + ' ' + self._formatDate(value, 'shorttime');
                    case'datehourminutesecond':
                        dateStr = self._formatDate(value, dateType + 'Date');
                        return dateStr + ' ' + self._formatDate(value, 'longtime');
                    case'year':
                        dateStr = value.toString();
                        return dateType === 'abbr' ? dateStr.slice(2, 4) : dateStr;
                    case'quarter':
                        return quarterPrefix + value.toString();
                    case'month':
                        index = value - 1;
                        return dateType === 'abbr' ? calendar.months.namesAbbr[index] : calendar.months.names[index];
                    case'hour':
                        if (dateType === 'long') {
                            time = new Date;
                            time.setHours(value);
                            time.setMinutes(0);
                            return self._formatDate(time, 'shorttime')
                        }
                        else
                            return value.toString();
                    case'dayofweek':
                        index = $.inArray(value, ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']);
                        if (dateType !== 'num')
                            return dateType === 'abbr' ? calendar.days.namesAbbr[index] : calendar.days.names[index];
                        else
                            return ((index - calendar.firstDay + 1 + 7) % 8).toString();
                    default:
                        return value.toString()
                }
            else
                return value.toString()
        },
        getTimeFormat: function(showSecond) {
            if (showSecond)
                return this._getDateTimeFormatPattern('longtime');
            return this._getDateTimeFormatPattern('shorttime')
        },
        getDateFormatByDifferences: function(dateDifferences) {
            var resultFormat = '';
            if (dateDifferences.millisecond)
                resultFormat = DX.DateTimeFormat.millisecond;
            if (dateDifferences.hour || dateDifferences.minute || dateDifferences.second)
                resultFormat = this._addFormatSeparator(this.getTimeFormat(dateDifferences.second), resultFormat);
            if (dateDifferences.year && dateDifferences.month && dateDifferences.day)
                return this._addFormatSeparator(this._getDateTimeFormatPattern('shortdate'), resultFormat);
            if (dateDifferences.year && dateDifferences.month)
                return DX.DateTimeFormat['monthandyear'];
            if (dateDifferences.year)
                return DX.DateTimeFormat['year'];
            if (dateDifferences.month && dateDifferences.day)
                return this._addFormatSeparator(this._getDateTimeFormatPattern('monthandday'), resultFormat);
            if (dateDifferences.month)
                return DX.DateTimeFormat['month'];
            if (dateDifferences.day)
                return this._addFormatSeparator('dddd, dd', resultFormat);
            return resultFormat
        },
        getDateFormatByTicks: function(ticks) {
            var resultFormat,
                maxDif,
                currentDif,
                i,
                dateUnitInterval;
            if (ticks.length > 1) {
                maxDif = utils.getDatesDifferences(ticks[0], ticks[1]);
                for (i = 1; i < ticks.length - 1; i++) {
                    currentDif = utils.getDatesDifferences(ticks[i], ticks[i + 1]);
                    if (maxDif.count < currentDif.count)
                        maxDif = currentDif
                }
            }
            else
                maxDif = {
                    year: true,
                    month: true,
                    day: true,
                    hour: ticks[0].getHours() > 0,
                    minute: ticks[0].getMinutes() > 0,
                    second: ticks[0].getSeconds() > 0
                };
            resultFormat = this.getDateFormatByDifferences(maxDif);
            return resultFormat
        },
        getDateFormatByTickInterval: function(startValue, endValue, tickInterval) {
            var resultFormat,
                dateDifferences,
                dateUnitInterval,
                dateDifferencesConverter = {
                    quarter: 'month',
                    week: 'day'
                },
                correctDateDifferences = function(dateDifferences, tickInterval, value) {
                    switch (tickInterval) {
                        case'year':
                            dateDifferences.month = value;
                        case'quarter':
                        case'month':
                            dateDifferences.day = value;
                        case'week':
                        case'day':
                            dateDifferences.hour = value;
                        case'hour':
                            dateDifferences.minute = value;
                        case'minute':
                            dateDifferences.second = value;
                        case'second':
                            dateDifferences.millisecond = value
                    }
                },
                correctDifferencesByMaxDate = function(differences, minDate, maxDate) {
                    if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
                        if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
                            differences.millisecond = true;
                            differences.second = false
                        }
                    }
                    else if (!maxDate.getSeconds() && maxDate.getMinutes()) {
                        if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
                            differences.second = true;
                            differences.minute = false
                        }
                    }
                    else if (!maxDate.getMinutes() && maxDate.getHours()) {
                        if (maxDate.getHours() - minDate.getHours() === 1) {
                            differences.minute = true;
                            differences.hour = false
                        }
                    }
                    else if (!maxDate.getHours() && maxDate.getDate() > 1) {
                        if (maxDate.getDate() - minDate.getDate() === 1) {
                            differences.hour = true;
                            differences.day = false
                        }
                    }
                    else if (maxDate.getDate() === 1 && maxDate.getMonth()) {
                        if (maxDate.getMonth() - minDate.getMonth() === 1) {
                            differences.day = true;
                            differences.month = false
                        }
                    }
                    else if (!maxDate.getMonth() && maxDate.getFullYear())
                        if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
                            differences.month = true;
                            differences.year = false
                        }
                };
            tickInterval = utils.isString(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
            dateDifferences = utils.getDatesDifferences(startValue, endValue);
            if (startValue !== endValue)
                correctDifferencesByMaxDate(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue);
            dateUnitInterval = utils.getDateUnitInterval(dateDifferences);
            correctDateDifferences(dateDifferences, dateUnitInterval, true);
            dateUnitInterval = utils.getDateUnitInterval(tickInterval || 'second');
            correctDateDifferences(dateDifferences, dateUnitInterval, false);
            dateDifferences[dateDifferencesConverter[dateUnitInterval] || dateUnitInterval] = true;
            resultFormat = this.getDateFormatByDifferences(dateDifferences);
            return resultFormat
        }
    }
})(jQuery, DevExpress);

// Module core, file data.js

(function($, DX, undefined) {
    var HAS_KO = !!window.ko;
    var bracketsToDots = function(expr) {
            return expr.replace(/\[/g, ".").replace(/\]/g, "")
        };
    var unwrapObservable = function(value) {
            if (HAS_KO)
                return ko.utils.unwrapObservable(value);
            return value
        };
    var isObservable = function(value) {
            return HAS_KO && ko.isObservable(value)
        };
    var assign = function(obj, propName, value) {
            var propValue = obj[propName];
            if (isObservable(propValue))
                propValue(value);
            else
                obj[propName] = value
        };
    var compileGetter = function(expr) {
            if (arguments.length > 1)
                expr = $.makeArray(arguments);
            if (!expr || expr === "this")
                return function(obj) {
                        return obj
                    };
            if ($.isFunction(expr))
                return expr;
            if ($.isArray(expr))
                return combineGetters(expr);
            expr = bracketsToDots(expr);
            var path = expr.split(".");
            return function(obj, options) {
                    options = options || {};
                    var current = unwrapObservable(obj);
                    $.each(path, function() {
                        if (!current)
                            return false;
                        var next = unwrapObservable(current[this]);
                        if ($.isFunction(next) && !options.functionsAsIs)
                            next = next.call(current);
                        current = next
                    });
                    return current
                }
        };
    var combineGetters = function(getters) {
            var compiledGetters = {};
            $.each(getters, function() {
                compiledGetters[this] = compileGetter(this)
            });
            return function(obj) {
                    var result = {};
                    $.each(compiledGetters, function(name) {
                        var value = this(obj),
                            current,
                            path,
                            last,
                            i;
                        if (value === undefined)
                            return;
                        current = result;
                        path = name.split(".");
                        last = path.length - 1;
                        for (i = 0; i < last; i++)
                            current = current[path[i]] = {};
                        current[path[i]] = value
                    });
                    return result
                }
        };
    var compileSetter = function(expr) {
            if (!expr || expr === "this")
                throw Error("Cannot assign to self");
            expr = bracketsToDots(expr);
            var pos = expr.lastIndexOf("."),
                targetGetter = compileGetter(expr.substr(0, pos)),
                targetExpr = expr.substr(1 + pos);
            return function(obj, value, options) {
                    options = options || {};
                    var target = targetGetter(obj, {functionsAsIs: options.functionsAsIs}),
                        prevTargetValue = target[targetExpr];
                    if (!options.functionsAsIs && $.isFunction(prevTargetValue) && !isObservable(prevTargetValue))
                        target[targetExpr](value);
                    else {
                        prevTargetValue = unwrapObservable(prevTargetValue);
                        if (options.merge && $.isPlainObject(value) && (prevTargetValue === undefined || $.isPlainObject(prevTargetValue))) {
                            if (!prevTargetValue)
                                assign(target, targetExpr, {});
                            $.extend(true, unwrapObservable(target[targetExpr]), value)
                        }
                        else
                            assign(target, targetExpr, value)
                    }
                }
        };
    var normalizeBinaryCriterion = function(crit) {
            return [crit[0], crit.length < 3 ? "=" : crit[1].toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]]
        };
    var normalizeSortingInfo = function(info) {
            if (!$.isArray(info))
                info = [info];
            return $.map(info, function(i) {
                    return {
                            selector: $.isFunction(i) || typeof i === "string" ? i : i.field || i.selector,
                            desc: !!(i.desc || String(i.dir).charAt(0).toLowerCase() === "d")
                        }
                })
        };
    var Guid = DX.Class.inherit({
            ctor: function(value) {
                if (value)
                    value = String(value);
                this._value = this._normalize(value || this._generate())
            },
            _normalize: function(value) {
                value = value.replace(/[^a-f0-9]/ig, "").toLowerCase();
                while (value.length < 32)
                    value += "0";
                return [value.substr(0, 8), value.substr(8, 4), value.substr(12, 4), value.substr(16, 4), value.substr(20)].join("-")
            },
            _generate: function() {
                var value = "";
                for (var i = 0; i < 32; i++)
                    value += Math.round(Math.random() * 16).toString(16);
                return value
            },
            toString: function() {
                return this._value
            },
            valueOf: function() {
                return this._value
            },
            toJSON: function() {
                return this._value
            }
        });
    var toComparable = function(value, caseSensitive) {
            if (value instanceof Date)
                return value.getTime();
            if (value instanceof Guid)
                return value.valueOf();
            if (!caseSensitive && typeof value === "string")
                return value.toLowerCase();
            return value
        };
    var keysEqual = function(keyExpr, key1, key2) {
            if ($.isArray(keyExpr)) {
                var names = $.map(key1, function(v, k) {
                        return k
                    }),
                    name;
                for (var i = 0; i < names.length; i++) {
                    name = names[i];
                    if (toComparable(key1[name], true) != toComparable(key2[name], true))
                        return false
                }
                return true
            }
            return toComparable(key1, true) == toComparable(key2, true)
        };
    var BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var base64_encode = function(input) {
            if (!$.isArray(input))
                input = stringToByteArray(String(input));
            var result = "";
            for (var i = 0; i < input.length; i += 3) {
                var octet1 = input[i],
                    octet2 = input[i + 1],
                    octet3 = input[i + 2];
                result += $.map([octet1 >> 2, (octet1 & 3) << 4 | octet2 >> 4, isNaN(octet2) ? 64 : (octet2 & 15) << 2 | octet3 >> 6, isNaN(octet3) ? 64 : octet3 & 63], function(item) {
                    return BASE64_CHARS.charAt(item)
                }).join("")
            }
            return result
        };
    var stringToByteArray = function(str) {
            var bytes = [],
                code,
                i;
            for (i = 0; i < str.length; i++) {
                code = str.charCodeAt(i);
                if (code < 128)
                    bytes.push(code);
                else if (code < 2048)
                    bytes.push(192 + (code >> 6), 128 + (code & 63));
                else if (code < 65536)
                    bytes.push(224 + (code >> 12), 128 + (code >> 6 & 63), 128 + (code & 63));
                else if (code < 2097152)
                    bytes.push(240 + (code >> 18), 128 + (code >> 12 & 63), 128 + (code >> 6 & 63), 128 + (code & 63))
            }
            return bytes
        };
    var errorMessageFromXhr = function() {
            var textStatusMessages = {
                    timeout: "Network connection timeout",
                    error: "Unspecified network error",
                    parsererror: "Unexpected server response"
                };
            var textStatusDetails = {
                    timeout: "possible causes: the remote host is not accessible, overloaded or is not included into the domain white-list when being run in the native container",
                    error: "if the remote host is located on another domain, make sure it properly supports cross-origin resource sharing (CORS), or use the JSONP approach instead",
                    parsererror: "the remote host did not respond with valid JSON data"
                };
            var explainTextStatus = function(textStatus) {
                    var result = textStatusMessages[textStatus];
                    if (!result)
                        return textStatus;
                    result += " (" + textStatusDetails[textStatus] + ")";
                    return result
                };
            return function(xhr, textStatus) {
                    if (xhr.status < 400)
                        return explainTextStatus(textStatus);
                    return xhr.statusText
                }
        }();
    var data = DX.data = {
            utils: {
                compileGetter: compileGetter,
                compileSetter: compileSetter,
                normalizeBinaryCriterion: normalizeBinaryCriterion,
                normalizeSortingInfo: normalizeSortingInfo,
                toComparable: toComparable,
                keysEqual: keysEqual,
                errorMessageFromXhr: errorMessageFromXhr
            },
            Guid: Guid,
            base64_encode: base64_encode,
            queryImpl: {},
            queryAdapters: {},
            query: function() {
                var impl = $.isArray(arguments[0]) ? "array" : "remote";
                return data.queryImpl[impl].apply(this, arguments)
            },
            errorHandler: null,
            _handleError: function(error) {
                if (window.console)
                    console.warn("[DevExpress.data]: " + error);
                if (data.errorHandler)
                    data.errorHandler(error)
            }
        }
})(jQuery, DevExpress);

// Module core, file data.query.array.js

(function($, DX, undefined) {
    var Class = DX.Class,
        data = DX.data,
        queryImpl = data.queryImpl,
        compileGetter = data.utils.compileGetter,
        toComparable = data.utils.toComparable;
    var Iterator = Class.inherit({
            toArray: function() {
                var result = [];
                this.reset();
                while (this.next())
                    result.push(this.current());
                return result
            },
            countable: function() {
                return false
            }
        });
    var ArrayIterator = Iterator.inherit({
            ctor: function(array) {
                this.array = array;
                this.index = -1
            },
            next: function() {
                if (this.index + 1 < this.array.length) {
                    this.index++;
                    return true
                }
                return false
            },
            current: function() {
                return this.array[this.index]
            },
            reset: function() {
                this.index = -1
            },
            toArray: function() {
                return this.array.slice(0)
            },
            countable: function() {
                return true
            },
            count: function() {
                return this.array.length
            }
        });
    var WrappedIterator = Iterator.inherit({
            ctor: function(iter) {
                this.iter = iter
            },
            next: function() {
                return this.iter.next()
            },
            current: function() {
                return this.iter.current()
            },
            reset: function() {
                return this.iter.reset()
            }
        });
    var SortIterator = Iterator.inherit({
            ctor: function(iter, getter, desc) {
                this.iter = iter;
                this.rules = [{
                        getter: getter,
                        desc: desc
                    }]
            },
            thenBy: function(getter, desc) {
                var result = new SortIterator(this.sortedIter || this.iter, getter, desc);
                if (!this.sortedIter)
                    result.rules = this.rules.concat(result.rules);
                return result
            },
            next: function() {
                this._ensureSorted();
                return this.sortedIter.next()
            },
            current: function() {
                this._ensureSorted();
                return this.sortedIter.current()
            },
            reset: function() {
                delete this.sortedIter
            },
            countable: function() {
                return this.sortedIter || this.iter.countable()
            },
            count: function() {
                if (this.sortedIter)
                    return this.sortedIter.count();
                return this.iter.count()
            },
            _ensureSorted: function() {
                if (this.sortedIter)
                    return;
                $.each(this.rules, function() {
                    this.getter = compileGetter(this.getter)
                });
                this.sortedIter = new ArrayIterator(this.iter.toArray().sort($.proxy(this._compare, this)))
            },
            _compare: function(x, y) {
                if (x === y)
                    return 0;
                for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
                    var rule = this.rules[i],
                        xValue = toComparable(rule.getter(x)),
                        yValue = toComparable(rule.getter(y)),
                        factor = rule.desc ? -1 : 1;
                    if (xValue < yValue)
                        return -factor;
                    if (xValue > yValue)
                        return factor;
                    if (xValue !== yValue)
                        return !xValue ? -factor : factor
                }
                return 0
            }
        });
    var compileCriteria = function() {
            var compileGroup = function(crit) {
                    var operands = [],
                        bag = ["return function(d) { return "],
                        index = 0,
                        pushAnd = false;
                    $.each(crit, function() {
                        if ($.isArray(this) || $.isFunction(this)) {
                            if (pushAnd)
                                bag.push(" && ");
                            operands.push(compileCriteria(this));
                            bag.push("op[", index, "](d)");
                            index++;
                            pushAnd = true
                        }
                        else {
                            bag.push(/and|&/i.test(this) ? " && " : " || ");
                            pushAnd = false
                        }
                    });
                    bag.push(" }");
                    return new Function("op", bag.join(""))(operands)
                };
            var toString = function(value) {
                    return DX.utils.isDefined(value) ? value.toString() : ''
                };
            var compileBinary = function(crit) {
                    crit = data.utils.normalizeBinaryCriterion(crit);
                    var getter = compileGetter(crit[0]),
                        op = crit[1],
                        value = crit[2];
                    value = toComparable(value);
                    switch (op.toLowerCase()) {
                        case"=":
                            return function(obj) {
                                    return toComparable(getter(obj)) == value
                                };
                        case"<>":
                            return function(obj) {
                                    return toComparable(getter(obj)) != value
                                };
                        case">":
                            return function(obj) {
                                    return toComparable(getter(obj)) > value
                                };
                        case"<":
                            return function(obj) {
                                    return toComparable(getter(obj)) < value
                                };
                        case">=":
                            return function(obj) {
                                    return toComparable(getter(obj)) >= value
                                };
                        case"<=":
                            return function(obj) {
                                    return toComparable(getter(obj)) <= value
                                };
                        case"startswith":
                            return function(obj) {
                                    return toComparable(toString(getter(obj))).indexOf(value) === 0
                                };
                        case"endswith":
                            return function(obj) {
                                    var getterValue = toComparable(toString(getter(obj)));
                                    return getterValue.lastIndexOf(value) === getterValue.length - value.toString().length
                                };
                        case"contains":
                            return function(obj) {
                                    return toComparable(toString(getter(obj))).indexOf(value) > -1
                                };
                        case"notcontains":
                            return function(obj) {
                                    return toComparable(toString(getter(obj))).indexOf(value) === -1
                                }
                    }
                };
            return function(crit) {
                    if ($.isFunction(crit))
                        return crit;
                    if ($.isArray(crit[0]))
                        return compileGroup(crit);
                    return compileBinary(crit)
                }
        }();
    var FilterIterator = WrappedIterator.inherit({
            ctor: function(iter, criteria) {
                this.callBase(iter);
                this.criteria = compileCriteria(criteria)
            },
            next: function() {
                while (this.iter.next())
                    if (this.criteria(this.current()))
                        return true;
                return false
            }
        });
    var GroupIterator = Iterator.inherit({
            ctor: function(iter, getter) {
                this.iter = iter;
                this.getter = getter
            },
            next: function() {
                this._ensureGrouped();
                return this.groupedIter.next()
            },
            current: function() {
                this._ensureGrouped();
                return this.groupedIter.current()
            },
            reset: function() {
                delete this.groupedIter
            },
            countable: function() {
                return !!this.groupedIter
            },
            count: function() {
                return this.groupedIter.count()
            },
            _ensureGrouped: function() {
                if (this.groupedIter)
                    return;
                var hash = {},
                    keys = [],
                    iter = this.iter,
                    getter = compileGetter(this.getter);
                iter.reset();
                while (iter.next()) {
                    var current = iter.current(),
                        key = getter(current);
                    if (key in hash)
                        hash[key].push(current);
                    else {
                        hash[key] = [current];
                        keys.push(key)
                    }
                }
                this.groupedIter = new ArrayIterator($.map(keys, function(key) {
                    return {
                            key: key,
                            items: hash[key]
                        }
                }))
            }
        });
    var SelectIterator = WrappedIterator.inherit({
            ctor: function(iter, getter) {
                this.callBase(iter);
                this.getter = compileGetter(getter)
            },
            current: function() {
                return this.getter(this.callBase())
            },
            countable: function() {
                return this.iter.countable()
            },
            count: function() {
                return this.iter.count()
            }
        });
    var SliceIterator = WrappedIterator.inherit({
            ctor: function(iter, skip, take) {
                this.callBase(iter);
                this.skip = Math.max(0, skip);
                this.take = Math.max(0, take);
                this.pos = 0
            },
            next: function() {
                if (this.pos >= this.skip + this.take)
                    return false;
                while (this.pos < this.skip && this.iter.next())
                    this.pos++;
                this.pos++;
                return this.iter.next()
            },
            reset: function() {
                this.callBase();
                this.pos = 0
            },
            countable: function() {
                return this.iter.countable()
            },
            count: function() {
                return Math.min(this.iter.count() - this.skip, this.take)
            }
        });
    queryImpl.array = function(iter, queryOptions) {
        queryOptions = queryOptions || {};
        if (!(iter instanceof Iterator))
            iter = new ArrayIterator(iter);
        var handleError = function(error) {
                var handler = queryOptions.errorHandler;
                if (handler)
                    handler(error);
                data._handleError(error)
            };
        var aggregate = function(seed, step, finalize) {
                var d = $.Deferred().fail(handleError);
                try {
                    iter.reset();
                    if (arguments.length < 2) {
                        step = arguments[0];
                        seed = iter.next() ? iter.current() : undefined
                    }
                    var accumulator = seed;
                    while (iter.next())
                        accumulator = step(accumulator, iter.current());
                    d.resolve(finalize ? finalize(accumulator) : accumulator)
                }
                catch(x) {
                    d.reject(x)
                }
                return d.promise()
            };
        var select = function(getter) {
                if (!$.isFunction(getter) && !$.isArray(getter))
                    getter = $.makeArray(arguments);
                return chainQuery(new SelectIterator(iter, getter))
            };
        var selectProp = function(name) {
                return select(compileGetter(name))
            };
        var chainQuery = function(iter) {
                return queryImpl.array(iter, queryOptions)
            };
        return {
                toArray: function() {
                    return iter.toArray()
                },
                enumerate: function() {
                    var d = $.Deferred().fail(handleError);
                    try {
                        d.resolve(iter.toArray())
                    }
                    catch(x) {
                        d.reject(x)
                    }
                    return d.promise()
                },
                sortBy: function(getter, desc) {
                    return chainQuery(new SortIterator(iter, getter, desc))
                },
                thenBy: function(getter, desc) {
                    if (iter instanceof SortIterator)
                        return chainQuery(iter.thenBy(getter, desc));
                    throw Error();
                },
                filter: function(criteria) {
                    if (!$.isArray(criteria))
                        criteria = $.makeArray(arguments);
                    return chainQuery(new FilterIterator(iter, criteria))
                },
                slice: function(skip, take) {
                    if (take === undefined)
                        take = Number.MAX_VALUE;
                    return chainQuery(new SliceIterator(iter, skip, take))
                },
                select: select,
                groupBy: function(getter, desc) {
                    return chainQuery(new GroupIterator(iter, getter, desc))
                },
                aggregate: aggregate,
                count: function() {
                    if (iter.countable()) {
                        var d = $.Deferred().fail(handleError);
                        try {
                            d.resolve(iter.count())
                        }
                        catch(x) {
                            d.reject(x)
                        }
                        return d.promise()
                    }
                    return aggregate(0, function(count) {
                            return 1 + count
                        })
                },
                sum: function(getter) {
                    if (getter)
                        return selectProp(getter).sum();
                    return aggregate(0, function(sum, item) {
                            return sum + item
                        })
                },
                min: function(getter) {
                    if (getter)
                        return selectProp(getter).min();
                    return aggregate(function(min, item) {
                            return item < min ? item : min
                        })
                },
                max: function(getter) {
                    if (getter)
                        return selectProp(getter).max();
                    return aggregate(function(max, item) {
                            return item > max ? item : max
                        })
                },
                avg: function(getter) {
                    if (getter)
                        return selectProp(getter).avg();
                    var count = 0;
                    return aggregate(0, function(sum, item) {
                            count++;
                            return sum + item
                        }, function(sum) {
                            return count ? sum / count : undefined
                        })
                }
            }
    }
})(jQuery, DevExpress);

// Module core, file data.query.remote.js

(function($, DX, undefined) {
    var data = DX.data,
        queryImpl = data.queryImpl;
    queryImpl.remote = function(url, queryOptions, tasks) {
        tasks = tasks || [];
        queryOptions = queryOptions || {};
        var createTask = function(name, args) {
                return {
                        name: name,
                        args: args
                    }
            };
        var exec = function(executorTask) {
                var d = $.Deferred(),
                    adapterFactory,
                    adapter,
                    taskQueue,
                    currentTask;
                var rejectWithNotify = function(error) {
                        var handler = queryOptions.errorHandler;
                        if (handler)
                            handler(error);
                        data._handleError(error);
                        d.reject(error)
                    };
                try {
                    adapterFactory = queryOptions.adapter || "odata";
                    if (!$.isFunction(adapterFactory))
                        adapterFactory = data.queryAdapters[adapterFactory];
                    adapter = adapterFactory(queryOptions);
                    taskQueue = [].concat(tasks).concat(executorTask);
                    while (taskQueue.length) {
                        currentTask = taskQueue[0];
                        if (String(currentTask.name) !== "enumerate")
                            if (!adapter[currentTask.name] || adapter[currentTask.name].apply(adapter, currentTask.args) === false)
                                break;
                        taskQueue.shift()
                    }
                    adapter.exec(url).done(function(result) {
                        if (!taskQueue.length)
                            d.resolve(result);
                        else {
                            var clientChain = queryImpl.array(result, {errorHandler: queryOptions.errorHandler});
                            $.each(taskQueue, function() {
                                clientChain = clientChain[this.name].apply(clientChain, this.args)
                            });
                            clientChain.done($.proxy(d.resolve, d)).fail($.proxy(d.reject, d))
                        }
                    }).fail(rejectWithNotify)
                }
                catch(x) {
                    rejectWithNotify(x)
                }
                return d.promise()
            };
        var query = {};
        $.each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
            var name = this;
            query[name] = function() {
                return queryImpl.remote(url, queryOptions, tasks.concat(createTask(name, arguments)))
            }
        });
        $.each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
            var name = this;
            query[name] = function() {
                return exec.call(this, createTask(name, arguments))
            }
        });
        return query
    }
})(jQuery, DevExpress);

// Module core, file data.odata.js

(function($, DX, undefined) {
    var data = DX.data,
        Guid = data.Guid;
    var JSON_MIME_TYPE = "application/json;odata=verbose";
    var TEXT_MIME_TYPE = "text/plain";
    var ajaxOptionsForRequest = function(request, requestOptions) {
            request = $.extend({
                method: "get",
                url: "",
                params: {},
                payload: null,
                headers: {Accept: [JSON_MIME_TYPE, TEXT_MIME_TYPE].join()}
            }, request);
            requestOptions = requestOptions || {};
            var beforeSend = requestOptions.beforeSend;
            if (beforeSend)
                beforeSend(request);
            var method = (request.method || "get").toLowerCase(),
                isGet = method === "get",
                useJsonp = isGet && requestOptions.jsonp,
                params = $.extend({}, request.params),
                ajaxData = isGet ? params : JSON.stringify(request.payload),
                qs = !isGet && $.param(params),
                url = request.url,
                contentType = !isGet && JSON_MIME_TYPE;
            if (qs)
                url += (url.indexOf("?") > -1 ? "&" : "?") + qs;
            if (useJsonp)
                ajaxData["$format"] = "json";
            return {
                    url: url,
                    data: ajaxData,
                    dataType: useJsonp ? "jsonp" : "json",
                    jsonp: useJsonp && "$callback",
                    type: method,
                    timeout: 30000,
                    headers: request.headers,
                    contentType: contentType,
                    xhrFields: {withCredentials: true}
                }
        };
    var sendRequest = function(request, requestOptions) {
            var d = $.Deferred();
            $.ajax(ajaxOptionsForRequest(request, requestOptions)).always(function(obj, textStatus) {
                var tuplet = interpretVerboseJsonFormat(obj, textStatus),
                    error = tuplet.error,
                    data = tuplet.data,
                    nextUrl = tuplet.nextUrl;
                if (error)
                    d.reject(error);
                else if (requestOptions.countOnly)
                    d.resolve(tuplet.count);
                else if (nextUrl)
                    sendRequest({url: nextUrl}, requestOptions).fail($.proxy(d.reject, d)).done(function(nextData) {
                        d.resolve(data.concat(nextData))
                    });
                else
                    d.resolve(data)
            });
            return d.promise()
        };
    var formatDotNetError = function(errorObj) {
            var message,
                currentError = errorObj;
            if ("message" in errorObj)
                if (errorObj.message.value)
                    message = errorObj.message.value;
                else
                    message = errorObj.message;
            while (currentError = currentError.innererror || currentError.internalexception) {
                message = currentError.message;
                if (currentError.internalexception && message.indexOf("inner exception") === -1)
                    break
            }
            return message
        };
    var errorFromResponse = function(obj, textStatus) {
            if (textStatus === "nocontent")
                return null;
            var httpStatus = 200,
                message = "Unknown error",
                innerError,
                response = obj;
            if (textStatus !== "success") {
                httpStatus = obj.status;
                message = data.utils.errorMessageFromXhr(obj, textStatus);
                try {
                    response = $.parseJSON(obj.responseText)
                }
                catch(x) {}
            }
            var errorObj = response && response.error;
            if (errorObj) {
                message = formatDotNetError(errorObj) || message;
                if (httpStatus === 200)
                    httpStatus = 500;
                if (response.error.code)
                    httpStatus = Number(response.error.code);
                return $.extend(Error(message), {
                        httpStatus: httpStatus,
                        errorDetails: errorObj
                    })
            }
            else if (httpStatus !== 200)
                return $.extend(Error(message), {httpStatus: httpStatus})
        };
    var interpretVerboseJsonFormat = function(obj, textStatus) {
            var error = errorFromResponse(obj, textStatus);
            if (error)
                return {error: error};
            if (!$.isPlainObject(obj))
                return {data: obj};
            var data = obj.d;
            if (!data)
                return {error: Error("Malformed or unsupported JSON response received")};
            data = data.results || data;
            recognizeDates(data);
            return {
                    data: data,
                    nextUrl: obj.d.__next,
                    count: obj.d.__count
                }
        };
    var EdmLiteral = DX.Class.inherit({
            ctor: function(value) {
                this._value = value
            },
            valueOf: function() {
                return this._value
            }
        });
    var serializeDate = function() {
            var pad = function(part) {
                    part = String(part);
                    if (part.length < 2)
                        part = "0" + part;
                    return part
                };
            return function(date) {
                    var result = ["datetime'", date.getUTCFullYear(), "-", pad(date.getUTCMonth() + 1), "-", pad(date.getUTCDate())];
                    if (date.getUTCHours() || date.getUTCMinutes() || date.getUTCSeconds() || date.getUTCMilliseconds()) {
                        result.push("T", pad(date.getUTCHours()), ":", pad(date.getUTCMinutes()), ":", pad(date.getUTCSeconds()));
                        if (date.getUTCMilliseconds())
                            result.push(".", date.getUTCMilliseconds())
                    }
                    result.push("'");
                    return result.join("")
                }
        }();
    var serializePropName = function(propName) {
            return propName.replace(/\./g, "/")
        };
    var serializeValue = function(value) {
            if (value instanceof Date)
                return serializeDate(value);
            if (value instanceof Guid)
                return "guid'" + value + "'";
            if (value instanceof EdmLiteral)
                return value.valueOf();
            if (typeof value === "string")
                return "'" + value.replace(/'/g, "''") + "'";
            return String(value)
        };
    var serializeKey = function(key) {
            if ($.isPlainObject(key)) {
                var parts = [];
                $.each(key, function(k, v) {
                    parts.push(serializePropName(k) + "=" + serializeValue(v))
                });
                return parts.join()
            }
            return serializeValue(key)
        };
    var recognizeDates = function(list) {
            $.each(list, function(i, val) {
                if (val !== null && typeof val === "object")
                    recognizeDates(val);
                else if (typeof val === "string") {
                    var matches = val.match(/^\/Date\((-?\d+)((\+|-)?(\d+)?)\)\/$/);
                    if (matches)
                        list[i] = new Date(Number(matches[1]) + matches[2] * 60000)
                }
            })
        };
    var keyConverters = {
            String: function(value) {
                return value + ""
            },
            Int32: function(value) {
                return ~~value
            },
            Int64: function(value) {
                if (value instanceof EdmLiteral)
                    return value;
                return new EdmLiteral(value + "L")
            },
            Guid: function(value) {
                if (value instanceof Guid)
                    return value;
                return new Guid(value)
            }
        };
    var compileCriteria = function() {
            var createBinaryOperationFormatter = function(op) {
                    return function(prop, val, bag) {
                            bag.push(prop, " ", op, " ", val)
                        }
                };
            var createStringFuncFormatter = function(op, reverse) {
                    return function(prop, val, bag) {
                            if (reverse)
                                bag.push(op, "(", val, ",", prop, ")");
                            else
                                bag.push(op, "(", prop, ",", val, ")")
                        }
                };
            var formatters = {
                    "=": createBinaryOperationFormatter("eq"),
                    "<>": createBinaryOperationFormatter("ne"),
                    ">": createBinaryOperationFormatter("gt"),
                    ">=": createBinaryOperationFormatter("ge"),
                    "<": createBinaryOperationFormatter("lt"),
                    "<=": createBinaryOperationFormatter("le"),
                    startswith: createStringFuncFormatter("startswith"),
                    endswith: createStringFuncFormatter("endswith"),
                    contains: createStringFuncFormatter("substringof", true),
                    notcontains: createStringFuncFormatter("not substringof", true)
                };
            var compileBinary = function(criteria, bag) {
                    criteria = data.utils.normalizeBinaryCriterion(criteria);
                    formatters[criteria[1]](serializePropName(criteria[0]), serializeValue(criteria[2]), bag)
                };
            var compileGroup = function(criteria, bag) {
                    var pushAnd = false;
                    $.each(criteria, function() {
                        if ($.isArray(this)) {
                            if (pushAnd)
                                bag.push(" and ");
                            bag.push("(");
                            compileCore(this, bag);
                            bag.push(")");
                            pushAnd = true
                        }
                        else {
                            bag.push(/and|&/i.test(this) ? " and " : " or ");
                            pushAnd = false
                        }
                    })
                };
            var compileCore = function(criteria, bag) {
                    if ($.isArray(criteria[0]))
                        compileGroup(criteria, bag);
                    else
                        compileBinary(criteria, bag)
                };
            return function(criteria) {
                    var bag = [];
                    compileCore(criteria, bag);
                    return bag.join("")
                }
        }();
    var createODataQueryAdapter = function(queryOptions) {
            var sorting = [],
                criteria = [],
                select,
                skip,
                take,
                countQuery;
            var hasSlice = function() {
                    return skip || take !== undefined
                };
            var sortCore = function(getter, desc, reset) {
                    if (hasSlice() || typeof getter !== "string")
                        return false;
                    if (reset)
                        sorting = [];
                    var rule = serializePropName(getter);
                    if (desc)
                        rule += " desc";
                    sorting.push(rule)
                };
            var generateExpand = function() {
                    var hash = {};
                    if (queryOptions.expand)
                        $.each($.makeArray(queryOptions.expand), function() {
                            hash[serializePropName(this)] = 1
                        });
                    if (select)
                        $.each(select, function() {
                            var path = this.split(".");
                            if (path.length < 2)
                                return;
                            path.pop();
                            hash[serializePropName(path.join("."))] = 1
                        });
                    return $.map(hash, function(k, v) {
                            return v
                        }).join() || undefined
                };
            var requestData = function() {
                    var result = {};
                    if (!countQuery) {
                        if (sorting.length)
                            result["$orderby"] = sorting.join(",");
                        if (skip)
                            result["$skip"] = skip;
                        if (take !== undefined)
                            result["$top"] = take;
                        if (select)
                            result["$select"] = serializePropName(select.join());
                        result["$expand"] = generateExpand()
                    }
                    if (criteria.length)
                        result["$filter"] = compileCriteria(criteria.length < 2 ? criteria[0] : criteria);
                    if (countQuery) {
                        result["$inlinecount"] = "allpages";
                        result["$top"] = 0
                    }
                    return result
                };
            return {
                    exec: function(url) {
                        return sendRequest({
                                url: url,
                                params: $.extend(requestData(), queryOptions && queryOptions.params)
                            }, {
                                beforeSend: queryOptions.beforeSend,
                                jsonp: queryOptions.jsonp,
                                countOnly: countQuery
                            })
                    },
                    sortBy: function(getter, desc) {
                        return sortCore(getter, desc, true)
                    },
                    thenBy: function(getter, desc) {
                        return sortCore(getter, desc, false)
                    },
                    slice: function(skipCount, takeCount) {
                        if (hasSlice())
                            return false;
                        skip = skipCount;
                        take = takeCount
                    },
                    filter: function(criterion) {
                        if (hasSlice() || $.isFunction(criterion))
                            return false;
                        if (!$.isArray(criterion))
                            criterion = $.makeArray(arguments);
                        if (criteria.length)
                            criteria.push("and");
                        criteria.push(criterion)
                    },
                    select: function(expr) {
                        if (select || $.isFunction(expr))
                            return false;
                        if (!$.isArray(expr))
                            expr = $.makeArray(arguments);
                        select = expr
                    },
                    count: function() {
                        countQuery = true
                    }
                }
        };
    $.extend(true, data, {
        EdmLiteral: EdmLiteral,
        utils: {odata: {
                sendRequest: sendRequest,
                serializePropName: serializePropName,
                serializeValue: serializeValue,
                serializeKey: serializeKey,
                keyConverters: keyConverters
            }},
        queryAdapters: {odata: createODataQueryAdapter}
    })
})(jQuery, DevExpress);

// Module core, file data.store.abstract.js

(function($, DX, undefined) {
    var Class = DX.Class,
        abstract = DX.abstract,
        data = DX.data,
        normalizeSortingInfo = data.utils.normalizeSortingInfo;
    var STORE_CALLBACK_NAMES = ["loading", "loaded", "modifying", "modified", "inserting", "inserted", "updating", "updated", "removing", "removed"];
    var multiLevelGroup = function(query, groupInfo) {
            query = query.groupBy(groupInfo[0].selector);
            if (groupInfo.length > 1)
                query = query.select(function(g) {
                    return $.extend({}, g, {items: multiLevelGroup(data.query(g.items), groupInfo.slice(1)).toArray()})
                });
            return query
        };
    data.Store = Class.inherit({
        ctor: function(options) {
            var self = this;
            options = options || {};
            $.each(STORE_CALLBACK_NAMES, function() {
                var callbacks = self[this] = $.Callbacks();
                if (this in options)
                    callbacks.add(options[this])
            });
            this._key = options.key;
            this._keyGetter = data.utils.compileGetter(this._key);
            this._errorHandler = options.errorHandler
        },
        customLoadOptions: function() {
            return null
        },
        key: function() {
            return this._key
        },
        keyOf: function(obj) {
            return this._keyGetter(obj)
        },
        _requireKey: function() {
            if (!this._key)
                throw Error("Key expression is required for this operation");
        },
        load: function(options) {
            var self = this;
            options = options || {};
            this.loading.fire(options);
            return this._loadImpl(options).done(function(result) {
                    self.loaded.fire(result)
                })
        },
        _loadImpl: function(options) {
            var filter = options.filter,
                sort = options.sort,
                select = options.select,
                group = options.group,
                skip = options.skip,
                take = options.take,
                q = this.createQuery(options);
            if (filter)
                q = q.filter(filter);
            if (group)
                group = normalizeSortingInfo(group);
            if (sort) {
                sort = normalizeSortingInfo(sort);
                if (group)
                    sort = group.concat(sort);
                $.each(sort, function(index) {
                    q = q[index ? "thenBy" : "sortBy"](this.selector, this.desc)
                })
            }
            if (group)
                q = multiLevelGroup(q, group);
            if (take || skip)
                q = q.slice(skip || 0, take);
            if (select)
                q = q.select(select);
            return q.enumerate()
        },
        createQuery: abstract,
        byKey: function(key, extraOptions) {
            return this._addFailHandlers(this._byKeyImpl(key, extraOptions))
        },
        _byKeyImpl: abstract,
        insert: function(values) {
            var self = this;
            self.modifying.fire();
            self.inserting.fire(values);
            return self._addFailHandlers(self._insertImpl(values).done(function(callbackValues, callbackKey) {
                    self.inserted.fire(callbackValues, callbackKey);
                    self.modified.fire()
                }))
        },
        _insertImpl: abstract,
        update: function(key, values) {
            var self = this;
            self.modifying.fire();
            self.updating.fire(key, values);
            return self._addFailHandlers(self._updateImpl(key, values).done(function(callbackKey, callbackValues) {
                    self.updated.fire(callbackKey, callbackValues);
                    self.modified.fire()
                }))
        },
        _updateImpl: abstract,
        remove: function(key) {
            var self = this;
            self.modifying.fire();
            self.removing.fire(key);
            return self._addFailHandlers(self._removeImpl(key).done(function(callbackKey) {
                    self.removed.fire(callbackKey);
                    self.modified.fire()
                }))
        },
        _removeImpl: abstract,
        _addFailHandlers: function(deferred) {
            return deferred.fail(this._errorHandler, data._handleError)
        }
    })
})(jQuery, DevExpress);

// Module core, file data.store.array.js

(function($, DX, undefined) {
    var data = DX.data,
        Guid = data.Guid;
    var trivialPromise = function(_) {
            var d = $.Deferred();
            return d.resolve.apply(d, arguments).promise()
        };
    var rejectedPromise = function(_) {
            var d = $.Deferred();
            return d.reject.apply(d, arguments).promise()
        };
    data.ArrayStore = data.Store.inherit({
        ctor: function(options) {
            if ($.isArray(options))
                options = {data: options};
            else
                options = options || {};
            this.callBase(options);
            this._array = options.data || []
        },
        createQuery: function() {
            return data.query(this._array, {errorHandler: this._errorHandler})
        },
        _byKeyImpl: function(key) {
            return trivialPromise(this._array[this._indexByKey(key)])
        },
        _insertImpl: function(values) {
            var keyExpr = this.key(),
                keyValue,
                obj = {};
            $.extend(obj, values);
            if (keyExpr) {
                keyValue = this.keyOf(obj);
                if (keyValue === undefined || typeof keyValue === "object" && $.isEmptyObject(keyValue)) {
                    if ($.isArray(keyExpr))
                        throw Error("Compound keys cannot be auto-generated");
                    keyValue = obj[keyExpr] = String(new Guid)
                }
                else if (this._array[this._indexByKey(keyValue)] !== undefined)
                    return rejectedPromise(Error("Attempt to insert an item with the duplicate key"))
            }
            else
                keyValue = obj;
            this._array.push(obj);
            return trivialPromise(values, keyValue)
        },
        _updateImpl: function(key, values) {
            var target;
            if (this.key()) {
                var index = this._indexByKey(key);
                if (index < 0)
                    return rejectedPromise(Error("Data item not found"));
                target = this._array[index]
            }
            else
                target = key;
            $.extend(true, target, values);
            return trivialPromise(key, values)
        },
        _removeImpl: function(key) {
            var index = this._indexByKey(key);
            if (index > -1)
                this._array.splice(index, 1);
            return trivialPromise(key)
        },
        _indexByKey: function(key) {
            for (var i = 0, arrayLength = this._array.length; i < arrayLength; i++)
                if (data.utils.keysEqual(this.key(), this._keyGetter(this._array[i]), key))
                    return i;
            return -1
        }
    })
})(jQuery, DevExpress);

// Module core, file data.store.local.js

(function($, DX, undefined) {
    var Class = DX.Class,
        abstract = DX.abstract,
        data = DX.data;
    var LocalStoreBackend = Class.inherit({
            ctor: function(store, storeOptions) {
                this._store = store;
                this._dirty = false;
                var immediate = this._immediate = storeOptions.immediate;
                var flushInterval = Math.max(100, storeOptions.flushInterval || 10 * 1000);
                if (!immediate) {
                    var saveProxy = $.proxy(this.save, this);
                    setInterval(saveProxy, flushInterval);
                    $(window).on("beforeunload", saveProxy);
                    if (window.cordova)
                        document.addEventListener("pause", saveProxy, false)
                }
            },
            notifyChanged: function() {
                this._dirty = true;
                if (this._immediate)
                    this.save()
            },
            load: function() {
                this._store._array = this._loadImpl();
                this._dirty = false
            },
            save: function() {
                if (!this._dirty)
                    return;
                this._saveImpl(this._store._array);
                this._dirty = false
            },
            _loadImpl: abstract,
            _saveImpl: abstract
        });
    var DomLocalStoreBackend = LocalStoreBackend.inherit({
            ctor: function(store, storeOptions) {
                this.callBase(store, storeOptions);
                var name = storeOptions.name;
                if (!name)
                    throw Error("Name is required");
                this._key = "dx-data-localStore-" + name
            },
            _loadImpl: function() {
                var raw = localStorage.getItem(this._key);
                if (raw)
                    return JSON.parse(raw);
                return []
            },
            _saveImpl: function(array) {
                if (!array.length)
                    localStorage.removeItem(this._key);
                else
                    localStorage.setItem(this._key, JSON.stringify(array))
            }
        });
    var localStoreBackends = {dom: DomLocalStoreBackend};
    data.LocalStore = data.ArrayStore.inherit({
        ctor: function(options) {
            if (typeof options === "string")
                options = {name: options};
            else
                options = options || {};
            this.callBase(options);
            this._backend = new localStoreBackends[options.backend || "dom"](this, options);
            this._backend.load()
        },
        clear: function() {
            this._array = [];
            this._backend.notifyChanged()
        },
        _insertImpl: function(values) {
            var b = this._backend;
            return this.callBase(values).done($.proxy(b.notifyChanged, b))
        },
        _updateImpl: function(key, values) {
            var b = this._backend;
            return this.callBase(key, values).done($.proxy(b.notifyChanged, b))
        },
        _removeImpl: function(key) {
            var b = this._backend;
            return this.callBase(key).done($.proxy(b.notifyChanged, b))
        }
    })
})(jQuery, DevExpress);

// Module core, file data.store.odata.js

(function($, DX, undefined) {
    var Class = DX.Class,
        data = DX.data,
        odataUtils = data.utils.odata;
    var escapeServiceOperationParams = function(params) {
            if (!params)
                return params;
            var result = {};
            $.each(params, function(k, v) {
                result[k] = odataUtils.serializeValue(v)
            });
            return result
        };
    var convertSimpleKey = function(keyType, keyValue) {
            var converter = odataUtils.keyConverters[keyType];
            if (!converter)
                throw Error("Unknown key type: " + keyType);
            return converter(keyValue)
        };
    var SharedMethods = {
            _extractServiceOptions: function(options) {
                options = options || {};
                this._url = String(options.url).replace(/\/+$/, "");
                this._beforeSend = options.beforeSend;
                this._jsonp = options.jsonp
            },
            _sendRequest: function(url, method, params, payload) {
                return odataUtils.sendRequest({
                        url: url,
                        method: method,
                        params: params || {},
                        payload: payload
                    }, {
                        beforeSend: this._beforeSend,
                        jsonp: this._jsonp
                    })
            }
        };
    var ODataStore = data.Store.inherit({
            ctor: function(options) {
                this.callBase(options);
                this._extractServiceOptions(options);
                this._name = options.name;
                this._keyType = options.keyType
            },
            customLoadOptions: function() {
                return ["expand", "customQueryParams"]
            },
            _byKeyImpl: function(key, extraOptions) {
                var params = {};
                if (extraOptions)
                    if (extraOptions.expand)
                        params["$expand"] = $.map($.makeArray(extraOptions.expand), odataUtils.serializePropName).join();
                return this._sendRequest(this._byKeyUrl(key), "GET", params)
            },
            createQuery: function(loadOptions) {
                loadOptions = loadOptions || {};
                return data.query(this._url, {
                        beforeSend: this._beforeSend,
                        errorHandler: this._errorHandler,
                        jsonp: this._jsonp,
                        params: escapeServiceOperationParams(loadOptions.customQueryParams),
                        expand: loadOptions.expand
                    })
            },
            _insertImpl: function(values) {
                this._requireKey();
                var self = this,
                    d = $.Deferred();
                $.when(this._sendRequest(this._url, "POST", null, values)).done(function(serverResponse) {
                    d.resolve(values, self._keyGetter(serverResponse))
                }).fail($.proxy(d.reject, d));
                return d.promise()
            },
            _updateImpl: function(key, values) {
                var d = $.Deferred();
                $.when(this._sendRequest(this._byKeyUrl(key), "MERGE", null, values)).done(function() {
                    d.resolve(key, values)
                }).fail($.proxy(d.reject, d));
                return d.promise()
            },
            _removeImpl: function(key) {
                var d = $.Deferred();
                $.when(this._sendRequest(this._byKeyUrl(key), "DELETE")).done(function() {
                    d.resolve(key)
                }).fail($.proxy(d.reject, d));
                return d.promise()
            },
            _byKeyUrl: function(key) {
                var keyType = this._keyType;
                if ($.isPlainObject(keyType))
                    $.each(keyType, function(subKeyName, subKeyType) {
                        key[subKeyName] = convertSimpleKey(subKeyType, key[subKeyName])
                    });
                else if (keyType)
                    key = convertSimpleKey(keyType, key);
                return this._url + "(" + encodeURIComponent(odataUtils.serializeKey(key)) + ")"
            }
        }).include(SharedMethods);
    var ODataContext = Class.inherit({
            ctor: function(options) {
                var self = this;
                self._extractServiceOptions(options);
                self._errorHandler = options.errorHandler;
                $.each(options.entities || [], function(entityAlias, entityOptions) {
                    self[entityAlias] = new ODataStore($.extend({}, options, {url: self._url + "/" + encodeURIComponent(entityOptions.name || entityAlias)}, entityOptions))
                })
            },
            get: function(operationName, params) {
                return this.invoke(operationName, params, "GET")
            },
            invoke: function(operationName, params, httpMethod) {
                httpMethod = httpMethod || "POST";
                var d = $.Deferred();
                $.when(this._sendRequest(this._url + "/" + encodeURIComponent(operationName), httpMethod, escapeServiceOperationParams(params))).done(function(r) {
                    if (r && operationName in r)
                        r = r[operationName];
                    d.resolve(r)
                }).fail([this._errorHandler, data._handleError, $.proxy(d.reject, d)]);
                return d.promise()
            },
            objectLink: function(entityAlias, key) {
                var store = this[entityAlias];
                if (!store)
                    throw Error("Unknown entity name or alias: " + entityAlias);
                return {__metadata: {uri: store._byKeyUrl(key)}}
            }
        }).include(SharedMethods);
    $.extend(data, {
        ODataStore: ODataStore,
        ODataContext: ODataContext
    })
})(jQuery, DevExpress);

// Module core, file data.store.rest.js

(function($, DX, undefined) {
    var data = DX.data;
    function createAjaxFailureHandler(deferred) {
        return function(xhr, textStatus) {
                if (!xhr || !xhr.getResponseHeader)
                    deferred.reject.apply(deferred, arguments);
                else
                    deferred.reject(Error(data.utils.errorMessageFromXhr(xhr, textStatus)))
            }
    }
    function operationCustomizerPropName(operationName) {
        return "_customize" + DX.inflector.camelize(operationName, true)
    }
    function pathPropName(operationName) {
        return "_" + operationName + "Path"
    }
    data.RestStore = data.Store.inherit({
        ctor: function(options) {
            var self = this;
            self.callBase(options);
            options = options || {};
            self._url = String(options.url).replace(/\/+$/, "");
            self._jsonp = options.jsonp;
            $.each(["Load", "Insert", "Update", "Remove", "ByKey", "Operation"], function() {
                var value = options["customize" + this];
                if (value)
                    self[operationCustomizerPropName(this)] = value
            });
            $.each(["load", "insert", "update", "remove", "byKey"], function() {
                var value = options[this + "Path"];
                if (value)
                    self[pathPropName(this)] = value
            })
        },
        _loadImpl: function(options) {
            var d = $.Deferred(),
                ajaxOptions = {
                    url: this._formatUrlNoKey("load"),
                    type: "GET"
                };
            $.when(this._createAjax(ajaxOptions, "load", options)).done($.proxy(d.resolve, d)).fail(createAjaxFailureHandler(d));
            return this._addFailHandlers(d.promise())
        },
        createQuery: function() {
            throw Error("Not supported");
        },
        _insertImpl: function(values) {
            var d = $.Deferred(),
                self = this,
                ajaxOptions = {
                    url: this._formatUrlNoKey("insert"),
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify(values)
                };
            $.when(this._createAjax(ajaxOptions, "insert")).done(function(serverResponse) {
                d.resolve(values, self.key() && self._keyGetter(serverResponse))
            }).fail(createAjaxFailureHandler(d));
            return d.promise()
        },
        _updateImpl: function(key, values) {
            var d = $.Deferred(),
                ajaxOptions = {
                    url: this._formatUrlWithKey("update", key),
                    type: "PUT",
                    contentType: "application/json",
                    data: JSON.stringify(values)
                };
            $.when(this._createAjax(ajaxOptions, "update")).done(function() {
                d.resolve(key, values)
            }).fail(createAjaxFailureHandler(d));
            return d.promise()
        },
        _removeImpl: function(key) {
            var d = $.Deferred(),
                ajaxOptions = {
                    url: this._formatUrlWithKey("remove", key),
                    type: "DELETE"
                };
            $.when(this._createAjax(ajaxOptions, "remove")).done(function() {
                d.resolve(key)
            }).fail(createAjaxFailureHandler(d));
            return d.promise()
        },
        _byKeyImpl: function(key) {
            var d = $.Deferred(),
                ajaxOptions = {
                    url: this._formatUrlWithKey("byKey", key),
                    type: "GET"
                };
            $.when(this._createAjax(ajaxOptions, "byKey")).done(function(data) {
                d.resolve(data)
            }).fail(createAjaxFailureHandler(d));
            return d.promise()
        },
        _createAjax: function(ajaxOptions, operationName, extra) {
            var customizationFunc,
                customizationResult;
            function isDeferred(obj) {
                return "done" in obj && "fail" in obj
            }
            if (this._jsonp && ajaxOptions.type === "GET")
                ajaxOptions.dataType = "jsonp";
            else
                $.extend(true, ajaxOptions, {xhrFields: {withCredentials: true}});
            customizationFunc = this[operationCustomizerPropName("operation")];
            if (customizationFunc) {
                customizationResult = customizationFunc(ajaxOptions, operationName, extra);
                if (customizationResult) {
                    if (isDeferred(customizationResult))
                        return customizationResult;
                    ajaxOptions = customizationResult
                }
            }
            customizationFunc = this[operationCustomizerPropName(operationName)];
            if (customizationFunc) {
                customizationResult = customizationFunc(ajaxOptions, extra);
                if (customizationResult) {
                    if (isDeferred(customizationResult))
                        return customizationResult;
                    ajaxOptions = customizationResult
                }
            }
            return $.ajax(ajaxOptions)
        },
        _formatUrlNoKey: function(operationName) {
            var url = this._url,
                path = this[pathPropName(operationName)];
            if (!path)
                return url;
            if ($.isFunction(path))
                return path(url);
            return url + "/" + path
        },
        _formatUrlWithKey: function(operationName, key) {
            var url = this._url,
                path = this[pathPropName(operationName)];
            if (!path)
                return url + "/" + encodeURIComponent(key);
            if ($.isFunction(path))
                return path(url, key);
            return url + "/" + path + "/" + encodeURIComponent(key)
        }
    })
})(jQuery, DevExpress);

// Module core, file data.store.simple.js

(function($, DX, undefined) {
    var data = DX.data;
    function operationCustomizerPropName(operationName) {
        return "_customize" + DX.inflector.camelize(operationName, true)
    }
    function pathPropName(operationName) {
        return "_" + operationName + "Path"
    }
    data.SimpleStore = data.Store.inherit({
        ctor: function(options) {
            var self = this;
            self.callBase(options);
            options = options || {};
            self.changed = options.changed;
            self.userLoadCallback = options.load;
            self.userLookupCallback = options.lookup
        },
        _loadImpl: function(loadOptions) {
            if (!this.userLoadCallback)
                throw new Error('Load callback was not defined');
            var loadOptions2 = {refresh: loadOptions.refresh};
            loadOptions2.searchString = loadOptions.searchString;
            var result = this.userLoadCallback(loadOptions2);
            if (!result)
                result = (new $.Deferred).resolve([]);
            if ($.isArray(result))
                result = (new $.Deferred).resolve(result);
            return result
        },
        lookup: function(key, lookupExpression, lookupGetter) {
            if (!this.userLookupCallback)
                throw new Error('Lookup callback was not defined');
            var result = this.userLookupCallback(key, lookupExpression, lookupGetter);
            if ($.isArray(result))
                result = result[0];
            if (!result)
                result = (new $.Deferred).resolve([]);
            if (!result.done)
                result = (new $.Deferred).resolve(result);
            return result
        }
    })
})(jQuery, DevExpress);

// Module core, file data.dataSource.js

(function($, DX, undefined) {
    var data = DX.data,
        Class = DX.Class;
    var LOCAL_KEY_PROP = "__key__";
    var emptyPromise = $.Deferred().resolve([]).promise();
    var DataSource = Class.inherit({
            ctor: function(options) {
                options = options || {};
                var store = options.store;
                if ($.isArray(store))
                    store = new data.ArrayStore(store);
                this._store = store;
                this._storeLoadOptions = this._extractLoadOptions(options);
                this._mapFunc = options.map;
                this._postProcessFunc = options.postProcess;
                this._pageIndex = 0;
                this._pageSize = options.pageSize !== undefined ? options.pageSize : 20;
                this._items = [];
                this._updateMode = options.updateMode || "item";
                this._isLoaded = false;
                this._paginate = options.paginate;
                if (this._paginate === undefined)
                    this._paginate = !this._isGrouped();
                this._isLastPage = !this._paginate;
                this.changed = $.Callbacks();
                this.loadError = $.Callbacks();
                store.updated.add(this._storeUpdatedHandler = $.proxy(this._handleStoreUpdated, this));
                store.inserted.add(this._storeInsertedHandler = $.proxy(this._handleStoreInserted, this));
                store.removed.add(this._storeRemovedHandler = $.proxy(this._handleStoreRemoved, this));
                this._customizeFilters = $.Callbacks()
            },
            dispose: function() {
                this.changed.empty();
                this.loadError.empty();
                this._store.updated.remove(this._storeUpdatedHandler);
                delete this._storeUpdatedHandler;
                this._store.inserted.remove(this._storeInsertedHandler);
                delete this._storeInsertedHandler;
                this._store.removed.remove(this._storeRemovedHandler);
                delete this._storeRemovedHandler;
                delete this._store;
                this._disposed = true
            },
            _extractLoadOptions: function(options) {
                var result = {},
                    names = ["sort", "filter", "select", "group"],
                    customNames = this._store.customLoadOptions();
                if (customNames)
                    names = names.concat(customNames);
                $.each(names, function() {
                    result[this] = options[this]
                });
                return result
            },
            loadOptions: function() {
                return this._storeLoadOptions
            },
            _accessStoreLoadOption: function(name, value) {
                var options = this._storeLoadOptions;
                if (arguments.length < 2)
                    return options[name];
                options[name] = value;
                this.reload()
            },
            filter: function(expr) {
                if (!arguments.length)
                    return this._accessStoreLoadOption("filter");
                if (expr && !$.isArray(expr))
                    expr = $.makeArray(arguments);
                this._accessStoreLoadOption("filter", expr)
            },
            clearFilter: function() {
                this.filter(null)
            },
            sortBy: function(expr) {
                if (arguments.length > 1)
                    expr = {
                        selector: arguments[0],
                        desc: arguments[1]
                    };
                this._accessStoreLoadOption("sort", expr)
            },
            clearSort: function() {
                this.sortBy(null)
            },
            store: function() {
                return this._store
            },
            key: function() {
                return this._store && this._store.key()
            },
            _isGrouped: function() {
                return !!this._storeLoadOptions.group
            },
            _assignPageIndex: function(value) {
                if (this._pageIndex === value)
                    return;
                this._pageIndex = value;
                this.load()
            },
            reload: function(options) {
                this._pageIndex = 0;
                this._isLastPage = false;
                return this._loadCore(options)
            },
            load: function(options) {
                return this._loadCore(options)
            },
            isLoaded: function() {
                return this._isLoaded
            },
            lookup: function(options) {
                var d = new $.Deferred,
                    self = this,
                    key = options.key;
                options.lookupExpression = options.lookupExpression || self.key();
                if (this._store.lookup)
                    this._store.lookup(key).done(function(item) {
                        var transformed = self._transformLoadedData(item);
                        d.resolve(transformed[0])
                    });
                else if (options.lookupExpression && options.lookupExpression === self.key())
                    this._loadSingleByKey(key).done(function(item) {
                        d.resolve(item)
                    });
                else {
                    var newDataSource = self._store.toDataSource();
                    newDataSource.load({
                        searchString: key,
                        searchMethod: "=",
                        searchField: options.lookupExpression,
                        silent: true
                    }).done(function() {
                        var items = newDataSource.items();
                        var transformed = self._transformLoadedData(items);
                        d.resolve(transformed[0])
                    }).always(function() {
                        newDataSource.dispose()
                    })
                }
                return d
            },
            nextPage: function(append) {
                append = append === undefined ? true : append;
                if (this._isLastPage)
                    return emptyPromise;
                this._pageIndex++;
                var options = {append: append};
                $.extend(options, this._searchCondition);
                return this._loadCore(options)
            },
            _loadCore: function(options) {
                options = options || {};
                var self = this,
                    d = $.Deferred(),
                    errorCallback = self.loadError,
                    loadOptions = $.extend(true, {}, self._storeLoadOptions),
                    pageIndex = self._pageIndex,
                    localFilter;
                if (!this.userDataSource && (options.searchField || loadOptions.searchFilter)) {
                    if (loadOptions.filter && !$.isArray(loadOptions.filter[0]))
                        loadOptions.filter = [loadOptions.filter];
                    loadOptions.filter = loadOptions.filter || [];
                    if (options.searchField)
                        localFilter = [options.searchField, options.searchMethod || "contains", options.searchString];
                    else
                        localFilter = loadOptions.searchFilter;
                    loadOptions.filter.push(localFilter);
                    self._storeLoadOptions.searchFilter = localFilter
                }
                if (this._paginate)
                    if (self._pageSize)
                        $.extend(loadOptions, {
                            skip: self._pageIndex * self._pageSize,
                            take: self._pageSize
                        });
                $.extend(loadOptions, {
                    refresh: !self._paginate || self._pageIndex === 0,
                    searchString: options.searchString
                });
                var loadTask = function() {
                        if (self._disposed)
                            return undefined;
                        return $.when(self._store.load(loadOptions)).done(function(data) {
                                DX.utils.executeAsync(function() {
                                    if (self._disposed)
                                        return;
                                    var items = self._items;
                                    data = self._transformLoadedData(data);
                                    if (!options.append)
                                        items.splice(0, items.length);
                                    items.push.apply(items, data);
                                    if (!data.length || !self._paginate || self._pageSize && data.length < self._pageSize)
                                        self._isLastPage = true;
                                    self._isLoaded = true;
                                    if (!options.silent)
                                        self.changed.fire();
                                    d.resolve(data)
                                })
                            }).fail($.proxy(d.reject, d))
                    };
                if (DataSourceLoadLock.locked())
                    DataSourceLoadLock.addTask(loadTask);
                else
                    loadTask();
                return d.promise().fail($.proxy(errorCallback.fire, errorCallback))
            },
            _loadSingleByKey: function(key) {
                var self = this,
                    d = $.Deferred();
                if (!self._disposed)
                    $.when(self._store.byKey(key)).done(function(item) {
                        if (self._disposed)
                            return;
                        var transformed = self._transformLoadedData(item);
                        d.resolve(transformed[0])
                    });
                return d.promise()
            },
            _transformLoadedData: function(data) {
                var self = this,
                    result;
                result = $.map($.makeArray(data), function(item, index) {
                    var keyValue = self._store.keyOf(item),
                        transformed;
                    if (self._mapFunc)
                        transformed = self._mapFunc(item, index);
                    else if (typeof item === "object")
                        transformed = $.extend({}, item);
                    else
                        transformed = item;
                    if (typeof item === "object")
                        transformed[LOCAL_KEY_PROP] = keyValue;
                    return transformed
                });
                if (self._postProcessFunc)
                    result = self._postProcessFunc(result);
                return result
            },
            _localIndexByKey: function(key) {
                var items = this._items,
                    len = items.length,
                    keyExpr = this._store.key(),
                    itemKey;
                for (var i = 0; i < len; i++) {
                    itemKey = items[i][LOCAL_KEY_PROP];
                    if (data.utils.keysEqual(keyExpr, itemKey, key))
                        return i
                }
                return -1
            },
            _handleStoreUpdated: function(key) {
                var self = this;
                switch (self._updateMode) {
                    case"full":
                        this.reload();
                        break;
                    case"item":
                        if (self._isGrouped())
                            return;
                        var localIndex = this._localIndexByKey(key);
                        if (localIndex < 0)
                            return;
                        self._loadSingleByKey(key).done(function(item) {
                            self._items.splice(localIndex, 1, item);
                            self.changed.fire()
                        });
                        break
                }
            },
            _handleStoreInserted: function(_, key) {
                var self = this;
                switch (self._updateMode) {
                    case"full":
                        self.reload();
                        break;
                    case"item":
                        if (self._isGrouped())
                            return;
                        self._loadSingleByKey(key).done(function(item) {
                            self._items.push(item);
                            self.changed.fire()
                        });
                        break
                }
            },
            _handleStoreRemoved: function(key) {
                var self = this;
                switch (self._updateMode) {
                    case"full":
                        self.reload();
                        break;
                    case"item":
                        if (self._isGrouped())
                            return;
                        var localIndex = this._localIndexByKey(key);
                        if (localIndex < 0)
                            return;
                        self._items.splice(localIndex, 1);
                        self.changed.fire();
                        break
                }
            }
        });
    var SimpleDataSource = DataSource.inherit({
            items: function() {
                return this._items
            },
            pageIndex: function(value) {
                if (value === undefined)
                    return this._pageIndex;
                this._assignPageIndex(value)
            },
            isLastPage: function() {
                return this._isLastPage
            }
        });
    var KoDataSource = DataSource.inherit({
            ctor: function(store, options) {
                this.callBase(store, options);
                var pinger = ko.observable();
                this.changed.add(function() {
                    pinger.notifySubscribers()
                });
                this.items = ko.computed(function() {
                    pinger();
                    return this._items
                }, this);
                this.pageIndex = ko.computed({
                    read: function() {
                        pinger();
                        return this._pageIndex
                    },
                    write: function(value) {
                        this._assignPageIndex(value)
                    }
                }, this);
                this.isLastPage = ko.computed(function() {
                    pinger();
                    return this._isLastPage
                }, this)
            },
            dispose: function() {
                this.callBase();
                this.items.dispose();
                this.pageIndex.dispose();
                this.isLastPage.dispose()
            }
        });
    data.Store.redefine({toDataSource: function(options, impl) {
            var dataSource;
            options = $.extend({store: this}, options);
            if ($.isFunction(impl))
                dataSource = new impl(options);
            else
                switch (impl) {
                    case"simple":
                        dataSource = new SimpleDataSource(options);
                        break;
                    default:
                        dataSource = new KoDataSource(options)
                }
            if (dataSource && this.changed && $.isFunction(this.changed.add))
                this.changed.add(function() {
                    dataSource.reload()
                });
            if (options.userDataSource)
                dataSource.userDataSource = options.userDataSource;
            return dataSource
        }});
    var createDataSource = function(dataSourceOptions) {
            var defaultDataSourceType = window.ko ? KoDataSource : SimpleDataSource;
            return new DX.data.SimpleStore(dataSourceOptions).toDataSource({
                    pageSize: null,
                    userDataSource: true
                }, defaultDataSourceType)
        };
    var DataSourceLoadLock = new function() {
            var delayedLoadTasks = [],
                lockCount = 0;
            var obtain = function() {
                    lockCount++
                };
            var release = function() {
                    lockCount--;
                    if (lockCount < 1) {
                        $.each(delayedLoadTasks, function() {
                            DX.enqueue(this)
                        });
                        delayedLoadTasks = []
                    }
                };
            return {
                    obtain: obtain,
                    release: release,
                    locked: function() {
                        return lockCount > 0
                    },
                    addTask: function(task) {
                        delayedLoadTasks.push(task)
                    }
                }
        };
    $.extend(true, data, {
        DataSource: DataSource,
        KoDataSource: KoDataSource,
        SimpleDataSource: SimpleDataSource,
        createDataSource: createDataSource,
        utils: {DataSourceLoadLock: DataSourceLoadLock}
    })
})(jQuery, DevExpress);

// Module core, file social.js

DevExpress.social = {};

// Module core, file facebook.js

(function($, DX, undefined) {
    var social = DX.social;
    var location = window.location,
        navigator = window.navigator,
        encodeURIComponent = window.encodeURIComponent,
        decodeURIComponent = window.decodeURIComponent,
        iosStandaloneMode = navigator.standalone,
        cordovaMode = false;
    if (window.cordova)
        $(document).on("deviceready", function() {
            cordovaMode = true
        });
    var ACCESS_TOKEN_KEY = "dx-facebook-access-token",
        IOS_STANDALONE_STEP1_KEY = "dx-facebook-step1",
        IOS_STANDALONE_STEP2_KEY = "dx-facebook-step2";
    var accessToken = null,
        expires = null,
        connectionChanged = $.Callbacks();
    var pendingLoginRedirectUrl;
    var isConnected = function() {
            return !!accessToken
        };
    var getAccessTokenObject = function() {
            return {
                    accessToken: accessToken,
                    expiresIn: accessToken ? expires : 0
                }
        };
    var FB = social.Facebook = {
            loginRedirectUrl: "FacebookLoginCallback.html",
            connectionChanged: connectionChanged,
            isConnected: isConnected,
            getAccessTokenObject: getAccessTokenObject,
            jsonp: false
        };
    var login = function(appId, options) {
            options = options || {};
            if (cordovaMode)
                pendingLoginRedirectUrl = "https://www.facebook.com/connect/login_success.html";
            else
                pendingLoginRedirectUrl = formatLoginRedirectUrl();
            var scope = (options.permissions || []).join(),
                url = "https://www.facebook.com/dialog/oauth?display=popup&client_id=" + appId + "&redirect_uri=" + encodeURIComponent(pendingLoginRedirectUrl) + "&scope=" + encodeURIComponent(scope) + "&response_type=token";
            if (iosStandaloneMode)
                putData(IOS_STANDALONE_STEP1_KEY, location.href);
            if (cordovaMode)
                startLogin_cordova(url);
            else
                startLogin_browser(url)
        };
    var formatLoginRedirectUrl = function() {
            var pathSegments = location.pathname.split(/\//g);
            pathSegments.pop();
            pathSegments.push(FB.loginRedirectUrl);
            return location.protocol + "//" + location.host + pathSegments.join("/")
        };
    var startLogin_browser = function(loginUrl) {
            var width = 512,
                height = 320,
                left = (screen.width - width) / 2,
                top = (screen.height - height) / 2;
            window.open(loginUrl, null, "width=" + width + ",height=" + height + ",toolbar=0,scrollbars=0,status=0,resizable=0,menuBar=0,left=" + left + ",top=" + top)
        };
    var startLogin_cordova = function(loginUrl) {
            var ref = window.open(loginUrl, "_blank");
            ref.addEventListener('exit', function(event) {
                pendingLoginRedirectUrl = null
            });
            ref.addEventListener('loadstop', function(event) {
                var url = unescape(event.url);
                if (url.indexOf(pendingLoginRedirectUrl) === 0) {
                    ref.close();
                    _processLoginRedirectUrl(url)
                }
            })
        };
    var handleLoginRedirect = function() {
            var opener = window.opener;
            if (iosStandaloneMode) {
                putData(IOS_STANDALONE_STEP2_KEY, location.href);
                location.href = getData(IOS_STANDALONE_STEP1_KEY)
            }
            else if (opener && opener.DevExpress) {
                opener.DevExpress.social.Facebook._processLoginRedirectUrl(location.href);
                window.close()
            }
        };
    var _processLoginRedirectUrl = function(url) {
            var params = parseUrlFragment(url);
            expires = params.expires_in;
            changeToken(params.access_token);
            pendingLoginRedirectUrl = null
        };
    var parseUrlFragment = function(url) {
            var hash = url.split("#")[1];
            if (!hash)
                return {};
            var pairs = hash.split(/&/g),
                result = {};
            $.each(pairs, function(i) {
                var splitPair = this.split("=");
                result[splitPair[0]] = decodeURIComponent(splitPair[1])
            });
            return result
        };
    var logout = function() {
            changeToken(null)
        };
    var changeToken = function(value) {
            if (value === accessToken)
                return;
            accessToken = value;
            putData(ACCESS_TOKEN_KEY, value);
            connectionChanged.fire(!!value)
        };
    var api = function(resource, method, params) {
            if (!isConnected())
                throw Error("Not connected");
            if (typeof method !== "string") {
                params = method;
                method = undefined
            }
            method = (method || "get").toLowerCase();
            var d = $.Deferred();
            var args = arguments;
            $.ajax({
                url: "https://graph.facebook.com/" + resource,
                type: method,
                data: $.extend({access_token: accessToken}, params),
                dataType: FB.jsonp && method === "get" ? "jsonp" : "json"
            }).done(function(response) {
                response = response || simulateErrorResponse();
                if (response.error)
                    d.reject(response.error);
                else
                    d.resolve(response)
            }).fail(function(xhr) {
                var response;
                try {
                    response = $.parseJSON(xhr.responseText);
                    var tries = args[3] || 0;
                    if (tries++ < 3 && response.error.code == 190 && response.error.error_subcode == 466) {
                        setTimeout(function() {
                            api(resource, method, params, tries).done(function(result) {
                                d.resolve(result)
                            }).fail(function(error) {
                                d.reject(error)
                            })
                        }, 500);
                        return
                    }
                }
                catch(x) {
                    response = simulateErrorResponse()
                }
                d.reject(response.error)
            });
            return d.promise()
        };
    var simulateErrorResponse = function() {
            return {error: {message: "Unknown error"}}
        };
    var ensureStorageBackend = function() {
            if (!hasStorageBackend())
                throw Error("HTML5 sessionStorage or jQuery.cookie plugin is required");
        };
    var hasStorageBackend = function() {
            return !!($.cookie || window.sessionStorage)
        };
    var putData = function(key, data) {
            ensureStorageBackend();
            data = JSON.stringify(data);
            if (window.sessionStorage)
                if (data === null)
                    sess.removeItem(key);
                else
                    sessionStorage.setItem(key, data);
            else
                $.cookie(key, data)
        };
    var getData = function(key) {
            ensureStorageBackend();
            try {
                return JSON.parse(window.sessionStorage ? sessionStorage.getItem(key) : $.cookie(key))
            }
            catch(x) {
                return null
            }
        };
    if (hasStorageBackend())
        accessToken = getData(ACCESS_TOKEN_KEY);
    if (iosStandaloneMode) {
        var url = getData(IOS_STANDALONE_STEP2_KEY);
        if (url) {
            _processLoginRedirectUrl(url);
            putData(IOS_STANDALONE_STEP1_KEY, null);
            putData(IOS_STANDALONE_STEP2_KEY, null)
        }
    }
    $.extend(FB, {
        login: login,
        logout: logout,
        handleLoginRedirect: handleLoginRedirect,
        _processLoginRedirectUrl: _processLoginRedirectUrl,
        api: api
    })
})(jQuery, DevExpress);

// Module core, file ui.js

(function($, DX, undefined) {
    var ui = DX.ui = {};
    var initViewport = function(options) {
            options = $.extend({}, options);
            var allowZoom = options.allowZoom,
                allowPan = options.allowPan;
            var metaSelector = "meta[name=viewport]";
            if (!$(metaSelector).length)
                $("<meta />").attr("name", "viewport").appendTo("head");
            var metaVerbs = ["width=device-width"],
                msTouchVerbs = [];
            if (allowZoom)
                msTouchVerbs.push("pinch-zoom");
            else
                metaVerbs.push("initial-scale=1.0", "maximum-scale=1.0");
            if (allowPan)
                msTouchVerbs.push("pan-x", "pan-y");
            if (!allowPan && !allowZoom)
                $("html, body").css("overflow", "hidden");
            else
                $("html").css("-ms-overflow-style", "-ms-autohiding-scrollbar");
            $(metaSelector).attr("content", metaVerbs.join());
            $("html").css("-ms-touch-action", msTouchVerbs.join(" ") || "none");
            if (DX.support.touch)
                $(document).on("touchmove", function(e) {
                    var count = e.originalEvent.touches.length;
                    if (!allowPan && count === 1 || !allowZoom && count > 1)
                        e.preventDefault()
                })
        };
    var hideAdressBar = function() {
            var nav = navigator,
                iphone = /iphone|ipod/i.test(nav.appVersion),
                isBrowser = !nav.standalone && /safari/i.test(nav.userAgent);
            if (iphone && isBrowser) {
                var height = $(window).height() + 60;
                if ($("body").height() !== height)
                    $("body").height(height);
                setTimeout(function() {
                    window.scrollTo(0, 1)
                }, 0)
            }
        };
    $(window).on("load resize orientationchange", hideAdressBar);
    var Template = DX.Class.inherit({
            ctor: function(element) {
                this._element = $(element);
                this._template = $("<div />").append(element)
            },
            render: function(container) {
                var result = this._template.clone(true, true).contents();
                container.append(result);
                return result
            }
        });
    DX.registerActionExecutor({
        designMode: {validate: function(e) {
                if (DX.designMode && !(e.context instanceof ui.dxScrollable) && !(e.context instanceof ui.dxScrollView))
                    e.canceled = true
            }},
        gesture: {validate: function(e) {
                var args = e.args,
                    context = e.context,
                    component = args.length && args[0].component;
                if (ui.gestureUtils.hasRecent() && context !== ui.dxSwipeable && !(context instanceof ui.dxScrollable) && !(context instanceof ui.dxScrollView) && !(component instanceof ui.dxSwipeable) && !(component instanceof ui.dxScrollable))
                    e.canceled = true
            }},
        disabled: {validate: function(e) {
                if (!e.args.length)
                    return;
                var element = e.args[0].element;
                if (element && element.is(".dx-state-disabled, .dx-state-disabled *"))
                    e.canceled = true
            }},
        disabledCollectionContainerWidgetItem: {validate: function(e) {
                if (!e.args.length)
                    return;
                var element = e.args[0].itemElement;
                if (element && element.is(".dx-state-disabled *"))
                    e.canceled = true
            }}
    });
    var dialog = function(options) {
            var DX_DIALOG_CLASSNAME = "dx-dialog",
                DX_DIALOG_ROOT_CLASSNAME = DX_DIALOG_CLASSNAME + "-root",
                DX_DIALOG_CONTENT_CLASSNAME = DX_DIALOG_CLASSNAME + "-content",
                DX_DIALOG_MESSAGE_CLASSNAME = DX_DIALOG_CLASSNAME + "-message",
                DX_DIALOG_BUTTONS_CLASSNAME = DX_DIALOG_CLASSNAME + "-buttons",
                DX_DIALOG_BUTTON_CLASSNAME = DX_DIALOG_CLASSNAME + "-button";
            var result,
                deferred,
                instance,
                $holder,
                $element,
                $message,
                $buttons,
                oldShow,
                oldHide;
            function div() {
                return $("<div/>")
            }
            if (!ui.dxPopup)
                throw new Error("DevExpress.ui.dxPopup required.");
            options = $.extend(ui.optionsByDevice(DX.devices.current(), "dxDialog"), options);
            $holder = $(".dx-viewport");
            $element = div().addClass(DX_DIALOG_CLASSNAME).appendTo($holder);
            $message = div().addClass(DX_DIALOG_MESSAGE_CLASSNAME).html(String(options.message));
            $buttons = div().addClass(DX_DIALOG_BUTTONS_CLASSNAME);
            deferred = $.Deferred();
            instance = $element.dxPopup({
                title: options.title || self.title,
                fullscreen: false,
                height: "auto",
                width: function() {
                    var isPortrait = $(window).height() > $(window).width(),
                        key = (isPortrait ? "p" : "l") + "Width";
                    return options.hasOwnProperty(key) ? options[key] : options["width"]
                }
            }).data("dxPopup");
            $.each(options.buttons || [{
                    text: "Ok",
                    clickAction: function() {
                        return true
                    }
                }], function() {
                var buttonOptions = this,
                    buttonClickAction = new DX.Action(this.clickAction, {context: instance});
                div().addClass(DX_DIALOG_BUTTON_CLASSNAME).appendTo($buttons).dxButton($.extend(buttonOptions, {clickAction: function() {
                        result = buttonClickAction.execute(arguments);
                        instance.hide()
                    }}))
            });
            instance.rootElement().addClass(DX_DIALOG_ROOT_CLASSNAME);
            instance.content().addClass(DX_DIALOG_CONTENT_CLASSNAME).append($message).append($buttons);
            instance.message = function() {
                return $message
            };
            instance.buttons = function() {
                return $buttons
            };
            instance.result = function() {
                return result
            };
            oldShow = instance.show;
            instance.show = function() {
                oldShow.apply(this, arguments);
                return deferred.promise()
            };
            oldHide = instance.hide;
            instance.hide = function() {
                oldHide.apply(this, arguments);
                this.rootElement().remove();
                deferred.resolve(this.result())
            };
            return instance
        };
    dialog.alert = function(message, title) {
        var dialog,
            options = $.isPlainObject(message) ? message : {
                title: title,
                message: message
            };
        dialog = this.custom(options);
        return dialog.show()
    };
    dialog.confirm = function(message, title) {
        var dialog,
            options = $.isPlainObject(message) ? message : {
                title: title,
                message: message,
                buttons: [{
                        text: "Yes",
                        clickAction: function() {
                            return true
                        }
                    }, {
                        text: "No",
                        clickAction: function() {
                            return false
                        }
                    }]
            };
        dialog = this.custom(options);
        return dialog.show()
    };
    $.extend(ui, {
        Template: Template,
        initViewport: initViewport,
        notify: function(message, type, displayTime) {
            var instance,
                hiddenAction,
                options = $.isPlainObject(message) ? message : {message: message};
            if (!ui.dxToast) {
                alert(options.message);
                return
            }
            if (type)
                options.type = type;
            if (displayTime)
                options.displayTime = displayTime;
            instance = $("<div/>").appendTo($(".dx-viewport")).dxToast(options).data("dxToast");
            instance.option("hiddenAction", function() {
                this.rootElement().remove();
                new DX.Action(options.hiddenAction, {context: this}).execute(arguments)
            });
            instance.show()
        },
        dialog: {
            custom: dialog,
            alert: dialog.alert,
            confirm: dialog.confirm
        }
    });
    ui.__internals = {Template: Template}
})(jQuery, DevExpress);

// Module core, file ui.knockoutIntegration.js

(function($, DX, undefined) {
    var ko = window.ko;
    if (!ko)
        return;
    if (parseFloat(ko.version) < 2.2)
        throw Error("Your version of KnockoutJS is too old. Please upgrade KnockoutJS to 2.2.0 or later.");
    var ui = DX.ui,
        inflector = DX.inflector,
        DATA_BIND_ATTR = "data-bind",
        ANONYMOUS_BINDING_KEY = "unknown",
        ANONYMOUS_OPTION_NAME_FOR_OPTIONS_BAG = "_";
    var LOCKS_DATA_KEY = "dxKoLocks",
        MODEL_TO_OPTIONS_LOCK_NAME = "M2O",
        OPTIONS_TO_MODEL_LOCK_NAME = "O2M",
        CREATED_WITH_KO_DATA_KEY = "dxKoCreation";
    var defaultBindingProvider = ko.bindingProvider.instance,
        parseObjectLiteral = ko.jsonExpressionRewriting.parseObjectLiteral,
        bindingEvaluatorElement = $("<div></div>");
    var isComponentName = function(name) {
            return name in ui && ui[name].subclassOf && ui[name].subclassOf(ui.Component)
        };
    var stripQuotes = function(text) {
            return text.replace(/^['"]|['"]$/g, "")
        };
    var hideComponentBindings = function(element) {
            element = $(element);
            var bindingExpr = element.attr(DATA_BIND_ATTR);
            if (!bindingExpr)
                return;
            var parsedBindingExpr = parseObjectLiteral(bindingExpr),
                newBindingFragments = [],
                found = false;
            $.each(parsedBindingExpr, function() {
                var componentName = stripQuotes(this.key),
                    hiddenBindingsAttrName = "data-" + inflector.underscore(componentName);
                if (isComponentName(componentName) && !element.attr(hiddenBindingsAttrName)) {
                    found = true;
                    element.attr(hiddenBindingsAttrName, this.value);
                    newBindingFragments.push({
                        key: componentName,
                        value: "true"
                    })
                }
                else
                    newBindingFragments.push(this)
            });
            if (found)
                element.attr(DATA_BIND_ATTR, $.map(newBindingFragments, function(i) {
                    return i.key + ": " + i.value
                }).join(", "))
        };
    var PatchedBindingProvider = {
            _original: defaultBindingProvider,
            nodeHasBindings: function(node) {
                return defaultBindingProvider.nodeHasBindings(node)
            },
            getBindings: function(node, bindingContext) {
                hideComponentBindings(node);
                return defaultBindingProvider.getBindings(node, bindingContext)
            }
        };
    var Locks = function() {
            var info = {};
            var currentCount = function(lockName) {
                    return info[lockName] || 0
                };
            return {
                    obtain: function(lockName) {
                        info[lockName] = currentCount(lockName) + 1
                    },
                    release: function(lockName) {
                        var count = currentCount(lockName);
                        if (count < 1)
                            throw Error("Not locked");
                        if (count === 1)
                            delete info[lockName];
                        else
                            info[lockName] = count - 1
                    },
                    locked: function(lockName) {
                        return currentCount(lockName) > 0
                    }
                }
        };
    var registerComponentKoBinding = function(componentName) {
            var parseHiddenBindings = function(element) {
                    var bindingString = $.trim(element.attr("data-" + inflector.underscore(componentName))),
                        result,
                        firstItem;
                    if (bindingString.charAt(0) === "{") {
                        result = parseObjectLiteral(bindingString);
                        firstItem = result[0];
                        if (firstItem && ANONYMOUS_BINDING_KEY in firstItem)
                            result = $.trim(firstItem[ANONYMOUS_BINDING_KEY])
                    }
                    else
                        result = bindingString;
                    if (result === "")
                        result = [];
                    return result
                };
            ko.bindingHandlers[componentName] = {init: function(domNode) {
                    var element = $(domNode),
                        parsedBindings = parseHiddenBindings(element),
                        ctorOptions = {},
                        optionNameToModelMap = {};
                    var evalModelValue = function(optionName, modelValueExpr) {
                            bindingEvaluatorElement.attr(DATA_BIND_ATTR, optionName + ":" + modelValueExpr);
                            try {
                                return defaultBindingProvider.getBindings(bindingEvaluatorElement[0], ko.contextFor(domNode))[optionName]
                            }
                            finally {
                                bindingEvaluatorElement.removeAttr(DATA_BIND_ATTR)
                            }
                        };
                    var applyModelValueToOption = function(optionName, modelValue) {
                            var component = element.data(componentName),
                                locks = element.data(LOCKS_DATA_KEY),
                                optionValue = ko.utils.unwrapObservable(modelValue);
                            if (!component) {
                                ctorOptions[optionName] = optionValue;
                                if (ko.isWriteableObservable(modelValue))
                                    optionNameToModelMap[optionName] = modelValue
                            }
                            else {
                                if (locks.locked(OPTIONS_TO_MODEL_LOCK_NAME))
                                    return;
                                locks.obtain(MODEL_TO_OPTIONS_LOCK_NAME);
                                try {
                                    component.option(optionName, optionValue)
                                }
                                finally {
                                    locks.release(MODEL_TO_OPTIONS_LOCK_NAME)
                                }
                            }
                        };
                    var handleOptionChanged = function(optionName, optionValue) {
                            if (!(optionName in optionNameToModelMap))
                                return;
                            var element = this._element,
                                locks = element.data(LOCKS_DATA_KEY);
                            if (locks.locked(MODEL_TO_OPTIONS_LOCK_NAME))
                                return;
                            locks.obtain(OPTIONS_TO_MODEL_LOCK_NAME);
                            try {
                                optionNameToModelMap[optionName](optionValue)
                            }
                            finally {
                                locks.release(OPTIONS_TO_MODEL_LOCK_NAME)
                            }
                        };
                    ko.utils.domNodeDisposal.addDisposeCallback(domNode, function() {
                        $.each(element.data("dxComponents") || [], function(index, item) {
                            element.data(item)._dispose()
                        })
                    });
                    if (typeof parsedBindings === "string")
                        ko.computed(function() {
                            $.each(ko.utils.unwrapObservable(evalModelValue(ANONYMOUS_OPTION_NAME_FOR_OPTIONS_BAG, parsedBindings)), applyModelValueToOption)
                        }, null, {disposeWhenNodeIsRemoved: domNode});
                    else
                        $.each(parsedBindings, function() {
                            var optionName = stripQuotes($.trim(this.key)),
                                modelValueExpr = $.trim(this.value);
                            ko.computed(function() {
                                var modelValue = evalModelValue(optionName, modelValueExpr);
                                applyModelValueToOption(optionName, modelValue)
                            }, null, {disposeWhenNodeIsRemoved: domNode})
                        });
                    if (ctorOptions) {
                        element.data(CREATED_WITH_KO_DATA_KEY, true);
                        element[componentName](ctorOptions);
                        ctorOptions = null;
                        element.data(LOCKS_DATA_KEY, new Locks);
                        element.data(componentName).optionChanged.add(handleOptionChanged)
                    }
                    return {controlsDescendantBindings: ui[componentName].subclassOf(ui.Widget)}
                }}
        };
    ko.bindingProvider.instance = PatchedBindingProvider;
    var KoTemplate = ui.Template.inherit({
            ctor: function(element) {
                this.callBase(element);
                this._cleanTemplateElement();
                this._registerKoTemplate()
            },
            _cleanTemplateElement: function() {
                this._element.each(function() {
                    ko.cleanNode(this)
                })
            },
            _registerKoTemplate: function() {
                var template = this._template.get(0);
                new ko.templateSources.anonymousTemplate(template)['nodes'](template)
            },
            render: function(container, data) {
                if (!$(container).closest("body").length)
                    throw Error("Attempt to render into container detached from document");
                data = data !== undefined ? data : ko.dataFor(container.get(0)) || {};
                var containerBindingContext = ko.contextFor(container[0]);
                var bindingContext = containerBindingContext ? containerBindingContext.createChildContext(data) : data;
                var renderBag = $("<div />").appendTo(container);
                ko.renderTemplate(this._template.get(0), bindingContext, null, renderBag.get(0));
                var result = renderBag.contents();
                container.append(result);
                renderBag.remove();
                return result
            }
        });
    ko.bindingHandlers.dxAction = {
        init: function(element, valueAccessor, allBindingsAccessor, viewModel) {
            ko.bindingHandlers.click.init(element, function() {
                return function() {
                        $(element).data('action').execute({
                            element: $(element),
                            model: viewModel
                        })
                    }
            }, allBindingsAccessor, viewModel)
        },
        update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
            var $element = $(element),
                actionSource = ko.utils.unwrapObservable(valueAccessor());
            $element.data('action', new DX.Action(actionSource, {context: $element}))
        }
    };
    var defaultKoTemplate = function() {
            var cache = {};
            return function(widgetName) {
                    if (!DEFAULT_ITEM_TEMPLATE_GENERATORS[widgetName])
                        widgetName = "base";
                    if (!cache[widgetName]) {
                        var html = DEFAULT_ITEM_TEMPLATE_GENERATORS[widgetName](),
                            markup = DX.utils.createMarkupFromString(html);
                        markup.each(function() {
                            hideComponentBindings($(this))
                        });
                        cache[widgetName] = new KoTemplate(markup)
                    }
                    return cache[widgetName]
                }
        }();
    var createElementWithBindAttr = function(tagName, bindings, closeTag) {
            closeTag = closeTag === undefined ? true : closeTag;
            var bindAttr = $.map(bindings, function(value, key) {
                    return key + ":" + value
                }).join(",");
            return "<" + tagName + " data-bind=\"" + bindAttr + "\">" + (closeTag ? "</" + tagName + ">" : "")
        };
    var defaultKoTemplateBasicBindings = {
            visible: "$data.visible === undefined || $data.visible",
            css: "{ 'dx-state-disabled': $data.disabled }"
        };
    var DEFAULT_ITEM_TEMPLATE_GENERATORS = {base: function() {
                var template = [createElementWithBindAttr("div", defaultKoTemplateBasicBindings, false)],
                    htmlBinding = createElementWithBindAttr("div", {html: "html"}),
                    textBinding = createElementWithBindAttr("div", {text: "text"}),
                    primitiveBinding = createElementWithBindAttr("div", {html: "String($data)"});
                template.push("<!-- ko if: $data.html -->", htmlBinding, "<!-- /ko -->", "<!-- ko if: !$data.html && $data.text -->", textBinding, "<!-- /ko -->", "<!-- ko ifnot: $.isPlainObject($data) -->", primitiveBinding, "<!-- /ko -->", "</div>");
                return template.join("")
            }};
    DEFAULT_ITEM_TEMPLATE_GENERATORS.dxList = function() {
        var template = DEFAULT_ITEM_TEMPLATE_GENERATORS.base(),
            keyBinding = createElementWithBindAttr("div", {html: "key"});
        template = [template.substring(0, template.length - 6), "<!-- ko if: $data.key -->" + keyBinding + "<!-- /ko -->", "</div>"];
        return template.join("")
    };
    DEFAULT_ITEM_TEMPLATE_GENERATORS.dxToolbar = function() {
        var template = DEFAULT_ITEM_TEMPLATE_GENERATORS.base();
        template = [template.substring(0, template.length - 6), "<!-- ko if: $data.widget -->"];
        $.each(["button", "tabs", "dropDownMenu"], function() {
            var bindingName = DX.inflector.camelize(["dx", "-", this].join("")),
                bindingObj = {};
            bindingObj[bindingName] = "$data.options";
            template.push("<!-- ko if: $data.widget === '", this, "' -->", createElementWithBindAttr("div", bindingObj), "<!-- /ko -->")
        });
        template.push("<!-- /ko -->");
        return template.join("")
    };
    DEFAULT_ITEM_TEMPLATE_GENERATORS.dxGallery = function() {
        var template = DEFAULT_ITEM_TEMPLATE_GENERATORS.base(),
            primitiveBinding = createElementWithBindAttr("div", {html: "String($data)"}),
            imgBinding = createElementWithBindAttr("img", {attr: "{ src: String($data) }"}, false);
        template = template.replace(primitiveBinding, imgBinding);
        return template
    };
    DEFAULT_ITEM_TEMPLATE_GENERATORS.dxTabs = function() {
        var template = DEFAULT_ITEM_TEMPLATE_GENERATORS.base(),
            baseTextBinding = createElementWithBindAttr("div", {text: "text"}),
            iconBinding = createElementWithBindAttr("span", {
                attr: "{ 'class': 'dx-icon-' + $data.icon }",
                css: "{ 'dx-icon': true }"
            }),
            iconSrcBinding = createElementWithBindAttr("img", {
                attr: "{ src: $data.iconSrc }",
                css: "{ 'dx-icon': true }"
            }, false),
            textBinding = "<!-- ko if: $data.icon -->" + iconBinding + "<!-- /ko -->" + "<!-- ko if: !$data.icon && $data.iconSrc -->" + iconSrcBinding + "<!-- /ko -->" + "<span class=\"dx-tab-text\" data-bind=\"text: $data.text\"></span>";
        template = template.replace("<!-- ko if: !$data.html && $data.text -->", "<!-- ko if: !$data.html && ($data.text || $data.icon || $data.iconSrc) -->").replace(baseTextBinding, textBinding);
        return template
    };
    DEFAULT_ITEM_TEMPLATE_GENERATORS.dxActionSheet = function() {
        return createElementWithBindAttr("div", {dxButton: "{ text: $data.text, clickAction: $data.clickAction, type: $data.type, disabled: !!$data.disabled }"})
    };
    DEFAULT_ITEM_TEMPLATE_GENERATORS.dxNavBar = DEFAULT_ITEM_TEMPLATE_GENERATORS.dxTabs;
    $.extend(ui, {
        registerComponentKoBinding: registerComponentKoBinding,
        Template: KoTemplate,
        defaultTemplate: defaultKoTemplate
    })
})(jQuery, DevExpress);

// Module core, file ui.gestureUtils.js

(function($, DX, undefined) {
    var ui = DX.ui,
        support = DX.support,
        TOUCH = support.touch,
        UNLOCK_ACTION_TIMEOUT = 400;
    var gestureUtils = function() {
            var actionLocked = false,
                unlockActionTimer = null,
                gestureStartCallbacks = $.Callbacks();
            var notifyGestureStart = function() {
                    clearTimeout(unlockActionTimer);
                    unlockActionTimer = null;
                    actionLocked = true;
                    gestureStartCallbacks.fire()
                };
            var notifyGestureEnd = function() {
                    if (unlockActionTimer)
                        return;
                    unlockActionTimer = setTimeout(function() {
                        actionLocked = false;
                        unlockActionTimer = null
                    }, UNLOCK_ACTION_TIMEOUT)
                };
            var hasRecentGesture = function() {
                    return actionLocked
                };
            var android4nativeBrowser = /^4\.0/.test(DX.devices.androidVersion()) && navigator.userAgent.indexOf("Chrome") === -1;
            var preventHangingCursor = function() {
                    if (TOUCH)
                        if (android4nativeBrowser)
                            androidInputBlur();
                        else if (document.activeElement)
                            document.activeElement.blur()
                };
            var androidInputBlur = function() {
                    var $specInput = $("<input>").addClass("dx-hidden-input").appendTo("body");
                    setTimeout(function() {
                        $specInput.focus();
                        setTimeout(function() {
                            $specInput.hide();
                            $specInput.remove()
                        }, 100)
                    }, 100)
                };
            var preventNativeElastic = function(e) {
                    if (TOUCH)
                        e.preventDefault()
                };
            var needSkipEvent = function(e) {
                    return $(e.target).is("input, textarea")
                };
            return {
                    gestureStartCallbacks: gestureStartCallbacks,
                    preventHangingCursor: preventHangingCursor,
                    preventNativeElastic: preventNativeElastic,
                    needSkipEvent: needSkipEvent,
                    notifyStart: notifyGestureStart,
                    notifyEnd: notifyGestureEnd,
                    hasRecent: hasRecentGesture
                }
        }();
    gestureUtils.__internals = {
        UNLOCK_ACTION_TIMEOUT: UNLOCK_ACTION_TIMEOUT,
        setUnlockTimeout: function(timeout) {
            UNLOCK_ACTION_TIMEOUT = timeout
        }
    };
    ui.gestureUtils = gestureUtils
})(jQuery, DevExpress);

// Module core, file ui.dataHelper.js

(function($, DX, undefined) {
    var data = DX.data;
    var DATA_SOURCE_OPTIONS_METHOD = "_dataSourceOptions",
        DATA_SOURCE_CHANGED_METHOD = "_handleDataSourceChanged",
        DATA_SOURCE_LOAD_ERROR_METHOD = "_handleDataSourceLoadError";
    DX.ui.DataHelperMixin = {
        ctor: function() {
            this.disposing.add(function() {
                this._disposeDataSource()
            })
        },
        _initDataSource: function() {
            var self = this,
                dataSourceOptions = self.option("dataSource"),
                dataSource,
                widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {},
                dataSourceType = self._dataSourceType ? self._dataSourceType() : data.SimpleDataSource;
            self._disposeDataSource();
            if (!dataSourceOptions)
                return;
            if ($.isArray(dataSourceOptions))
                dataSource = new data.ArrayStore(dataSourceOptions).toDataSource(widgetDataSourceOptions, dataSourceType);
            else if ($.isPlainObject(dataSourceOptions))
                if ('load' in dataSourceOptions)
                    dataSource = data.createDataSource(dataSourceOptions);
                else {
                    if (!dataSourceOptions.store)
                        throw Error("Please specify 'load' function for the datasource");
                    dataSource = new dataSourceType($.extend(true, {}, widgetDataSourceOptions, dataSourceOptions))
                }
            else if (dataSourceOptions instanceof data.DataSource) {
                self._sharedDataSource = true;
                dataSource = dataSourceOptions
            }
            else if (dataSourceOptions instanceof data.Store)
                dataSource = dataSourceOptions.toDataSource(widgetDataSourceOptions, dataSourceType);
            else
                throw Error("Invalid dataSource option");
            self._dataSource = dataSource;
            dataSource.changed.add(self._dataSourceChangedHandler = function() {
                self[DATA_SOURCE_CHANGED_METHOD](dataSource.items())
            });
            if (DATA_SOURCE_LOAD_ERROR_METHOD in self)
                dataSource.loadError.add(self._dataSourceLoadErrorHandler = $.proxy(self[DATA_SOURCE_LOAD_ERROR_METHOD], self))
        },
        _loadDataSource: function() {
            var ds = this._dataSource;
            if (!ds)
                return;
            if (ds.isLoaded())
                this._dataSourceChangedHandler();
            else
                ds.load()
        },
        _disposeDataSource: function() {
            if (!this._dataSource)
                return;
            if (!this._sharedDataSource)
                this._dataSource.dispose();
            else {
                delete this._sharedDataSource;
                this._dataSource.changed.remove(this._dataSourceChangedHandler);
                this._dataSource.loadError.remove(this._dataSourceLoadErrorHandler)
            }
            delete this._dataSource;
            delete this._dataSourceChangedHandler;
            delete this._dataSourceLoadErrorHandler
        }
    }
})(jQuery, DevExpress);

// Module core, file ui.eventHelper.js

(function($, DX, undefined) {
    var ui = DX.ui,
        gestureUtils = ui.gestureUtils;
    var EventHelper = DX.Class.inherit({
            EVENT_SOURCES_REGEX: {
                mouse: /^mouse/i,
                touch: /^touch/i,
                keyboard: /^key/i
            },
            EVENTS: {
                click: "click",
                start: "touchstart mousedown",
                move: "touchmove mousemove",
                end: "touchend mouseup",
                cancel: "touchcancel",
                wheel: "mousewheel"
            },
            ctor: function(namespace) {
                this._namespace = namespace
            },
            eventSource: function(e) {
                var result = "other";
                $.each(this.EVENT_SOURCES_REGEX, function(key) {
                    if (this.test(e.type)) {
                        result = key;
                        return false
                    }
                });
                return result
            },
            isMouseEvent: function(e) {
                return this.eventSource(e) === "mouse"
            },
            isTouchEvent: function(e) {
                return this.eventSource(e) === "touch"
            },
            isKeyboardEvent: function() {
                return this.eventSource(e) === "keyboard"
            },
            eventName: function(type) {
                var self = this;
                var events = this.EVENTS[type] || type;
                events = events.split(/\W+/g);
                $.each(events, function(index, eventName) {
                    events[index] = eventName + "." + self._namespace
                });
                return events.join(" ")
            },
            eventX: function(e) {
                if (this.isMouseEvent(e))
                    return e.pageX;
                if (this.isTouchEvent(e))
                    return e.originalEvent.touches[0].pageX
            },
            eventY: function(e) {
                if (this.isMouseEvent(e))
                    return e.pageY;
                if (this.isTouchEvent(e))
                    return e.originalEvent.touches[0].pageY
            },
            eventData: function(e) {
                if (this.isMouseEvent(e))
                    return {
                            x: e.pageX,
                            y: e.pageY,
                            time: e.timeStamp
                        };
                if (this.isTouchEvent(e)) {
                    var touch = (e.changedTouches || e.originalEvent.changedTouches)[0];
                    return {
                            x: touch.pageX,
                            y: touch.pageY,
                            time: e.timeStamp
                        }
                }
            },
            eventDelta: function(from, to) {
                return {
                        x: to.x - from.x,
                        y: to.y - from.y,
                        time: to.time - from.time || 1
                    }
            },
            hasTouches: function(e) {
                if (this.isMouseEvent(e))
                    return 0;
                if (this.isTouchEvent(e))
                    return e.originalEvent.touches.length
            },
            needSkipEvent: function(e) {
                if (this.isMouseEvent(e))
                    return gestureUtils.needSkipEvent(e) || e.which !== 1;
                if (this.isTouchEvent(e))
                    return (e.changedTouches || e.originalEvent.changedTouches).length !== 1
            }
        });
    var MOUSE_EVENT_LOCK_TIMEOUT = 400,
        mouseLocked = false,
        unlockMouseTimer = null;
    DX.registerActionExecutor("ignoreMouseAfterTouch", {validate: function(e) {
            var event = e.args[0];
            if (event && event.jQueryEvent)
                event = event.jQueryEvent;
            if (!(event instanceof $.Event))
                return;
            if (EventHelper.prototype.isTouchEvent(event)) {
                mouseLocked = true;
                clearTimeout(unlockMouseTimer);
                unlockMouseTimer = setTimeout(function() {
                    mouseLocked = false
                }, MOUSE_EVENT_LOCK_TIMEOUT)
            }
            else if (EventHelper.prototype.isMouseEvent(event))
                if (mouseLocked)
                    e.canceled = true
        }});
    DX.ui.EventHelper = EventHelper
})(jQuery, DevExpress);

// Module core, file ui.component.js

(function($, DX, undefined) {
    var COMPONENT_NAMES_DATA_KEY = "dxComponents",
        HAS_KO = !!window.ko,
        CREATED_WITH_KO_DATA_KEY = "dxKoCreation",
        ui = DX.ui,
        dataUtils = DX.data.utils,
        DISABLED_STATE_CLASS = "dx-state-disabled";
    var Component = DX.Class.inherit({
            NAME: null,
            _defaultOptions: function() {
                return {disabled: false}
            },
            _createdWithKo: function() {
                return !!this._element.data(CREATED_WITH_KO_DATA_KEY)
            },
            ctor: function(element, options) {
                if (!this.NAME)
                    throw Error("NAME is not specified");
                element = $(element);
                element.data(this.NAME, this);
                if (!element.data(COMPONENT_NAMES_DATA_KEY))
                    element.data(COMPONENT_NAMES_DATA_KEY, []);
                element.data(COMPONENT_NAMES_DATA_KEY).push(this.NAME);
                this._element = element;
                this._options = {};
                this._updateLockCount = 0;
                this._requireRefresh = false;
                this._eventHelper = new ui.EventHelper(this.NAME);
                this.optionChanged = $.Callbacks();
                this.disposing = $.Callbacks();
                this.beginUpdate();
                try {
                    var device = DX.devices.current(),
                        optionsByDevice = ui.optionsByDevice(device, this.NAME) || {},
                        defaultOptions = $.extend(this._defaultOptions(), optionsByDevice);
                    this.option(defaultOptions);
                    this._initOptions(options || {})
                }
                finally {
                    this.endUpdate()
                }
            },
            _initOptions: function(options) {
                this.option(options)
            },
            _optionValuesEqual: function(name, oldValue, newValue) {
                oldValue = dataUtils.toComparable(oldValue, true);
                newValue = dataUtils.toComparable(newValue, true);
                if (oldValue === null || typeof oldValue !== "object")
                    return oldValue === newValue;
                return false
            },
            _init: $.noop,
            _render: function() {
                this._renderDisabledState()
            },
            _clean: $.noop,
            _invalidate: function() {
                if (!this._updateLockCount)
                    throw Error("Invalidate called outside update transaction");
                this._requireRefresh = true
            },
            _refresh: function() {
                this._clean();
                this._render()
            },
            _dispose: function() {
                this._clean();
                this.optionChanged.empty();
                this.disposing.fireWith(this).empty()
            },
            _renderDisabledState: function(state) {
                this.rootElement().toggleClass(DISABLED_STATE_CLASS, this.option("disabled"))
            },
            _createAction: function(actionSource, config) {
                var self = this;
                config = $.extend({}, config);
                var element = config.element || self._element,
                    model = self._modelByElement(element);
                config.context = model || self;
                config.component = self;
                var action = new DX.Action(actionSource, config);
                return function(e) {
                        if (!$.isPlainObject(e))
                            e = {actionValue: e};
                        return action.execute.call(action, $.extend(e, {
                                component: self,
                                element: element,
                                model: model
                            }))
                    }
            },
            _createActionByOption: function(optionName, config) {
                if (typeof optionName !== "string")
                    throw Error("Option name type is unexpected");
                return this._createAction(this.option(optionName), config)
            },
            _modelByElement: function(element) {
                if (HAS_KO && element.length)
                    return ko.dataFor(element.get(0))
            },
            _optionChanged: function(name, value, prevValue) {
                if (name === "disabled")
                    this._renderDisabledState(value);
                else
                    this._invalidate()
            },
            rootElement: function() {
                return this._element
            },
            instance: function() {
                return this
            },
            beginUpdate: function() {
                this._updateLockCount++
            },
            endUpdate: function() {
                this._updateLockCount--;
                if (!this._updateLockCount)
                    if (!this._initializing && !this._initialized) {
                        this._initializing = true;
                        try {
                            this._init()
                        }
                        finally {
                            this._initializing = false;
                            this._initialized = true
                        }
                        this._render()
                    }
                    else if (this._requireRefresh) {
                        this._refresh();
                        this._requireRefresh = false
                    }
            },
            option: function(options) {
                var self = this,
                    name = options,
                    value = arguments[1];
                if (arguments.length < 2 && $.type(name) !== "object")
                    return dataUtils.compileGetter(name)(self._options, {functionsAsIs: true});
                if (typeof name === "string") {
                    options = {};
                    options[name] = value
                }
                self.beginUpdate();
                try {
                    $.each(options, function(name, value) {
                        var prevValue = dataUtils.compileGetter(name)(self._options, {functionsAsIs: true}),
                            topLevelName;
                        if (self._optionValuesEqual(name, prevValue, value))
                            return;
                        dataUtils.compileSetter(name)(self._options, value, {
                            functionsAsIs: true,
                            merge: true
                        });
                        topLevelName = name.split(/[.\[]/)[0];
                        if (self._initialized) {
                            self.optionChanged.fireWith(self, [topLevelName, value, prevValue]);
                            self._optionChanged(topLevelName, value, prevValue)
                        }
                    })
                }
                finally {
                    self.endUpdate()
                }
            }
        });
    var registerComponent = function(name, componentClass) {
            ui[name] = componentClass;
            componentClass.prototype.NAME = name;
            $.fn[name] = function(options) {
                var isMemberInvoke = typeof options === "string",
                    result = this;
                if (isMemberInvoke) {
                    var memberName = options,
                        memberArgs = $.makeArray(arguments).slice(1);
                    this.each(function() {
                        var instance = $(this).data(name);
                        if (!instance)
                            throw Error("Component " + name + " has not been initialized on this element");
                        var member = instance[memberName],
                            memberValue = member.apply(instance, memberArgs);
                        if (memberValue !== undefined) {
                            result = memberValue;
                            return false
                        }
                    })
                }
                else
                    this.each(function() {
                        var instance = $(this).data(name);
                        if (instance)
                            instance.option(options);
                        else
                            new componentClass(this, options)
                    });
                return result
            };
            if (HAS_KO)
                ui.registerComponentKoBinding(name)
        };
    var getComponents = function(element) {
            element = $(element);
            var names = element.data(COMPONENT_NAMES_DATA_KEY);
            if (!names)
                return [];
            return $.map(names, function(name) {
                    return element.data(name)
                })
        };
    function cleanComponentsAndKoData(element, andSelf) {
        element.each(function() {
            var all = this.getElementsByTagName ? this.getElementsByTagName("*") : [];
            if (andSelf)
                all = jQuery.merge([this], all);
            for (var i = 0, item; (item = all[i]) != null; i++) {
                $.each(getComponents(item), function() {
                    this._dispose()
                });
                if (HAS_KO)
                    ko.cleanNode(item)
            }
        })
    }
    var originalEmpty = $.fn.empty;
    $.fn.empty = function() {
        cleanComponentsAndKoData(this, false);
        return originalEmpty.apply(this, arguments)
    };
    var originalRemove = $.fn.remove;
    $.fn.remove = function(selector, keepData) {
        if (!keepData) {
            var subject = this;
            if (selector)
                subject = subject.filter(selector);
            cleanComponentsAndKoData(subject, true)
        }
        return originalRemove.call(this, selector, keepData)
    };
    var originalHtml = $.fn.html;
    $.fn.html = function(value) {
        if (typeof value === "string")
            cleanComponentsAndKoData(this, false);
        return originalHtml.apply(this, arguments)
    };
    $.extend(ui, {
        registerComponent: registerComponent,
        Component: Component
    })
})(jQuery, DevExpress);

// Module core, file ui.widget.js

(function($, DX, undefined) {
    var ui = DX.ui,
        UI_FEEDBACK = "UIFeedback",
        UI_FEEDBACK_CLASS = "dx-feedback",
        ACTIVE_STATE_CLASS = "dx-state-active",
        DISABLED_STATE_CLASS = "dx-state-disabled",
        INVISIBLE_STATE_CLASS = "dx-state-invisible",
        FEEDBACK_SHOW_TIMEOUT = 30,
        FEEDBACK_HIDE_TIMEOUT = 400;
    var activeElement,
        eventHelper = new ui.EventHelper(UI_FEEDBACK),
        feedbackLocked = false;
    ui.feedback = {
        lock: function() {
            feedbackLocked = true
        },
        unlock: function() {
            window.setTimeout(function() {
                feedbackLocked = false
            }, 0)
        }
    };
    ui.Widget = ui.Component.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    visible: true,
                    activeStateEnabled: true,
                    width: undefined,
                    height: undefined,
                    clickAction: null
                })
        },
        _init: function() {
            this.callBase();
            this._feedbackShowTimeout = FEEDBACK_SHOW_TIMEOUT
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass("dx-widget");
            this._toggleVisibility(this.option("visible"));
            this._refreshFeedback();
            this._renderDimensions();
            this._renderClick()
        },
        _dispose: function() {
            this._clearTimers();
            if (activeElement && activeElement.closest(this.rootElement()).length)
                activeElement = null;
            this.callBase()
        },
        _clean: function() {
            this.callBase();
            this.rootElement().empty()
        },
        _clearTimers: function() {
            clearTimeout(this._feedbackHideTimer);
            clearTimeout(this._feedbackShowTimer)
        },
        _toggleVisibility: function(visible) {
            this.rootElement().toggleClass(INVISIBLE_STATE_CLASS, !visible)
        },
        _renderDimensions: function() {
            var width = this.option("width"),
                height = this.option("height");
            if (width)
                this.rootElement().width(width);
            if (height)
                this.rootElement().height(height)
        },
        _refreshFeedback: function() {
            if (this._feedbackDisabled()) {
                this._feedbackOff();
                this._element.removeClass(UI_FEEDBACK_CLASS)
            }
            else
                this._element.addClass(UI_FEEDBACK_CLASS)
        },
        _renderClick: function() {
            var eventName = this._eventHelper.eventName("click");
            this.rootElement().off(eventName).on(eventName, this._createActionByOption("clickAction"))
        },
        _feedbackDisabled: function() {
            return !this.option("activeStateEnabled") || this.option("disabled")
        },
        _feedbackOn: function(element, immediate) {
            if (this._feedbackDisabled() || feedbackLocked)
                return;
            this._clearTimers();
            if (immediate)
                this._feedbackShow(element);
            else
                this._feedbackShowTimer = window.setTimeout($.proxy(this._feedbackShow, this, element), this._feedbackShowTimeout);
            this._saveActiveElement()
        },
        _feedbackShow: function(element) {
            var activeStateElement = this.rootElement();
            if (this._activeStateUnit)
                activeStateElement = $(element).closest(this._activeStateUnit);
            if (!activeStateElement.hasClass(DISABLED_STATE_CLASS))
                activeStateElement.addClass(ACTIVE_STATE_CLASS)
        },
        _saveActiveElement: function() {
            activeElement = this.rootElement()
        },
        _feedbackOff: function(isGestureStart, immediate) {
            this._clearTimers();
            if (immediate)
                this._feedbackHide();
            else
                this._feedbackHideTimer = window.setTimeout($.proxy(this._feedbackHide, this), FEEDBACK_HIDE_TIMEOUT)
        },
        _feedbackHide: function() {
            var activeStateElement = this.rootElement();
            if (this._activeStateUnit)
                activeStateElement = activeStateElement.find(this._activeStateUnit);
            activeStateElement.removeClass(ACTIVE_STATE_CLASS);
            this._clearActiveElement()
        },
        _clearActiveElement: function() {
            var rootDomElement = this.rootElement().get(0),
                activeDomElement = activeElement && activeElement.get(0);
            if (activeDomElement && (activeDomElement === rootDomElement || $.contains(rootDomElement, activeDomElement)))
                activeElement = null
        },
        _optionChanged: function(name, value) {
            switch (name) {
                case"disabled":
                    this.callBase.apply(this, arguments);
                case"activeStateEnabled":
                    this._refreshFeedback();
                    break;
                case"visible":
                    this._toggleVisibility(value);
                    break;
                case"width":
                case"height":
                    this._renderDimensions();
                    break;
                case"clickAction":
                    this._renderClick();
                    break;
                default:
                    this.callBase.apply(this, arguments)
            }
        }
    });
    var handleStart = function(e, immediate) {
            if (activeElement)
                getWidget(activeElement)._feedbackOff(false, true);
            var closestFeedbackElement = $(e.target).closest("." + UI_FEEDBACK_CLASS),
                widget;
            if (closestFeedbackElement.length) {
                widget = getWidget(closestFeedbackElement);
                widget._feedbackOn(e.target, immediate);
                if (immediate)
                    widget._feedbackOff()
            }
        };
    var handleEnd = function(isGestureStart) {
            if (!activeElement)
                return;
            getWidget(activeElement)._feedbackOff(isGestureStart)
        };
    var getWidget = function(widgetElement) {
            var result;
            $.each(widgetElement.data("dxComponents"), function(index, componentName) {
                if (ui[componentName].subclassOf(ui.Widget)) {
                    result = widgetElement.data(componentName);
                    return false
                }
            });
            return result
        };
    $(function() {
        var startAction = new DX.Action(handleStart);
        $(document).on(eventHelper.eventName("start"), function(e) {
            startAction.execute(e)
        }).on(eventHelper.eventName("end") + " " + eventHelper.eventName("cancel"), function(e) {
            if (!DX.ui.gestureUtils.hasRecent())
                startAction.execute(e, true);
            handleEnd()
        });
        ui.gestureUtils.gestureStartCallbacks.add(function() {
            handleEnd(true)
        })
    })
})(jQuery, DevExpress);

// Module core, file ui.containerWidget.js

(function($, DX, undefined) {
    var ui = DX.ui,
        ANONYMOUS_TEMPLATE_NAME = "template";
    var getTemplateOptions = function(element) {
            var options = element.data("options");
            if ($.trim(options).charAt(0) !== "{")
                options = "{" + options + "}";
            return new Function("return " + options)().dxTemplate
        };
    var ContainerWidget = ui.Widget.inherit({
            _init: function() {
                this.callBase();
                this._initTemplates()
            },
            _clean: $.noop,
            _initTemplates: function() {
                var templates = {},
                    templateElements = this._element.children("[data-options]");
                if (templateElements.length)
                    templateElements.each(function(index, element) {
                        element = $(element);
                        var templateOptions = getTemplateOptions(element);
                        if (!templateOptions.name)
                            throw Error("Template name was not specified");
                        templates[templateOptions.name] = new ui.Template(element.get(0))
                    });
                else
                    templates[ANONYMOUS_TEMPLATE_NAME] = new ui.Template(this._element.contents());
                this._templates = templates
            },
            _getTemplate: function(templateName) {
                var result = this._aquireTemplate.apply(this, arguments);
                if (!result && this._createdWithKo() && ui.defaultTemplate) {
                    result = ui.defaultTemplate(this.NAME);
                    if (!result)
                        throw Error("Template \"" + templateName + "\" was not found and no default template specified!");
                }
                return result
            },
            _aquireTemplate: function(templateName) {
                if ($.isFunction(templateName))
                    templateName = templateName.apply(this, $.makeArray(arguments).slice(1));
                return this._templates[templateName]
            }
        });
    ui.ContainerWidget = ContainerWidget
})(jQuery, DevExpress);

// Module core, file ui.collectionContainerWidget.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var CollectionContainerWidget = ui.ContainerWidget.inherit({
            _defaultOptions: function() {
                return $.extend(this.callBase(), {
                        items: [],
                        itemTemplate: "item",
                        itemRender: null,
                        itemClickAction: null,
                        itemRenderedAction: null,
                        noDataText: "No data to display",
                        dataSource: null
                    })
            },
            _init: function() {
                this.callBase();
                this._initDataSource();
                this._loadDataSource()
            },
            _optionChanged: function(name, value, prevValue) {
                switch (name) {
                    case"dataSource":
                        this._initDataSource();
                        this._loadDataSource();
                        return;
                    case"noDataText":
                        this._renderEmptyMessage();
                        return;
                    default:
                        this.callBase(name, value, prevValue)
                }
            },
            _clean: function() {
                this._itemContainer().empty()
            },
            _handleDataSourceChanged: function(items) {
                this.option("items", items);
                setTimeout($.proxy(this._renderEmptyMessage, this), 0)
            },
            _itemContainer: function() {
                return this.rootElement()
            },
            _itemClass: DX.abstract,
            _itemSelector: function() {
                return "." + this._itemClass()
            },
            _itemDataKey: DX.abstract,
            _items: function() {
                return this._itemContainer().find(this._itemSelector())
            },
            _render: function() {
                this.callBase();
                this._attachClickEvent();
                this._renderItems();
                if (!this._dataSource)
                    this._renderEmptyMessage()
            },
            _renderEmptyMessage: function() {
                var noDataText = this.option("noDataText"),
                    noDataTextElement = this.rootElement().find(".dx-empty-message");
                if (!noDataText || this._items().length)
                    noDataTextElement.remove();
                else {
                    if (!noDataTextElement.length)
                        noDataTextElement = $("<div />").addClass("dx-empty-message").appendTo(this._itemContainer());
                    noDataTextElement.text(noDataText)
                }
            },
            _attachClickEvent: function() {
                var self = this,
                    itemSelector = self._itemSelector();
                self._element.off("." + self.NAME, itemSelector).on(self._eventHelper.eventName("click"), itemSelector, function(e) {
                    self._handleItemEvent(e, "itemClickAction")
                })
            },
            _renderItems: function() {
                $.each(this.option("items") || [], $.proxy(this._renderItem, this))
            },
            _renderItem: function(index, item, container) {
                container = container || this._itemContainer();
                var itemRenderer = this.option("itemRender"),
                    itemTemplateName = this.option("itemTemplate"),
                    itemTemplate = this._getTemplate(item.template || itemTemplateName, index, item),
                    itemElement;
                var renderArgs = {
                        index: index,
                        item: item,
                        container: container
                    };
                if (itemRenderer)
                    itemElement = this._createItemByRenderer(itemRenderer, renderArgs);
                else if (itemTemplate)
                    itemElement = this._createItemByTemplate(itemTemplate, renderArgs);
                else
                    itemElement = this._createItemByRenderer(this._itemRenderDefault, renderArgs);
                itemElement.addClass(this._itemClass()).data(this._itemDataKey(), item);
                this._createActionByOption("itemRenderedAction", {element: this.rootElement()})({
                    itemElement: itemElement,
                    itemData: item
                });
                return itemElement
            },
            _createItemByRenderer: function(itemRenderer, renderArgs) {
                var itemElement = $("<div />").appendTo(renderArgs.container);
                var rendererResult = itemRenderer.call(this, renderArgs.item, renderArgs.index, itemElement);
                if (rendererResult && itemElement[0] !== rendererResult[0])
                    itemElement.append(rendererResult);
                return itemElement
            },
            _createItemByTemplate: function(itemTemplate, renderArgs) {
                return itemTemplate.render(renderArgs.container, renderArgs.item)
            },
            _itemRenderDefault: function(item, index, itemElement) {
                if ($.isPlainObject(item)) {
                    if (item.visible !== undefined && !item.visible)
                        itemElement.hide();
                    if (item.disabled)
                        itemElement.addClass("dx-state-disabled");
                    if (item.text)
                        itemElement.text(item.text);
                    if (item.html)
                        itemElement.html(item.html)
                }
                else
                    itemElement.html(String(item))
            },
            _handleItemEvent: function(jQueryEvent, handlerOptionName, args) {
                var itemElement = $(jQueryEvent.target).closest(this._itemSelector());
                var action = this._createActionByOption(handlerOptionName, {element: this.rootElement()});
                var actionArgs = $.extend({
                        itemElement: itemElement,
                        itemData: itemElement.data(this._itemDataKey()),
                        jQueryEvent: jQueryEvent
                    }, args);
                return action(actionArgs)
            }
        }).include(ui.DataHelperMixin);
    ui.CollectionContainerWidget = CollectionContainerWidget
})(jQuery, DevExpress);

// Module core, file ui.optionsByDevice.js

(function($, DX, undefined) {
    DX.ui.optionsByDevice = function(device, componentName) {
        if (device.platform === "desktop") {
            switch (componentName) {
                case"dxScrollable":
                case"dxScrollView":
                    return {
                            locked: true,
                            showScrollbar: false
                        };
                case"dxList":
                    return {
                            scrollingEnabled: false,
                            showScrollbar: false,
                            autoPagingEnabled: false,
                            showNextButton: true
                        }
            }
            return {}
        }
        if (device.platform === "ios" && device.phone && componentName === "dxLookup")
            return {fullScreen: true};
        if (device.platform === "win8")
            if (componentName === "dxPopup")
                return {
                        width: "60%",
                        height: "auto"
                    };
        if (device.platform === "win8" || navigator.appName === "Microsoft Internet Explorer")
            if (componentName === "dxScrollable" || componentName === "dxScrollView")
                return {animationStrategy: "transition"};
        if (componentName === "dxDialog") {
            if (device.platform === "ios")
                return {width: 276};
            if (device.platform === "win8")
                return {width: "60%"};
            if (device.platform === "android")
                return {
                        lWidth: "60%",
                        pWidth: "80%"
                    }
        }
    }
})(jQuery, DevExpress);


// Module widgets, file ui.swipeable.js

(function($, DX, undefined) {
    var ui = DX.ui,
        gestureUtils = ui.gestureUtils,
        DX_SWIPEABLE = "dxSwipeable",
        SWIPEABLE_CLASS = "dx-swipeable",
        STAGE_SLEEP = 0,
        STAGE_TOUCHED = 1,
        STAGE_SWIPING = 2,
        TICK_INTERVAL = 300,
        FAST_SWIPE_SPEED_LIMIT = 5,
        activeSwipeable,
        swipeStage = STAGE_SLEEP,
        touchX,
        touchY,
        touchTime,
        maxLeftOffset,
        maxRightOffset,
        moveX,
        tickX,
        tickTime,
        eventHelper = new ui.EventHelper(DX_SWIPEABLE);
    var reset = function() {
            activeSwipeable = null;
            swipeStage = STAGE_SLEEP
        };
    var closestSwipeable = function(e) {
            var current = $(e.target);
            while (current.length) {
                var swipeable = $(current).data(DX_SWIPEABLE);
                if (swipeable)
                    return swipeable;
                current = current.parent()
            }
        };
    var defaultItemWidthFunc = function(element) {
            return $(element).width()
        };
    var handleStart = function(e) {
            if (eventHelper.needSkipEvent(e))
                return;
            if (swipeStage > STAGE_SLEEP)
                return;
            activeSwipeable = closestSwipeable(e);
            if (!activeSwipeable)
                return;
            touchX = eventHelper.eventX(e);
            touchY = eventHelper.eventY(e);
            touchTime = e.timeStamp;
            tickTime = 0;
            swipeStage = STAGE_TOUCHED;
            if (eventHelper.isMouseEvent(e))
                e.preventDefault()
        };
    var handleMove = function(e) {
            if (!activeSwipeable || swipeStage === STAGE_SLEEP)
                return;
            gestureUtils.preventNativeElastic(e);
            if (swipeStage === STAGE_TOUCHED)
                handleFirstMove(e);
            if (swipeStage === STAGE_SWIPING)
                handleNextMoves(e)
        };
    var handleFirstMove = function(e) {
            var deltaX = eventHelper.eventX(e) - touchX;
            if (!deltaX || Math.abs(eventHelper.eventY(e) - touchY) >= Math.abs(deltaX) || eventHelper.needSkipEvent(e)) {
                reset();
                return
            }
            var startArgs = activeSwipeable._fireStart({jQueryEvent: e});
            if (startArgs.cancel) {
                activeSwipeable._fireCancel({jQueryEvent: e});
                reset();
                return
            }
            maxLeftOffset = startArgs.maxLeftOffset;
            maxRightOffset = startArgs.maxRightOffset;
            swipeStage = STAGE_SWIPING;
            gestureUtils.preventHangingCursor();
            gestureUtils.notifyStart()
        };
    var handleNextMoves = function(e) {
            moveX = eventHelper.eventX(e);
            var deltaX = moveX - touchX,
                offset = deltaX / activeSwipeable.itemWidthFunc();
            offset = fitOffset(offset, activeSwipeable.option("elastic"));
            if (e.timeStamp - tickTime > TICK_INTERVAL) {
                tickTime = e.timeStamp;
                tickX = eventHelper.eventX(e)
            }
            activeSwipeable._fireUpdate({
                offset: offset,
                jQueryEvent: e
            })
        };
    var handleEnd = function(e) {
            if (eventHelper.hasTouches(e) || !activeSwipeable)
                return;
            if (swipeStage !== STAGE_SWIPING) {
                reset();
                return
            }
            var offsetRatio = (moveX - touchX) / activeSwipeable.itemWidthFunc(),
                fast = FAST_SWIPE_SPEED_LIMIT * Math.abs(moveX - tickX) >= e.timeStamp - tickTime,
                startOffset = offsetRatio,
                targetOffset = calcTargetOffset(offsetRatio, fast);
            startOffset = fitOffset(startOffset, activeSwipeable.option("elastic"));
            targetOffset = fitOffset(targetOffset, false);
            activeSwipeable._fireEnd({
                offset: startOffset,
                targetOffset: targetOffset,
                jQueryEvent: e
            });
            gestureUtils.notifyEnd();
            reset()
        };
    var fitOffset = function(offset, elastic) {
            if (offset < -maxLeftOffset)
                return elastic ? (-2 * maxLeftOffset + offset) / 3 : -maxLeftOffset;
            if (offset > maxRightOffset)
                return elastic ? (2 * maxRightOffset + offset) / 3 : maxRightOffset;
            return offset
        };
    var calcTargetOffset = function(offsetRatio, fast) {
            var result;
            if (fast) {
                result = Math.ceil(Math.abs(offsetRatio));
                if (offsetRatio < 0)
                    result = -result
            }
            else
                result = Math.round(offsetRatio);
            return result
        };
    ui.registerComponent(DX_SWIPEABLE, ui.Component.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    elastic: true,
                    itemWidthFunc: defaultItemWidthFunc,
                    startAction: null,
                    updateAction: null,
                    endAction: null,
                    cancelAction: null
                })
        },
        _render: function() {
            this.callBase();
            this._createEventActions();
            this.rootElement().addClass(SWIPEABLE_CLASS)
        },
        _createEventActions: function() {
            this._startAction = this._createActionByOption("startAction");
            this._updateAction = this._createActionByOption("updateAction");
            this._endAction = this._createActionByOption("endAction");
            this._cancelAction = this._createActionByOption("cancelAction")
        },
        _dispose: function() {
            this.callBase();
            if (activeSwipeable === this)
                reset()
        },
        itemWidthFunc: function() {
            return this.option("itemWidthFunc")(this._element)
        },
        _fireStart: function(e) {
            e = $.extend(e, {
                element: activeSwipeable._element[0],
                maxLeftOffset: Number.POSITIVE_INFINITY,
                maxRightOffset: Number.POSITIVE_INFINITY,
                cancel: false
            });
            this._startAction(e);
            return e
        },
        _fireCancel: function(e) {
            this._cancelAction($.extend(e, {element: activeSwipeable._element[0]}))
        },
        _fireUpdate: function(e) {
            this._updateAction($.extend(e, {element: activeSwipeable._element[0]}))
        },
        _fireEnd: function(e) {
            this._endAction($.extend(e, {element: activeSwipeable._element[0]}))
        }
    }));
    $(function() {
        var startAction = new DX.Action(handleStart, {context: ui.dxSwipeable}),
            moveAction = new DX.Action(handleMove, {context: ui.dxSwipeable}),
            endAction = new DX.Action(handleEnd, {context: ui.dxSwipeable});
        $(document).on(eventHelper.eventName("start"), $.proxy(startAction.execute, startAction)).on(eventHelper.eventName("move"), $.proxy(moveAction.execute, moveAction)).on(eventHelper.eventName("end") + " " + eventHelper.eventName("cancel"), $.proxy(endAction.execute, endAction))
    });
    ui.dxSwipeable.__internals = {
        state: function() {
            return swipeStage
        },
        STAGE_SLEEP: STAGE_SLEEP,
        STAGE_TOUCHED: STAGE_TOUCHED,
        STAGE_SWIPING: STAGE_SWIPING
    }
})(jQuery, DevExpress);

// Module widgets, file ui.scrollable.js

(function($, DX, undefined) {
    var ui = DX.ui,
        gestureUtils = ui.gestureUtils,
        feedback = ui.feedback,
        fx = DX.fx,
        translator = DX.translator,
        WHEEL = "mousewheel" in $.event.special;
    var math = Math,
        abs = math.abs;
    var DX_SCROLLABLE = "dxScrollable",
        INERTION_EASING = "cubic-bezier(0.190, 1.000, 0.220, 1.000)",
        BOUNCE_EASING = "cubic-bezier(0.250, 0.460, 0.450, 0.940)",
        SCROLLABLE_CONTENT_CSS = "dx-scrollable-content",
        SCROLLABLE_CONTAINER_CSS = "dx-scrollable-container",
        SCROLLABLE_SCROLLBAR_CSS = "dx-scrollable-scrollbar",
        SCROLLABLE_SCROLL_CSS = "dx-scrollable-scroll",
        SCROLL_OPACITY = 0.9,
        SCROLL_FADE_DURATION = 300,
        SCROLL_BLINK_TIMEOUT = 1000,
        SCROLL_MIN_SIZE = 15,
        WHEEL_VELOCITY = 100,
        VELOCITY_CALC_TIMEOUT = 200,
        INERTION_CALC_TIMEOUT = 100,
        INERTION_DURATION = 400,
        INERTION_ANIM_DURATION = 2500,
        INERTION_MIN_VELOCITY = 0.2,
        BOUNCE_ANIM_DURATION = 400,
        BOUNCE_DECELERATION = 0.05,
        ELASTIC_RATE = 0.5,
        MAX_BOUNCE = 70,
        PROCESS_MOVE_INTERVAL = 20;
    var inRange = function(val, min, max) {
            if (val < min)
                return false;
            return val <= max
        };
    var limitRange = function(val, min, max) {
            if (val < min)
                return min;
            if (val > max)
                return max;
            return val
        };
    ui.registerComponent("dxScrollbar", ui.Widget.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {direction: "vertical"})
        },
        _init: function() {
            this.callBase();
            this._blinkTimeout = null;
            this._contentSize = 0;
            this._containerSize = 0
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass(SCROLLABLE_SCROLLBAR_CSS);
            this._scroll = $("<div />").addClass(SCROLLABLE_SCROLL_CSS).css("opacity", 0).appendTo(this._element);
            this._setDirection()
        },
        _setDirection: function() {
            this._directionHelper = this.option("direction") === "horizontal" ? {
                offsetProp: "left",
                sizeMethod: "width"
            } : {
                offsetProp: "top",
                sizeMethod: "height"
            };
            this.rootElement().toggleClass(SCROLLABLE_SCROLLBAR_CSS + "-vertical", this.option("direction") === "vertical");
            this.rootElement().toggleClass(SCROLLABLE_SCROLLBAR_CSS + "-horizontal", this.option("direction") === "horizontal")
        },
        _calcScrollOffset: function(contentOffset) {
            return -contentOffset / this._contentSize * this._containerSize
        },
        _dispose: function() {
            clearTimeout(this._blinkTimeout);
            this.callBase()
        },
        _optionChanged: function(name) {
            if (name === "direction")
                this._setDirection();
            this.callBase.apply(this, arguments)
        },
        update: function(contentSize, containerSize) {
            this._contentSize = contentSize;
            this._containerSize = containerSize;
            this._element[this._directionHelper.sizeMethod](containerSize);
            var scrollSize = contentSize > containerSize ? containerSize * containerSize / contentSize : containerSize;
            this._scroll[this._directionHelper.sizeMethod](math.max(scrollSize, SCROLL_MIN_SIZE))
        },
        animate: function(contentOffset, config) {
            var deferred = $.Deferred();
            config = $.extend({to: {}}, config);
            config.to[this._directionHelper.offsetProp] = this._calcScrollOffset(contentOffset);
            fx.animate(this._scroll, config).done(function() {
                deferred.resolveWith(this)
            });
            return deferred.promise()
        },
        arrange: function(contentOffset) {
            var offset = {};
            offset[this._directionHelper.offsetProp] = this._calcScrollOffset(contentOffset);
            translator.move(this._scroll, offset)
        },
        toggle: function(showOrHide, doAnimate) {
            var deferred = $.Deferred(),
                opacity = SCROLL_OPACITY * !!showOrHide;
            clearTimeout(this._blinkTimeout);
            this.stop();
            if (!doAnimate || !this.option("visible") || this.option("disabled")) {
                this._scroll.css("opacity", opacity);
                return deferred.resolveWith(this).promise()
            }
            fx.animate(this._scroll, {
                to: {opacity: opacity},
                duration: SCROLL_FADE_DURATION
            }).done(function() {
                deferred.resolveWith(this)
            });
            return deferred.promise()
        },
        blink: function(doAnimate) {
            var self = this,
                deferred = $.Deferred(),
                showDeferred,
                hideDeferred = $.Deferred();
            showDeferred = self.toggle(true, doAnimate);
            self._blinkTimeout = setTimeout(function() {
                self.toggle(false, doAnimate).done(function() {
                    hideDeferred.resolve()
                })
            }, SCROLL_BLINK_TIMEOUT);
            $.when(showDeferred, hideDeferred).then(function() {
                deferred.resolveWith(self)
            });
            return deferred.promise()
        },
        scrollElement: function() {
            return this._scroll
        },
        stop: function(jumpToEnd) {
            fx.stop(this._scroll, jumpToEnd)
        }
    }));
    var scrollHandled = false;
    ui.registerComponent(DX_SCROLLABLE, ui.Component.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    animationEnabled: true,
                    inertiaEnabled: true,
                    locked: false,
                    scrollByContent: true,
                    scrollByThumb: false,
                    showScrollbar: true,
                    bounceEnabled: true,
                    direction: "vertical",
                    startAction: null,
                    scrollAction: null,
                    stopAction: null,
                    endAction: null,
                    inertiaAction: null,
                    animationStrategy: "frame"
                })
        },
        _init: function() {
            this.callBase();
            this._allowUpdate = true;
            this._lastEventData = null;
            this._prevEventData = null;
            this._contentOffset = {
                top: 0,
                left: 0
            };
            this._contentSize = {
                width: 0,
                height: 0
            };
            this._containerSize = {
                width: 0,
                height: 0
            };
            this._nowScrolling = false;
            this._movingScrollbar = undefined;
            this._lastMoveEvent = undefined
        },
        _render: function() {
            this.callBase();
            var $horizontalScrollbar = $("<div />").dxScrollbar({direction: "horizontal"}),
                $verticalScrollbar = $("<div />").dxScrollbar({direction: "vertical"});
            this._scrollbars = {
                x: $horizontalScrollbar.data("dxScrollbar"),
                y: $verticalScrollbar.data("dxScrollbar")
            };
            this._content = $("<div />").addClass(SCROLLABLE_CONTENT_CSS);
            this._container = this._content.wrap($("<div />").addClass(SCROLLABLE_CONTAINER_CSS)).parent().append($horizontalScrollbar).append($verticalScrollbar);
            this._directionChanged();
            this._scrollbarsEnabling();
            this._scrollByChanged();
            var rootElement = this.rootElement();
            rootElement.addClass("dx-scrollable");
            this._content.append(rootElement.contents());
            this._container.appendTo(rootElement);
            this._afterRender()
        },
        _refresh: function() {
            this._detachStartHandlers();
            this._attachStartHandlers()
        },
        _directionChanged: function() {
            if ($.inArray(this.option("direction"), ["vertical", "horizontal", "both"]) < 0)
                this.option("direction", "vertical");
            this._content.toggleClass(SCROLLABLE_CONTENT_CSS + "-horizontal", this.option("direction") !== "vertical")
        },
        _scrollbarsEnabling: function() {
            this._scrollbars.x.option("visible", this.option("showScrollbar") && !this.option("locked") && this.option("direction") !== "vertical");
            this._scrollbars.y.option("visible", this.option("showScrollbar") && !this.option("locked") && this.option("direction") !== "horizontal")
        },
        _scrollByChanged: function() {
            var $scrollElements = $([this._scrollbars.x.scrollElement().get(0), this._scrollbars.y.scrollElement().get(0)]);
            this._startTarget = this.option("scrollByContent") ? this._container : $scrollElements;
            $scrollElements.css("cursor", this.option("scrollByThumb") ? "pointer" : "auto")
        },
        _afterRender: function() {
            this._afterRenderHandler()
        },
        _afterRenderHandler: function() {
            this._createEventActions();
            this._updateIfResized(false);
            this._attachStartHandlers();
            this._toggleWindowResizeHandler(true);
            this._scrollbarInitAction()
        },
        _scrollbarInitAction: function() {
            if (this.option("scrollByThumb")) {
                this._scrollbars.x.toggle(true);
                this._scrollbars.y.toggle(true)
            }
            else {
                this._scrollbars.x.blink(this.option("animationEnabled"));
                this._scrollbars.y.blink(this.option("animationEnabled"))
            }
        },
        _createEventActions: function() {
            this._startAction = this._createActionByOption("startAction");
            this._inertiaAction = this._createActionByOption("inertiaAction");
            this._scrollAction = this._createActionByOption("scrollAction");
            this._stopAction = this._createActionByOption("stopAction");
            this._endAction = this._createActionByOption("endAction")
        },
        _toggleWindowResizeHandler: function(onOff) {
            var callback = $.proxy(this.update, this);
            DX.utils.windowResizeCallbacks[onOff ? "add" : "remove"](callback)
        },
        _attachStartHandlers: function() {
            var eventHelper = this._eventHelper,
                actionStart = new DX.Action(this._handleStart, {context: this}),
                actionWheel = new DX.Action(this._handleWheel, {context: this}),
                actionNativeScroll = new DX.Action(this._handleNativeScroll, {context: this});
            this._startTarget.on(eventHelper.eventName("start"), $.proxy(actionStart.execute, actionStart));
            this._container.on(eventHelper.eventName("scroll"), $.proxy(actionNativeScroll.execute, actionNativeScroll));
            if (WHEEL)
                this._container.on(eventHelper.eventName("wheel"), $.proxy(actionWheel.execute, actionWheel))
        },
        _detachStartHandlers: function() {
            var eventHelper = this._eventHelper;
            this._startTarget.off(eventHelper.eventName("start"));
            this._container.on(eventHelper.eventName("scroll"));
            if (WHEEL)
                this._container.off(eventHelper.eventName("wheel"))
        },
        _handleStart: function(e) {
            var eventHelper = this._eventHelper;
            this._currentEvent = e;
            if (this.option("locked") || eventHelper.needSkipEvent(e))
                return;
            if (eventHelper.isMouseEvent(e))
                e.preventDefault();
            this._fixDirection(e.target);
            this._lastEventData = this._prevEventData = eventHelper.eventData(e);
            this._stopScrolling();
            this._updateIfResized(true);
            this._attachScrollHandlers()
        },
        _updateIfResized: function(doAnimate) {
            if (!this._allowUpdate || this.option("locked"))
                return;
            if (this._resized())
                this.update(doAnimate)
        },
        _resized: function() {
            return this._sizeChanged("width") || this._sizeChanged("height")
        },
        _sizeChanged: function(prop) {
            var contentSize = this._content[prop](),
                containerSize = this._container[prop]();
            if (!contentSize)
                return false;
            return contentSize !== this._contentSize[prop] || containerSize !== this._containerSize[prop]
        },
        _fixDirection: function(target) {
            var scrollbar = $(target).parent("." + SCROLLABLE_SCROLLBAR_CSS).data("dxScrollbar");
            this._movingScrollbar = this.option("scrollByThumb") && scrollbar ? scrollbar.option("direction") : undefined
        },
        _stopScrolling: function(jumpToEnd) {
            if (fx.animating(this._content)) {
                fx.stop(this._content, jumpToEnd);
                if (!jumpToEnd)
                    this._contentOffset = translator.locate(this._content);
                this._fireScrollStop()
            }
            this._scrollbars.x.stop(jumpToEnd);
            this._scrollbars.y.stop(jumpToEnd)
        },
        _attachScrollHandlers: function() {
            var eventHelper = this._eventHelper,
                actionFirstMove = new DX.Action(this._handleFirstMove, {context: this}),
                actionEnd = new DX.Action(this._handleEnd, {context: this});
            $(document).on(eventHelper.eventName("move") + ".dxFirstmove", $.proxy(actionFirstMove.execute, actionFirstMove)).on(eventHelper.eventName("end"), $.proxy(actionEnd.execute, actionEnd));
            if (eventHelper.eventName("cancel"))
                $(document).on(eventHelper.eventName("cancel"), $.proxy(actionEnd.execute, actionEnd))
        },
        _detachScrollHandlers: function() {
            var eventHelper = this._eventHelper;
            $(document).off(eventHelper.eventName("move")).off(eventHelper.eventName("end"));
            if (eventHelper.eventName("cancel"))
                $(document).off(eventHelper.eventName("cancel"))
        },
        _handleFirstMove: function(e) {
            if (scrollHandled)
                return;
            scrollHandled = true;
            this._currentEvent = e;
            var eventHelper = this._eventHelper,
                eventData = eventHelper.eventData(e),
                delta = eventHelper.eventDelta(this._lastEventData, eventData);
            this._allowUpdate = false;
            if (abs(delta.x) + abs(delta.y) === 0)
                return;
            $(document).off(eventHelper.eventName("move") + ".dxFirstmove");
            if (this._skipEventByDirection(delta))
                return;
            delta = this._ignoreLockedDirection(delta);
            this._lastMoveEvent = undefined;
            this._processMove();
            this._nowScrolling = true;
            this._startGesture(e);
            this._prevEventData = this._lastEventData;
            this._lastEventData = eventData;
            this._fireScrollStart();
            this._scrollbars.x.toggle(true);
            this._scrollbars.y.toggle(true);
            this._moveContent(delta);
            var actionMove = new DX.Action(this._handleMove, {context: this});
            $(document).on(eventHelper.eventName("move"), $.proxy(actionMove.execute, actionMove))
        },
        _skipEventByDirection: function(delta) {
            if (this._movingScrollbar)
                return false;
            if (this.option("direction") === "vertical" && abs(delta.x) >= abs(delta.y))
                return true;
            if (this.option("direction") === "horizontal" && abs(delta.x) <= abs(delta.y))
                return true;
            return false
        },
        _ignoreLockedDirection: function(delta) {
            if (this.option("direction") === "vertical" || this._movingScrollbar === "vertical")
                delta.x = 0;
            if (this.option("direction") === "horizontal" || this._movingScrollbar === "horizontal")
                delta.y = 0;
            return delta
        },
        _startGesture: function(e) {
            gestureUtils.preventHangingCursor();
            gestureUtils.preventNativeElastic(e);
            gestureUtils.notifyStart();
            feedback.lock()
        },
        _processMove: function(stop) {
            if (this._lastMoveEvent)
                this._handleLastMoveEvent();
            if (stop)
                clearTimeout(this._processMoveTimer);
            else
                this._processMoveTimer = setTimeout($.proxy(this._processMove, this), PROCESS_MOVE_INTERVAL)
        },
        _handleMove: function(e) {
            this._lastMoveEvent = e;
            gestureUtils.preventNativeElastic(e)
        },
        _handleLastMoveEvent: function() {
            var eventHelper = this._eventHelper,
                eventData = eventHelper.eventData(this._lastMoveEvent),
                delta = eventHelper.eventDelta(this._lastEventData, eventData);
            this._currentEvent = this._lastMoveEvent;
            this._lastMoveEvent = undefined;
            delta = this._ignoreLockedDirection(delta);
            this._moveContent(delta);
            var timeElapsed = eventHelper.eventDelta(this._prevEventData, this._lastEventData).time;
            if (timeElapsed > VELOCITY_CALC_TIMEOUT)
                this._prevEventData = this._lastEventData;
            this._lastEventData = eventData
        },
        _handleEnd: function(e) {
            this._processMove(true);
            this._currentEvent = e;
            this._detachScrollHandlers();
            scrollHandled = false;
            if (!this._nowScrolling) {
                this._bounceContent();
                return
            }
            this._nowScrolling = false;
            this._scrollContent(this._inertionOffset(e), true)
        },
        _inertionOffset: function(e) {
            var eventHelper = this._eventHelper,
                delta = eventHelper.eventDelta(this._prevEventData, this._lastEventData),
                endEventData = eventHelper.eventData(e),
                timeElapsed = eventHelper.eventDelta(this._lastEventData, endEventData).time,
                newOffset = $.extend({}, this._contentOffset);
            if (this.option("inertiaEnabled") && timeElapsed < INERTION_CALC_TIMEOUT) {
                delta = this._ignoreLockedDirection(delta);
                newOffset.left += this._inertionDistance(delta.x, delta.time);
                newOffset.top += this._inertionDistance(delta.y, delta.time)
            }
            return newOffset
        },
        _inertionDistance: function(deltaDistance, deltaTime) {
            var reverseModifier = this._movingScrollbar ? -1 : 1,
                deltaDistance = deltaDistance * reverseModifier,
                velocity = deltaDistance / deltaTime || 0,
                doInertion = abs(velocity) > INERTION_MIN_VELOCITY,
                distance = velocity * (doInertion ? INERTION_DURATION : 0);
            return distance
        },
        _handleWheel: function(e, delta) {
            this._currentEvent = e;
            if (this.option("locked") || this.option("direction") === "horizontal")
                return;
            if (WHEEL) {
                this._allowUpdate = false;
                this._stopScrolling();
                this._updateIfResized(true);
                this._scrollbars.x.toggle(true);
                this._scrollbars.y.toggle(true);
                var newOffset = $.extend({}, this._contentOffset);
                newOffset.top = this._contentOffset.top + delta * WHEEL_VELOCITY;
                this._scrollContent(newOffset, false)
            }
            e.preventDefault()
        },
        _handleNativeScroll: function(e) {
            var scrollOffset = {
                    top: this._container.get(0).scrollTop,
                    left: this._container.get(0).scrollLeft
                },
                min;
            this._refreshSizes();
            min = this._minLimit();
            this._scrollAction({
                jQueryEvent: e,
                scrollOffset: scrollOffset,
                reachedLeft: scrollOffset.left === 0,
                reachedRight: scrollOffset.left === -min.left,
                reachedTop: scrollOffset.top === 0,
                reachedBottom: scrollOffset.top === -min.top
            })
        },
        _refreshSizes: function() {
            this._contentSize = {
                width: this._content.width(),
                height: this._content.height()
            };
            this._containerSize = {
                width: this._container.width(),
                height: this._container.height()
            }
        },
        _moveContent: function(delta) {
            if (this._movingScrollbar)
                delta = {
                    x: -delta.x * this._content.width() / this._container.width(),
                    y: -delta.y * this._content.height() / this._container.height()
                };
            else
                delta = {
                    x: delta.x * (this._inBounds() || ELASTIC_RATE),
                    y: delta.y * (this._inBounds() || ELASTIC_RATE)
                };
            this._contentOffset.left += delta.x;
            this._contentOffset.top += delta.y;
            if (!this.option("bounceEnabled"))
                this._contentOffset = this._limitedOffset();
            this._arrangeContent()
        },
        _scrollContent: function(newOffset, doAnimate, isBounce, updating) {
            doAnimate = this.option("animationEnabled") && doAnimate && (this._inBounds() || isBounce);
            newOffset = this._calcOffset(newOffset);
            if (this._contentOffset.left === newOffset.left && this._contentOffset.top === newOffset.top)
                return this._scrollComplete(updating);
            this._contentOffset = newOffset;
            if (!this.option("bounceEnabled"))
                this._contentOffset = this._limitedOffset();
            if (!isBounce)
                this._fireInertia();
            if (doAnimate)
                return this._animateContent(!this._inBounds() || isBounce, updating);
            this._arrangeContent(updating);
            return this._scrollComplete(updating)
        },
        _calcOffset: function(newOffset) {
            var min = this._minLimit(),
                max = this._maxLimit(),
                offset = this._contentOffset,
                distance = newOffset - offset;
            return {
                    left: this._offsetByDirection(offset.left, newOffset.left, min.left, max.left),
                    top: this._offsetByDirection(offset.top, newOffset.top, min.top, max.top)
                }
        },
        _arrangeContent: function(updating) {
            translator.move(this._content, this._contentOffset);
            this._arrangeScrollbars(this._contentOffset);
            this._fireScroll(updating)
        },
        _animateContent: function(isBounce, updating) {
            var self = this,
                deferred = $.Deferred(),
                contentAnimDeferred = $.Deferred(),
                scrollbarsAnimDeferred,
                config = {
                    type: "slide",
                    strategy: self.option("animationStrategy"),
                    duration: isBounce ? BOUNCE_ANIM_DURATION : INERTION_ANIM_DURATION,
                    easing: isBounce ? BOUNCE_EASING : INERTION_EASING
                };
            fx.animate(self._content, $.extend({
                to: $.extend({}, self._contentOffset),
                complete: function() {
                    self._animationComplete(updating).done(function() {
                        contentAnimDeferred.resolve()
                    })
                }
            }, config));
            scrollbarsAnimDeferred = self._animateScrollbars(self._contentOffset, config);
            $.when(contentAnimDeferred, scrollbarsAnimDeferred).then(function() {
                deferred.resolveWith(self)
            });
            return deferred.promise()
        },
        _animationComplete: function(updating) {
            this._fireScroll(updating);
            return this._scrollComplete(updating)
        },
        _scrollComplete: function(updating) {
            this._fireScrollStop(updating);
            if (this._inBounds())
                this._fireScrollEnd(updating);
            return this._bounceContent(updating)
        },
        _bounceContent: function(updating) {
            if (this._inBounds()) {
                if (!this.option("scrollByThumb")) {
                    this._scrollbars.x.toggle(false, this.option("animationEnabled"));
                    this._scrollbars.y.toggle(false, this.option("animationEnabled"))
                }
                feedback.unlock();
                gestureUtils.notifyEnd();
                this._allowUpdate = true;
                return $.Deferred().resolveWith(this).promise()
            }
            return this._scrollContent(this._limitedOffset(), true, true, updating)
        },
        _arrangeScrollbars: function(contentOffset) {
            this._scrollbars.x.arrange(contentOffset.left);
            this._scrollbars.y.arrange(contentOffset.top)
        },
        _animateScrollbars: function(contentOffset, config) {
            return $.when(this._scrollbars.x.animate(contentOffset.left, config), this._scrollbars.y.animate(contentOffset.top, config))
        },
        _inBounds: function() {
            return (this.option("direction") === "vertical" || inRange(this._contentOffset.left, this._minLimit().left, this._maxLimit().left)) && (this.option("direction") === "horizontal" || inRange(this._contentOffset.top, this._minLimit().top, this._maxLimit().top))
        },
        _offsetByDirection: function(offset, newOffset, min, max) {
            var distance = newOffset - offset;
            if (!inRange(newOffset, min, max)) {
                newOffset = offset + distance * BOUNCE_DECELERATION;
                if (inRange(newOffset, min - MAX_BOUNCE, max + MAX_BOUNCE))
                    newOffset = limitRange(offset + distance, min - MAX_BOUNCE, max + MAX_BOUNCE)
            }
            return newOffset
        },
        _limitedOffset: function() {
            return {
                    left: limitRange(this._contentOffset.left, this._minLimit().left, this._maxLimit().left),
                    top: limitRange(this._contentOffset.top, this._minLimit().top, this._maxLimit().top)
                }
        },
        _maxLimit: function() {
            return {
                    left: 0,
                    top: 0
                }
        },
        _minLimit: function() {
            return {
                    left: math.min(this._containerSize.width - this._contentSize.width, 0),
                    top: math.min(this._containerSize.height - this._contentSize.height, 0)
                }
        },
        _fireScrollStart: function() {
            this._startAction(this._createEventArgs())
        },
        _fireInertia: function(animation, bouncing) {
            this._inertiaAction(this._createEventArgs())
        },
        _fireScroll: function(updating) {
            this._scrollAction($.extend(this._createEventArgs(), {updating: updating}))
        },
        _fireScrollStop: function(updating) {
            this._stopAction($.extend(this._createEventArgs(), {updating: updating}))
        },
        _fireScrollEnd: function(updating) {
            this._endAction($.extend(this._createEventArgs(), {updating: updating}))
        },
        _createEventArgs: function() {
            return {
                    jQueryEvent: this._currentEvent,
                    scrollOffset: {
                        top: -this._contentOffset.top,
                        left: -this._contentOffset.left
                    },
                    reachedLeft: this._reachedLeft(),
                    reachedRight: this._reachedRight(),
                    reachedTop: this._reachedTop(),
                    reachedBottom: this._reachedBottom()
                }
        },
        _reachedLeft: function() {
            return this._contentOffset.left >= this._maxLimit().left
        },
        _reachedTop: function() {
            return this._contentOffset.top >= this._maxLimit().top
        },
        _reachedRight: function() {
            var minLimit = this._minLimit();
            return minLimit.left && this._contentOffset.left <= minLimit.left
        },
        _reachedBottom: function() {
            var minLimit = this._minLimit();
            return minLimit.top && this._contentOffset.top <= minLimit.top
        },
        _dispose: function() {
            clearTimeout(this._processMoveTimer);
            this._detachStartHandlers();
            this._detachScrollHandlers();
            this._toggleWindowResizeHandler(false);
            this.callBase()
        },
        _optionChanged: function(name) {
            if (name === "showScrollbar" || name === "locked" || name === "direction") {
                if (name === "direction")
                    this._directionChanged();
                else if (name === "locked" && !this.option("locked")) {
                    this._stopScrolling();
                    this.update(true)
                }
                this._scrollbarsEnabling()
            }
            else if (name === "scrollByContent" || name === "scrollByThumb") {
                this._detachStartHandlers();
                this._scrollByChanged();
                this._scrollbarInitAction()
            }
            else if ($.inArray(name, ["startAction", "scrollAction", "stopAction", "endAction", "inertiaAction"]) > -1)
                this._createEventActions();
            this.callBase.apply(this, arguments)
        },
        _normalizeDistance: function(distance) {
            if ($.isPlainObject(distance))
                return distance;
            return this.option("direction") === "horizontal" ? {x: distance} : {y: distance}
        },
        _positionToOffset: function(pos) {
            var offset = {};
            if (pos.x !== undefined)
                offset.left = -pos.x;
            if (pos.y !== undefined)
                offset.top = -pos.y;
            return offset
        },
        _startScroll: function() {
            this._stopScrolling();
            this._updateIfResized(true);
            this._allowUpdate = false;
            this._fireScrollStart()
        },
        _updateScrollbars: function(contentSize, containerSize) {
            this._scrollbars.x.option("disabled", contentSize.width <= containerSize.width);
            this._scrollbars.x.update(contentSize.width, containerSize.width);
            this._scrollbars.y.option("disabled", contentSize.height <= containerSize.height);
            this._scrollbars.y.update(contentSize.height, containerSize.height)
        },
        _update: function(doAnimate) {
            if (this._inBounds()) {
                this._arrangeScrollbars(this._limitedOffset());
                return $.Deferred().resolveWith(this).promise()
            }
            this._scrollbars.x.toggle(true);
            this._scrollbars.y.toggle(true);
            return this._scrollContent(this._limitedOffset(), doAnimate, doAnimate, true)
        },
        update: function(doAnimate) {
            if (this.option("locked"))
                return $.Deferred().resolveWith(this).promise();
            return DX.utils.executeAsync(function() {
                    this._refreshSizes();
                    this._updateScrollbars(this._contentSize, this._containerSize);
                    return this._update(doAnimate)
                }, this)
        },
        content: function() {
            return this._content
        },
        scrollTo: function(pos, doAnimate) {
            var newOffset;
            this._startScroll();
            newOffset = $.extend({}, this._contentOffset);
            pos = this._normalizeDistance(pos);
            return this._scrollContent(this._positionToOffset(pos), doAnimate)
        },
        scrollBy: function(distance, doAnimate) {
            var pos;
            this._startScroll();
            distance = this._normalizeDistance(distance);
            pos = {
                left: this._contentOffset.left - ~~distance.x,
                top: this._contentOffset.top - ~~distance.y
            };
            return this._scrollContent(pos, doAnimate)
        },
        scrollPos: function(pos) {
            this._stopScrolling();
            pos = this._normalizeDistance(pos);
            $.extend(this._contentOffset, this._positionToOffset(pos));
            this._arrangeContent()
        },
        stop: function(jumpToEnd) {
            this._stopScrolling(jumpToEnd);
            return this._bounceContent()
        }
    }));
    $.extend(ui.dxScrollable, {
        wheelSupport: function(value) {
            if (!arguments.length)
                return WHEEL;
            WHEEL = value
        },
        INERTION_CALC_TIMEOUT: INERTION_CALC_TIMEOUT,
        INERTION_MIN_VELOCITY: INERTION_MIN_VELOCITY,
        INERTION_ANIM_DURATION: INERTION_ANIM_DURATION,
        VELOCITY_CALC_TIMEOUT: VELOCITY_CALC_TIMEOUT,
        WHEEL_VELOCITY: WHEEL_VELOCITY,
        SCROLL_BLINK_TIMEOUT: SCROLL_BLINK_TIMEOUT
    })
})(jQuery, DevExpress);

// Module widgets, file ui.scrollView.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var SCROLLVIEW_CLASS = "dx-scrollview",
        SCROLLVIEW_CONTENT_CLASS = "dx-scrollview-content",
        SCROLLVIEW_TOP_POCKET_CLASS = SCROLLVIEW_CLASS + "-top-pocket",
        SCROLLVIEW_BOTTOM_POCKET_CLASS = SCROLLVIEW_CLASS + "-bottom-pocket",
        SCROLLVIEW_SCROLLBOTTOM_INDICATOR_CLASS = SCROLLVIEW_CLASS + "-indicator",
        SCROLLVIEW_SCROLLBOTTOM_CLASS = SCROLLVIEW_CLASS + "-scrollbottom",
        SCROLLVIEW_SCROLLBOTTOM_IMAGE_CLASS = SCROLLVIEW_SCROLLBOTTOM_CLASS + "-image",
        SCROLLVIEW_SCROLLBOTTOM_TEXT_CLASS = SCROLLVIEW_SCROLLBOTTOM_CLASS + "-text",
        SCROLLVIEW_SCROLLBOTTOM_LOADING_CLASS = SCROLLVIEW_SCROLLBOTTOM_CLASS + "-loading",
        SCROLLVIEW_SCROLLBOTTOM_END_CLASS = SCROLLVIEW_SCROLLBOTTOM_CLASS + "-end",
        SCROLLVIEW_SCROLLBOTTOM_INDICATOR_CLASS = SCROLLVIEW_SCROLLBOTTOM_CLASS + "-indicator",
        SCROLLVIEW_PULLDOWN_CLASS = SCROLLVIEW_CLASS + "-pull-down",
        SCROLLVIEW_PULLDOWN_IMAGE_CLASS = SCROLLVIEW_PULLDOWN_CLASS + "-image",
        SCROLLVIEW_PULLDOWN_TEXT_CLASS = SCROLLVIEW_PULLDOWN_CLASS + "-text",
        SCROLLVIEW_PULLDOWN_LOADING_CLASS = SCROLLVIEW_PULLDOWN_CLASS + "-loading",
        SCROLLVIEW_PULLDOWN_READY_CLASS = SCROLLVIEW_PULLDOWN_CLASS + "-ready",
        SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = SCROLLVIEW_PULLDOWN_CLASS + "-indicator",
        RELEASE_TIMEOUT = 500;
    ui.registerComponent("dxScrollView", ui.dxScrollable.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    pullDownAction: null,
                    reachBottomAction: null,
                    updateAction: null
                })
        },
        _init: function() {
            this.callBase();
            this._topPocket = $("<div/>").addClass(SCROLLVIEW_TOP_POCKET_CLASS);
            this._bottomPocket = $("<div/>").addClass(SCROLLVIEW_BOTTOM_POCKET_CLASS);
            this._pullDown = $("<div/>").addClass(SCROLLVIEW_PULLDOWN_CLASS).appendTo(this._topPocket);
            $("<div />").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS).appendTo(this._pullDown);
            var loadIndicatorTop = $("<div>").dxLoadIndicator();
            $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS).append(loadIndicatorTop).appendTo(this._pullDown);
            this._pullDownText = $("<div />").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS).text("Pull down to refresh...").appendTo(this._pullDown);
            this._scrollBottom = $("<div/>").addClass(SCROLLVIEW_SCROLLBOTTOM_CLASS).addClass(SCROLLVIEW_SCROLLBOTTOM_LOADING_CLASS).appendTo(this._bottomPocket);
            var loadIndicatorBottom = $("<div>").dxLoadIndicator();
            $("<div>").addClass(SCROLLVIEW_SCROLLBOTTOM_INDICATOR_CLASS).append(loadIndicatorBottom).appendTo(this._scrollBottom);
            this._scrollBottomText = $("<div />").addClass(SCROLLVIEW_SCROLLBOTTOM_TEXT_CLASS).appendTo(this._scrollBottom);
            this._considerTopPocket = false;
            this._considerBottomPocket = false;
            this._startPullDown = false;
            this._pullDownInProcess = false;
            this._scrollBottomInProcess = false;
            this._preventScrollBottom = false;
            this._freezed = false;
            this._releaseTimer = null;
            this._refreshPullDown();
            this._refreshReachBottom()
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass(SCROLLVIEW_CLASS);
            this._scrollViewContent = this._content.wrapInner($("<div />").addClass(SCROLLVIEW_CONTENT_CLASS)).children().before(this._topPocket).after(this._bottomPocket);
            this._afterRenderHandler()
        },
        _optionChanged: function(name) {
            this.callBase.apply(this, arguments);
            if (name === "pullDownAction")
                this._refreshPullDown();
            else if (name === "reachBottomAction")
                this._refreshReachBottom();
            this.update()
        },
        _refreshPullDown: function() {
            this._hasPullDown = !!this.option("pullDownAction") && this.option("direction") === "vertical" && !this.option("locked");
            this._pullDown.toggle(this._hasPullDown);
            this._topPocketHeight = this._hasPullDown ? this._getHeight(this._topPocket) : 0
        },
        _refreshReachBottom: function() {
            this._hasScrollBottom = !!this.option("reachBottomAction") && this.option("direction") === "vertical" && !this.option("locked");
            this._scrollBottom.toggle(this._hasScrollBottom);
            this._bottomPocketHeight = this._hasScrollBottom ? this._getHeight(this._bottomPocket) : 0
        },
        _afterRender: function(){},
        _getHeight: function(element) {
            var themeContainer = $("[class*=dx-theme-]"),
                container = $("<div/>").css({
                    visibility: "hidden",
                    position: "fixed",
                    right: -9999
                }).appendTo(themeContainer.length ? themeContainer : "body"),
                clone = element.clone().appendTo(container).show();
            var result = clone.height();
            container.remove();
            return result
        },
        _toggleScrollBottomState: function(preventScrollBottom) {
            this._scrollBottom.toggleClass(SCROLLVIEW_SCROLLBOTTOM_END_CLASS, preventScrollBottom).toggleClass(SCROLLVIEW_SCROLLBOTTOM_LOADING_CLASS, !preventScrollBottom);
            this._scrollBottomText.text(preventScrollBottom ? "" : "Loading...");
            this._bottomPocketHeight = this._getHeight(this._bottomPocket)
        },
        _togglePullDownState: function(showing) {
            this._pullDown.removeClass(SCROLLVIEW_PULLDOWN_LOADING_CLASS).toggleClass(SCROLLVIEW_PULLDOWN_READY_CLASS, showing);
            this._pullDownText.text(showing ? "Release to refresh..." : "Pull down to refresh...")
        },
        _setPullDownInProcess: function() {
            this._pullDown.removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS).addClass(SCROLLVIEW_PULLDOWN_LOADING_CLASS);
            this._pullDownText.text('Refreshing...')
        },
        _fireScroll: function(updating) {
            this.callBase(updating);
            if (updating)
                return;
            this._handlePullDownScroll();
            this._handleScrollBottomScroll()
        },
        _fireScrollStop: function(updating) {
            this.callBase(updating);
            if (updating) {
                if (this._reachedPocketTop())
                    return;
                this._togglePullDownState(false);
                return
            }
            this._handlePullDownStop();
            this._handleScrollBottomStop()
        },
        _fireScrollEnd: function(updating) {
            this.callBase(updating);
            this._handlePullDownEnd()
        },
        _handlePullDownScroll: function() {
            if (!this._hasPullDown || this._pullDownInProcess || this._startPullDown)
                return;
            var reachedPocketTop = this._reachedPocketTop();
            if (this._considerTopPocket !== reachedPocketTop) {
                this._considerTopPocket = reachedPocketTop;
                this._togglePullDownState(reachedPocketTop)
            }
        },
        _handleScrollBottomScroll: function() {
            if (!this._hasScrollBottom || this._scrollBottomInProcess || this._preventScrollBottom)
                return;
            this._considerBottomPocket = this._reachedPocketBottom()
        },
        _handlePullDownStop: function() {
            if (this._pullDownInProcess)
                return;
            if (this._hasPullDown && this._reachedPocketTop()) {
                this._startPullDown = true;
                this._freezed = true;
                this._setPullDownInProcess()
            }
        },
        _handleScrollBottomStop: function() {
            if (this._scrollBottomInProcess || this._preventScrollBottom)
                return;
            if (this._hasScrollBottom && this._reachedPocketBottom())
                this._fireScrollBottom()
        },
        _handlePullDownEnd: function() {
            if (this._startPullDown)
                this._firePullDown()
        },
        _runReleaseTimer: function() {
            this._releaseTimerDeferred = $.Deferred();
            this._releaseTimer = setTimeout($.proxy(function() {
                this._releaseTimer = null;
                if (this._needToRelease)
                    this._doRelease().done(function() {
                        this._releaseTimerDeferred.resolve(this)
                    })
            }, this), RELEASE_TIMEOUT)
        },
        _firePullDown: function() {
            this._runReleaseTimer();
            this._pullDownInProcess = true;
            this._createActionByOption("pullDownAction")(this)
        },
        _fireScrollBottom: function() {
            this.update(true);
            this._freezed = true;
            this._scrollBottomInProcess = true;
            this._createActionByOption("reachBottomAction")(this)
        },
        _reachedPocketTop: function() {
            return this._contentOffset.top >= 0
        },
        _reachedPocketBottom: function() {
            var limitBottom = this._containerSize.height - this._contentSize.height;
            return limitBottom && this._contentOffset.top < limitBottom
        },
        _maxLimit: function() {
            if (this._considerTopPocket)
                return this.callBase();
            return {
                    left: 0,
                    top: -this._topPocketHeight
                }
        },
        _minLimit: function() {
            var result = this.callBase();
            if (this._containerSize.height > this._heightWithoutPockets())
                return this._maxLimit();
            var limitBottom = this._containerSize.height - this._contentSize.height;
            if (!this._considerBottomPocket || !this._hasScrollBottom)
                limitBottom += this._bottomPocketHeight;
            result.top = limitBottom;
            return result
        },
        _heightWithoutPockets: function() {
            var contentHeight = this._contentSize.height;
            if (!this._considerTopPocket)
                contentHeight -= this._topPocketHeight;
            if (!this._considerBottomPocket)
                contentHeight -= this._bottomPocketHeight;
            return contentHeight
        },
        _updateScrollbars: function(contentSize, containerSize) {
            var scrollViewContentSize = {
                    width: this._scrollViewContent.width(),
                    height: this._scrollViewContent.height()
                };
            this.callBase(scrollViewContentSize, containerSize)
        },
        _arrangeScrollbars: function(contentOffset) {
            this._scrollbars.x.arrange(contentOffset.left);
            this._scrollbars.y.arrange(contentOffset.top + this._topPocketHeight)
        },
        _animateScrollbars: function(contentOffset, config) {
            this._scrollbars.x.animate(contentOffset.left, config);
            this._scrollbars.y.animate(contentOffset.top + this._topPocketHeight, config)
        },
        _handleStart: function(e) {
            if (this._freezed)
                return;
            this.callBase(e)
        },
        _doRelease: function() {
            this._stopScrolling();
            this._needToRelease = false;
            this._toggleScrollBottomState(this._preventScrollBottom);
            this._startPullDown = false;
            this._pullDownInProcess = false;
            this._scrollBottomInProcess = false;
            this._considerTopPocket = false;
            this._considerBottomPocket = false;
            this._freezed = false;
            return this.update(true)
        },
        _dispose: function() {
            clearTimeout(this._releaseTimer);
            this.callBase()
        },
        update: function(doAnimate) {
            var promise;
            if (!this._freezed && !this.option("locked"))
                promise = this.callBase(doAnimate);
            else
                promise = $.Deferred().resolveWith(this).promise();
            promise.done(function() {
                if (this.option("updateAction"))
                    this._createActionByOption("updateAction")(this)
            });
            return promise
        },
        content: function() {
            return this._scrollViewContent
        },
        isFull: function() {
            var elementSize = this._scrollViewContent.height();
            return !elementSize || elementSize >= this._containerSize.height
        },
        release: function(preventScrollBottom) {
            this._preventScrollBottom = !!preventScrollBottom;
            if (this._releaseTimer) {
                this._needToRelease = true;
                return this._releaseTimerDeferred.promise()
            }
            return DX.utils.executeAsync(this._doRelease, this)
        },
        toggleLoading: function(showOrHide) {
            this._scrollBottom.toggle(this._hasScrollBottom || showOrHide)
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.button.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var BUTTON_CLASS = "dx-button",
        BUTTON_CONTENT_CLASS = "dx-button-content",
        BUTTON_CONTENT_SELECTOR = ".dx-button-content",
        BUTTON_TEXT_CLASS = "dx-button-text",
        BUTTON_TEXT_SELECTOR = ".dx-button-text",
        BUTTON_BACK_ARROW_CLASS = "dx-button-back-arrow",
        ICON_CLASS = "dx-icon",
        ICON_SELECTOR = ".dx-icon";
    ui.registerComponent("dxButton", ui.Widget.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    type: "normal",
                    text: "",
                    icon: "",
                    iconSrc: ""
                })
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass(BUTTON_CLASS).append($("<div />").addClass(BUTTON_CONTENT_CLASS));
            this._renderIcon();
            this._renderType();
            this._renderText()
        },
        _renderIcon: function() {
            var contentElement = this.rootElement().find(BUTTON_CONTENT_SELECTOR),
                iconElement = contentElement.find(ICON_SELECTOR),
                icon = this.option("icon"),
                iconSrc = this.option("iconSrc");
            iconElement.remove();
            if (this.option("type") === "back" && !icon)
                icon = "back";
            if (!icon && !iconSrc)
                return;
            if (icon)
                iconElement = $("<span />").addClass("dx-icon-" + icon);
            else if (iconSrc)
                iconElement = $("<img />").attr("src", iconSrc);
            contentElement.append(iconElement.addClass(ICON_CLASS))
        },
        _renderType: function() {
            var type = this.option("type");
            if (type)
                this.rootElement().addClass("dx-button-" + type);
            if (type === "back")
                this.rootElement().prepend($("<span />").addClass(BUTTON_BACK_ARROW_CLASS))
        },
        _renderText: function() {
            var text = this.option("text"),
                contentElement = this.rootElement().find(BUTTON_CONTENT_SELECTOR),
                back = this.option("type") === "back";
            var textElement = contentElement.find(BUTTON_TEXT_SELECTOR);
            if (!text && !back) {
                textElement.remove();
                return
            }
            if (!textElement.length)
                textElement = $('<span />').addClass(BUTTON_TEXT_CLASS).appendTo(contentElement);
            textElement.text(text || "Back")
        },
        _optionChanged: function(name) {
            switch (name) {
                case"type":
                case"icon":
                case"iconSrc":
                    this._renderType();
                    this._renderIcon();
                    break;
                case"text":
                    this._renderText();
                    break;
                default:
                    this.callBase.apply(this, arguments)
            }
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.checkbox.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var CHECKBOX_CLASS = "dx-checkbox",
        CHECKBOX_ICON_CLASS = "dx-checkbox-icon",
        CHECKBOX_CHECKED_CLASS = "dx-checkbox-checked";
    ui.registerComponent("dxCheckbox", ui.Widget.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {checked: false})
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass(CHECKBOX_CLASS);
            $("<span />").addClass(CHECKBOX_ICON_CLASS).appendTo(this.rootElement());
            this._renderValue()
        },
        _renderClick: function() {
            var eventName = this._eventHelper.eventName("click");
            this.rootElement().off(eventName).on(eventName, $.proxy(this._handleClick, this))
        },
        _handleClick: function() {
            var self = this;
            this._createActionByOption("clickAction", {beforeExecute: function() {
                    self.option("checked", !self.option("checked"))
                }})()
        },
        _renderValue: function() {
            this.rootElement().toggleClass(CHECKBOX_CHECKED_CLASS, this.option("checked"))
        },
        _refresh: function() {
            this._renderValue()
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.switch.js

(function($, DX, undefined) {
    var ui = DX.ui,
        fx = DX.fx;
    var SWITCH_CLASS = "dx-switch",
        SWITCH_WRAPPER_CLASS = SWITCH_CLASS + "-wrapper",
        SWITCH_INNER_CLASS = SWITCH_CLASS + "-inner",
        SWITCH_HANDLE_CLASS = SWITCH_CLASS + "-handle",
        SWITCH_ON_VALUE_CLASS = SWITCH_CLASS + "-on-value",
        SWITCH_ON_CLASS = SWITCH_CLASS + "-on",
        SWITCH_OFF_CLASS = SWITCH_CLASS + "-off",
        MARGIN_BOUND = 50,
        SWITCH_ANIMATION_DURATION = 100;
    ui.registerComponent("dxSwitch", ui.Widget.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    onText: "ON",
                    offText: "OFF",
                    value: false
                })
        },
        _init: function() {
            this.callBase();
            this._animating = false;
            this._animationDuration = SWITCH_ANIMATION_DURATION
        },
        _render: function() {
            this.callBase();
            this._switchInner = $("<div />").addClass(SWITCH_INNER_CLASS).append($("<div />").addClass(SWITCH_HANDLE_CLASS));
            this._labelOn = $("<div />").addClass(SWITCH_ON_CLASS).prependTo(this._switchInner);
            this._labelOff = $("<div />").addClass(SWITCH_OFF_CLASS).appendTo(this._switchInner);
            var $switchWrapper = $("<div />").addClass(SWITCH_WRAPPER_CLASS).append(this._switchInner);
            this.rootElement().addClass(SWITCH_CLASS).append($switchWrapper).dxSwipeable({
                elastic: false,
                startAction: $.proxy(this._handleSwipeStart, this),
                updateAction: $.proxy(this._handleSwipeUpdate, this),
                endAction: $.proxy(this._handleSwipeEnd, this),
                itemWidthFunc: function() {
                    return MARGIN_BOUND + 1
                }
            });
            this._renderValue();
            this._renderLabels()
        },
        _renderPosition: function(state, swipeOffset) {
            this._switchInner.css("marginLeft", MARGIN_BOUND * (state + swipeOffset - 1))
        },
        _renderClick: function() {
            this.callBase();
            var eventName = this._eventHelper.eventName("click"),
                clickAction = this._createAction($.proxy(this._handleClick, this));
            this.rootElement().on(eventName, function(e) {
                clickAction({jQueryEvent: e})
            })
        },
        _handleClick: function(args) {
            var self = args.component;
            if (self._animating || self._swiping)
                return;
            self._animating = true;
            var startValue = self.option("value"),
                endValue = !startValue;
            fx.animate(this._switchInner, {
                from: {marginLeft: (Number(startValue) - 1) * MARGIN_BOUND},
                to: {marginLeft: (Number(endValue) - 1) * MARGIN_BOUND},
                duration: self._animationDuration,
                complete: function() {
                    self._animating = false;
                    self.option("value", endValue)
                }
            })
        },
        _handleSwipeStart: function(e) {
            var state = this.option("value");
            e.maxLeftOffset = state ? 1 : 0;
            e.maxRightOffset = state ? 0 : 1;
            this._swiping = true
        },
        _handleSwipeUpdate: function(e) {
            this._renderPosition(this.option("value"), e.offset)
        },
        _handleSwipeEnd: function(e) {
            var self = this;
            fx.animate(this._switchInner, {
                to: {marginLeft: MARGIN_BOUND * (self.option("value") + e.targetOffset - 1)},
                duration: self._animationDuration,
                complete: function() {
                    self._swiping = false;
                    var pos = self.option("value") + e.targetOffset;
                    self.option("value", Boolean(pos))
                }
            })
        },
        _renderValue: function() {
            var val = this.option("value");
            this._renderPosition(val, 0);
            this.rootElement().toggleClass(SWITCH_ON_VALUE_CLASS, val)
        },
        _renderLabels: function() {
            this._labelOn.text(this.option("onText"));
            this._labelOff.text(this.option("offText"))
        },
        _optionChanged: function(name, value, prevValue) {
            switch (name) {
                case"value":
                    this._renderValue();
                    break;
                case"onText":
                case"offText":
                    this._renderLabels();
                    break;
                default:
                    this.callBase(name, value, prevValue)
            }
        },
        _feedbackOff: function(isGestureStart) {
            if (isGestureStart)
                return;
            this.callBase.apply(this, arguments)
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.editbox.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var EDITBOX_CLASS = "dx-editbox",
        EDITBOX_INPUT_CLASS = "dx-editbox-input",
        EDITBOX_INPUT_SELECTOR = "." + EDITBOX_INPUT_CLASS,
        EDITBOX_BORDER_CLASS = "dx-editbox-border",
        EDITBOX_PLACEHOLDER_CLASS = "dx-placeholder",
        EVENTS_LIST = ["focusIn", "focusOut", "keyDown", "keyPress", "keyUp", "change"];
    var nativePlaceholderSupport = function() {
            var check = document.createElement("input");
            return "placeholder" in check
        }();
    ui.registerComponent("dxEditbox", ui.Widget.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    value: "",
                    valueUpdateEvent: "change",
                    valueUpdateAction: null,
                    placeholder: "",
                    readOnly: false,
                    focusInAction: null,
                    focusOutAction: null,
                    keyDownAction: null,
                    keyPressAction: null,
                    keyUpAction: null,
                    changeAction: null
                })
        },
        _render: function() {
            this.rootElement().addClass(EDITBOX_CLASS);
            this._renderInput();
            this._renderValue();
            this._renderProps();
            this._renderPlaceholder();
            this._renderEvents();
            this.callBase()
        },
        _input: function() {
            return this.rootElement().find(EDITBOX_INPUT_SELECTOR)
        },
        _renderInput: function() {
            this.rootElement().append($("<input />").addClass(EDITBOX_INPUT_CLASS)).append($("<div />").addClass(EDITBOX_BORDER_CLASS))
        },
        _renderValue: function() {
            this._input().val(this.option("value"))
        },
        _renderProps: function() {
            this._input().prop({
                placeholder: this.option("placeholder"),
                readOnly: this.option("readOnly"),
                disabled: this.option("disabled")
            })
        },
        _renderPlaceholder: function() {
            if (nativePlaceholderSupport)
                return;
            var placeholderText = this.option("placeholder"),
                $input = this._input(),
                $placeholder = $('<div />').addClass(EDITBOX_PLACEHOLDER_CLASS).addClass("dx-hide").attr("data-dx_placeholder", placeholderText),
                startEvent = this._eventHelper.eventName("start");
            $placeholder.on(startEvent, function() {
                $input.focus()
            });
            if ($input.val() === "" && !$input.prop("disabled") && $input.prop("placeholder"))
                $placeholder.removeClass("dx-hide");
            $input.wrap($placeholder).on("focusin", function() {
                $(this).parent().addClass("dx-hide")
            }).on("focusout", function() {
                if ($(this).val() === "")
                    $(this).parent().removeClass("dx-hide")
            })
        },
        _renderEvents: function() {
            var self = this,
                $input = self._input(),
                eventHelper = this._eventHelper;
            $.each(EVENTS_LIST, function(index, event) {
                var eventName = eventHelper.eventName(event.toLowerCase()),
                    action = self._createActionByOption(event + "Action");
                $input.off(eventName).on(eventName, function(e) {
                    action({jQueryEvent: e})
                })
            });
            this._renderValueUpdateEvent()
        },
        _renderValueUpdateEvent: function() {
            var valueUpdateEventName = this._eventHelper.eventName(this.option("valueUpdateEvent"));
            this._input().off("." + this.NAME, this._handleValueChange).on(valueUpdateEventName, $.proxy(this._handleValueChange, this));
            this._changeAction = this._createActionByOption("valueUpdateAction")
        },
        _handleValueChange: function(e) {
            this.option("value", this._input().val())
        },
        _optionChanged: function(name) {
            if ($.inArray(name.replace("Action", ""), EVENTS_LIST) > -1) {
                this._renderEvents();
                return
            }
            switch (name) {
                case"value":
                    this._renderValue();
                    this._changeAction(this.option("value"));
                    break;
                case"valueUpdateEvent":
                case"valueUpdateAction":
                    this._renderValueUpdateEvent();
                    break;
                case"readOnly":
                case"disabled":
                    this._renderProps();
                    break;
                default:
                    this.callBase.apply(this, arguments)
            }
        },
        _setInputType: function(type) {
            var input = this._input();
            try {
                input.prop("type", type)
            }
            catch(e) {
                input.prop("type", "text")
            }
        },
        focus: function() {
            this._input().focus()
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.textbox.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var TEXTBOX_CLASS = "dx-textbox",
        AVAILABLE_INPUT_MODES = ["text", "email", "search", "tel", "url", "password"];
    var ignoreCode = [8, 9, 13, 33, 34, 35, 36, 37, 38, 39, 40, 46];
    ui.registerComponent("dxTextbox", ui.dxEditbox.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    mode: "text",
                    maxLength: null,
                    enterKeyAction: null
                })
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass(TEXTBOX_CLASS);
            if (this.option("enterKeyAction")) {
                this.rootElement().find("input").on("keydown.enterKey.dxTextbox", $.proxy(this._onKeyDownHandler, this));
                this._enterKeyAction = this._createActionByOption("enterKeyAction")
            }
            if (this._isAndroid())
                this.rootElement().find("input").on(this._eventHelper.eventName("keydown"), $.proxy(this._onKeyDownAndroidHandler, this)).on(this._eventHelper.eventName("change"), $.proxy(this._onChangeAndroidHandler, this));
            this._renderMode()
        },
        _renderMode: function() {
            var mode = this.option("mode");
            if ($.inArray(mode, AVAILABLE_INPUT_MODES) < 0)
                throw Error("Mode " + mode + " is unavailable");
            this._setInputType(mode)
        },
        _renderProps: function() {
            this.callBase();
            if (this._isAndroid())
                return;
            var maxLength = this.option("maxLength");
            if (maxLength > 0)
                this._input().prop("maxLength", maxLength)
        },
        _optionChanged: function(name) {
            if (name === "enterKeyAction") {
                var enterKeyActionProp;
                if (enterKeyActionProp = this.option("enterKeyAction")) {
                    this.rootElement().find("input").on("keydown.enterKey.dxTextbox", $.proxy(this._onKeyDownHandler, this));
                    this._enterKeyAction = this._createActionByOption("enterKeyAction")
                }
                else {
                    this.rootElement().find("input").off("keydown.enterKey.dxTextbox");
                    this._enterKeyAction = undefined
                }
            }
            else if (name === "maxLength")
                this._renderProps();
            else
                this.callBase.apply(this, arguments)
        },
        _onKeyDownHandler: function(e) {
            if (e.which === 13)
                this._enterKeyAction()
        },
        _onKeyDownAndroidHandler: function(e) {
            var maxLength = this.option("maxLength");
            if (maxLength) {
                var $input = $(e.target),
                    code = e.keyCode;
                this._cutOffExtraChar($input);
                return $input.val().length < maxLength || $.inArray(code, ignoreCode) !== -1 || window.getSelection().toString() !== ""
            }
            else
                return true
        },
        _onChangeAndroidHandler: function(e) {
            var $input = $(e.target);
            if (this.option("maxLength"))
                this._cutOffExtraChar($input)
        },
        _cutOffExtraChar: function($input) {
            var maxLength = this.option("maxLength"),
                textInput = $input.val();
            if (textInput.length > maxLength)
                $input.val(textInput.substr(0, maxLength))
        },
        _isAndroid: function() {
            var ua = window.navigator.userAgent,
                version = DX.devices.androidVersion(ua);
            return version && /^(2\.|4\.0|4\.1)/.test(version) && ua.indexOf("Chrome") === -1
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.textArea.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var TEXTAREA_CLASS = "dx-textarea",
        EDITBOX_INPUT_CLASS = "dx-editbox-input",
        EDITBOX_BORDER_CLASS = "dx-editbox-border";
    ui.registerComponent("dxTextArea", ui.dxEditbox.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    cols: 20,
                    rows: 2
                })
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass(TEXTAREA_CLASS)
        },
        _renderInput: function() {
            this.rootElement().append($("<textarea>").addClass(EDITBOX_INPUT_CLASS)).append($("<div />").addClass(EDITBOX_BORDER_CLASS))
        },
        _renderProps: function() {
            this.callBase();
            this._input().prop({
                rows: this.option("rows"),
                cols: this.option("cols")
            })
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.numberbox.js

(function($, DX, undefined) {
    var ui = DX.ui,
        math = Math;
    ui.registerComponent("dxNumberbox", ui.dxEditbox.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    value: 0,
                    min: -Number.MAX_VALUE,
                    max: Number.MAX_VALUE
                })
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass("dx-numberbox");
            this._setInputType("number")
        },
        _renderProps: function() {
            this.callBase();
            this._input().prop({
                min: this.option("min"),
                max: this.option("max")
            })
        },
        _handleValueChange: function() {
            var $input = this._input(),
                value = $input.val(),
                number;
            if (!value) {
                this.option("value", undefined);
                return
            }
            number = Globalize.parseFloat(value, 10, Globalize.findClosestCulture(navigator.language) || Globalize.cultures["default"].language);
            if (isNaN(number)) {
                $input.val(this.option("value"));
                return
            }
            number = math.max(number, this.option("min"));
            number = math.min(number, this.option("max"));
            this.option("value", number)
        },
        _optionChanged: function(name) {
            if (name === "min" || name === "max")
                this._renderProps(arguments);
            else
                this.callBase.apply(this, arguments)
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.datebox.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var DATEBOX_CLASS = "dx-datebox",
        EDITBOX_INPUT_CLASS = "dx-editbox-input";
    var formats = ["date", "time", "datetime"];
    var DATE_STANDARD_FORMAT_PATTERNS = {
            date: "yyyy-MM-dd",
            datetime: "yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'",
            datetimeAndroid: "yyyy'-'MM'-'dd'T'HH':'mm'Z'",
            time: "HH:mm"
        },
        MODE_FORMAT_MAP = {
            date: {
                y: 1,
                M: 1,
                d: 1
            },
            time: {
                h: 1,
                m: 1
            },
            datetime: {
                h: 1,
                m: 1,
                s: 1,
                M: 1,
                y: 1,
                d: 1,
                ms: 1
            }
        };
    var toStandardDateFormat = function(date, mode) {
            return Globalize.format(date, DATE_STANDARD_FORMAT_PATTERNS[mode])
        };
    var fromStandardDateFormat = function(date) {
            return Globalize.parseDate(date, DATE_STANDARD_FORMAT_PATTERNS.datetime) || Globalize.parseDate(date, DATE_STANDARD_FORMAT_PATTERNS.datetimeAndroid) || Globalize.parseDate(date, DATE_STANDARD_FORMAT_PATTERNS.time) || Globalize.parseDate(date, DATE_STANDARD_FORMAT_PATTERNS.date)
        };
    var DATE_OPTION_NAMES = ["y", "M", "d", "h", "m", "s", "ms"],
        DATE_METHOD_NAMES = ["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"];
    var mergeDates = function(target, source, options) {
            var defaults = {};
            $.each(DATE_OPTION_NAMES, function() {
                defaults[this] = false
            });
            options = $.extend(defaults, options);
            $.each(DATE_METHOD_NAMES, function(index) {
                var option = options[DATE_OPTION_NAMES[index]];
                if (option)
                    target["set" + this](source["get" + this]())
            })
        };
    ui.registerComponent("dxDatebox", ui.dxEditbox.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    format: "date",
                    value: new Date
                })
        },
        _init: function() {
            if (formats.indexOf(this.option("format")) === -1)
                this.option("format", "date")
        },
        _render: function() {
            this.callBase();
            var value = this.option("value"),
                valueUpdateEvent = this.option("valueUpdateEvent");
            this._element.addClass(DATEBOX_CLASS);
            this._setInputType(this.option("format"));
            this._inputElement = this.rootElement().find("." + EDITBOX_INPUT_CLASS).prop({
                disabled: this.option("disabled"),
                readOnly: this.option("readOnly")
            }).val(toStandardDateFormat(this.option("value"), this.option("format"))).off(valueUpdateEvent).on(valueUpdateEvent, $.proxy(function() {
                var value = fromStandardDateFormat(this._inputElement.val()),
                    modelValue = new Date(this.option("value") && this.option("value").valueOf());
                if (value) {
                    mergeDates(modelValue, value, MODE_FORMAT_MAP[this.option("format")]);
                    this.option("value", modelValue)
                }
                else
                    this.option({value: undefined})
            }, this)).prependTo(this._element)
        },
        _optionChanged: function(name, value, prevValue) {
            switch (name) {
                case"value":
                    this._inputElement.val(toStandardDateFormat(this.option("value"), this.option("format")));
                    break;
                default:
                    this.callBase(name, value, prevValue)
            }
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.slider.js

(function($, DX, undefined) {
    var ui = DX.ui,
        translator = DX.translator,
        utils = DX.utils;
    var SLIDER_CLASS = "dx-slider",
        SLIDER_WRAPPER_CLASS = SLIDER_CLASS + "-wrapper",
        SLIDER_HANDLE_CLASS = SLIDER_CLASS + "-handle",
        SLIDER_HANDLE_SELECTOR = "." + SLIDER_HANDLE_CLASS,
        SLIDER_BAR_CLASS = SLIDER_CLASS + "-bar",
        SLIDER_RANGE_CLASS = SLIDER_CLASS + "-range";
    ui.registerComponent("dxSlider", ui.Widget.inherit({
        _activeStateUnit: SLIDER_HANDLE_SELECTOR,
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    min: 0,
                    max: 100,
                    step: 1,
                    value: 50
                })
        },
        _init: function() {
            this.callBase();
            utils.windowResizeCallbacks.add(this._refreshHandler = $.proxy(this._refresh, this))
        },
        _dispose: function() {
            this.callBase();
            utils.windowResizeCallbacks.remove(this._refreshHandler)
        },
        _render: function() {
            this.callBase();
            this._wrapper = $("<div />").addClass(SLIDER_WRAPPER_CLASS);
            this._bar = $("<div />").addClass(SLIDER_BAR_CLASS).appendTo(this._wrapper);
            this._selectedRange = $("<div />").addClass(SLIDER_RANGE_CLASS).appendTo(this._bar);
            this._handle = $("<div />").addClass(SLIDER_HANDLE_CLASS).appendTo(this._bar);
            this.rootElement().addClass(SLIDER_CLASS).append(this._wrapper);
            this._wrapper.dxSwipeable({
                elastic: false,
                startAction: $.proxy(this._handleSwipeStart, this),
                updateAction: $.proxy(this._handleSwipeUpdate, this),
                itemWidthFunc: $.proxy(this._itemWidthFunc, this)
            });
            this._renderValue();
            this._renderStartHandler()
        },
        _renderStartHandler: function() {
            var eventName = this._eventHelper.eventName("start"),
                startAction = this._createAction($.proxy(this._handleStart, this));
            this.rootElement().on(eventName, function(e) {
                startAction({jQueryEvent: e})
            })
        },
        _itemWidthFunc: function() {
            return this.rootElement().width()
        },
        _handleSwipeStart: function(e) {
            this._startOffset = this._currentRatio;
            e.maxLeftOffset = this._startOffset;
            e.maxRightOffset = 1 - this._startOffset
        },
        _handleSwipeUpdate: function(e) {
            this._handleValueChange(this._startOffset + e.offset)
        },
        _handleValueChange: function(ratio) {
            var min = this.option("min"),
                max = this.option("max"),
                step = this.option("step"),
                newValue = Math.round(ratio * (max - min)) + min;
            if (newValue === max || newValue === min)
                this.option("value", newValue);
            else
                this.option("value", Math.round(newValue / step) * step)
        },
        _handleStart: function(args) {
            var e = args.jQueryEvent;
            if ($(e.target).is(this._handle))
                return;
            this._currentRatio = (this._eventHelper.eventX(e) - this._bar.offset().left) / this._bar.width();
            this._handleValueChange(this._currentRatio)
        },
        _renderValue: function() {
            var val = this.option("value"),
                min = this.option("min"),
                max = this.option("max");
            if (min > max)
                return;
            if (val < min) {
                this.option("value", min);
                this._currentRatio = 0;
                return
            }
            if (val > max) {
                this.option("value", max);
                this._currentRatio = 1;
                return
            }
            var handleWidth = this._handle.outerWidth(),
                barWidth = this._bar.width(),
                ratio = (val - min) / (max - min);
            translator.move(this._handle, {left: ratio * barWidth - handleWidth / 2});
            this._selectedRange.width(ratio * barWidth);
            this._currentRatio = ratio
        },
        _refresh: function() {
            this._renderValue()
        },
        _feedbackOff: function(isGestureStart) {
            if (isGestureStart)
                return;
            this.callBase.apply(this, arguments)
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.rangeSlider.js

(function($, DX, undefined) {
    var ui = DX.ui,
        translator = DX.translator;
    var SLIDER_HADLE_CLASS = "dx-slider-handle";
    ui.registerComponent("dxRangeSlider", ui.dxSlider.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    start: 40,
                    end: 60
                })
        },
        _render: function() {
            this._handleRight = $("<div />").addClass(SLIDER_HADLE_CLASS);
            this.callBase();
            this._handleRight.appendTo(this._bar)
        },
        _handleStart: function(args) {
            var e = args.jQueryEvent;
            var left = this._eventHelper.eventX(e) - this._bar.offset().left,
                ratio = left / this._bar.width();
            this._currentRatio = ratio;
            this._capturedHandle = (this._handle.position().left + this._handleRight.position().left) / 2 > left ? this._handle : this._handleRight;
            this._handleValueChange(ratio)
        },
        _handleValueChange: function(ratio) {
            var option = this._capturedHandle === this._handle ? "start" : "end";
            var min = this.option("min"),
                max = this.option("max"),
                start = this.option("start"),
                end = this.option("end"),
                step = this.option("step"),
                newValue = Math.round(ratio * (max - min)) + min;
            if (newValue > end && option === "start")
                newValue = end;
            if (newValue < start && option === "end")
                newValue = start;
            if (newValue === max || newValue === min)
                this.option(option, newValue);
            else
                this.option(option, Math.round(newValue / step) * step)
        },
        _renderValue: function() {
            var valStart = this.option("start"),
                valEnd = this.option("end"),
                min = this.option("min"),
                max = this.option("max");
            if (valStart < min)
                valStart = min;
            if (valEnd > max)
                valEnd = max;
            if (valEnd < valStart)
                valEnd = valStart;
            var handleWidth = this._handle.outerWidth(),
                barWidth = this._bar.width(),
                ratio1 = (valStart - min) / (max - min),
                ratio2 = (valEnd - min) / (max - min);
            translator.move(this._handle, {left: ratio1 * barWidth - handleWidth / 2});
            translator.move(this._handleRight, {left: ratio2 * barWidth - handleWidth / 2});
            translator.move(this._selectedRange, {left: ratio1 * barWidth});
            this._selectedRange.width((ratio2 - ratio1) * barWidth)
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.tabs.js

(function($, DX, undefined) {
    var ui = DX.ui,
        TABS_CLASS = "dx-tabs",
        TABS_WRAPPER_CLASS = "dx-indent-wrapper",
        TABS_ITEM_CLASS = "dx-tab",
        TABS_ITEM_SELECTOR = ".dx-tab",
        TABS_ITEM_SELECTED_CLASS = "dx-tab-selected",
        TABS_ITEM_TEXT_CLASS = "dx-tab-text",
        ICON_CLASS = "dx-icon",
        TABS_ITEM_DATA_KEY = "dxTabData";
    ui.registerComponent("dxTabs", ui.CollectionContainerWidget.inherit({
        _activeStateUnit: TABS_ITEM_SELECTOR,
        _defaultOptions: function() {
            return $.extend(this.callBase(), {selectedIndex: -1})
        },
        _itemClass: function() {
            return TABS_ITEM_CLASS
        },
        _itemDataKey: function() {
            return TABS_ITEM_DATA_KEY
        },
        _itemRenderDefault: function(item, index, itemElement) {
            this.callBase(item, index, itemElement);
            if (item.html)
                return;
            var text = item.text,
                icon = item.icon,
                iconSrc = item.iconSrc,
                iconElement;
            if (text)
                itemElement.wrapInner($("<span />").addClass(TABS_ITEM_TEXT_CLASS));
            if (icon)
                iconElement = $("<span />").addClass(ICON_CLASS + "-" + icon);
            else if (iconSrc)
                iconElement = $("<img />").attr("src", iconSrc);
            if (iconElement)
                iconElement.addClass(ICON_CLASS).prependTo(itemElement)
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass(TABS_CLASS);
            this._renderWrapper();
            this._renderSelectedIndex()
        },
        _renderWrapper: function() {
            this.rootElement().wrapInner($("<div />").addClass(TABS_WRAPPER_CLASS))
        },
        _renderSelectedIndex: function() {
            var selectedIndex = this.option("selectedIndex");
            this._tabs().each(function(tabIndex) {
                $(this).toggleClass(TABS_ITEM_SELECTED_CLASS, tabIndex === selectedIndex)
            })
        },
        _renderEmptyMessage: $.noop,
        _tabs: function() {
            return this._items()
        },
        _attachClickEvent: function() {
            var itemSelector = this._itemSelector(),
                itemClickAction = this._createAction(this._handleItemClick);
            this._element.off("." + this.NAME, itemSelector).on(this._eventHelper.eventName("end"), itemSelector, function(e) {
                itemClickAction({jQueryEvent: e})
            })
        },
        _handleItemClick: function(args) {
            var e = args.jQueryEvent,
                instance = args.component,
                clickedItemElement = $(e.target).closest(instance._itemSelector()).get(0);
            instance.option("selectedIndex", instance._tabs().index(clickedItemElement));
            e.target = instance._tabs().get(instance.option("selectedIndex"));
            instance._handleItemEvent(e, "itemClickAction")
        },
        _optionChanged: function(name) {
            switch (name) {
                case"selectedIndex":
                    this._renderSelectedIndex();
                    break;
                default:
                    this.callBase.apply(this, arguments)
            }
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.navBar.js

(function($, DX, undefined) {
    var ui = DX.ui,
        NAVBAR_CLASS = "dx-navbar",
        NABAR_ITEM_CLASS = "dx-nav-item",
        NAVBAR_ITEM_CONTENT_CLASS = "dx-nav-item-content";
    ui.registerComponent('dxNavBar', ui.dxTabs.inherit({
        _render: function() {
            this.callBase();
            this.rootElement().addClass(NAVBAR_CLASS)
        },
        _renderItem: function(index, item) {
            var itemElement = this.callBase(index, item);
            return itemElement.addClass(NABAR_ITEM_CLASS).wrapInner($("<div />").addClass(NAVBAR_ITEM_CONTENT_CLASS))
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.toolbar.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var TOOLBAR_CLASS = "dx-toolbar",
        TOOLBAR_ITEM_CLASS = "dx-toolbar-item",
        TOOLBAR_LABEL_CLASS = "dx-toolbar-label",
        TOOLBAR_BUTTON_CLASS = "dx-toolbar-button",
        TOOLBAR_ITEM_DATA_KEY = "dxToolbarItemDataKey";
    ui.registerComponent("dxToolbar", ui.CollectionContainerWidget.inherit({
        _itemContainer: function() {
            return this.rootElement().find([".dx-toolbar-left", ".dx-toolbar-center", ".dx-toolbar-right"].join(","))
        },
        _itemClass: function() {
            return TOOLBAR_ITEM_CLASS
        },
        _itemDataKey: function() {
            return TOOLBAR_ITEM_DATA_KEY
        },
        _itemRenderDefault: function(item, index, itemElement) {
            this.callBase(item, index, itemElement);
            var widget = item.widget;
            if (widget) {
                var widgetElement = $("<div />").appendTo(itemElement),
                    widgetName = DX.inflector.camelize("dx-" + widget),
                    options = item.options || {};
                widgetElement[widgetName](options)
            }
        },
        _render: function() {
            this.rootElement().addClass(TOOLBAR_CLASS);
            this._renderContainers();
            this.callBase()
        },
        _renderEmptyMessage: $.noop,
        _clean: function() {
            this.rootElement().children().empty()
        },
        _renderItem: function(index, item) {
            var align = item.align || "center",
                container = this.rootElement().find(".dx-toolbar-" + align);
            var itemElement = this.callBase(index, item, container);
            itemElement.addClass(TOOLBAR_BUTTON_CLASS);
            if (item.text)
                itemElement.addClass(TOOLBAR_LABEL_CLASS).removeClass(TOOLBAR_BUTTON_CLASS);
            return itemElement
        },
        _renderContainers: function() {
            var rootElement = this.rootElement();
            $.each(["left", "center", "right"], function() {
                var containerClass = "dx-toolbar-" + this,
                    container = rootElement.find("." + containerClass);
                if (!container.length)
                    container = $('<div />').addClass(containerClass).appendTo(rootElement)
            })
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.list.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var LIST_CLASS = "dx-list",
        LIST_ITEM_CLASS = "dx-list-item",
        LIST_ITEM_SELECTOR = "." + LIST_ITEM_CLASS,
        LIST_GROUD_CLASS = "dx-list-group",
        LIST_GROUP_HEADER_CLASS = "dx-list-group-header",
        LIST_HAS_NEXT_CLASS = "dx-has-next",
        LIST_NEXT_BUTTON_CLASS = "dx-list-next-button",
        LIST_ITEM_DATA_KEY = "dxListItemData",
        LIST_FEEDBACK_SHOW_TIMEOUT = 70,
        ITEM_SWIPE_SCROLL_SUPRESSION_THRESHOLD = 30,
        ITEM_SWIPE_DURATION_THRESHOLD = 1000,
        ITEM_SWIPE_HORIZONTAL_DISTANCE_THRESHOLD = 30,
        ITEM_SWIPE_VERTICAL_DISTANCE_THRESHOLD = 75;
    ui.registerComponent("dxList", ui.CollectionContainerWidget.inherit({
        _activeStateUnit: LIST_ITEM_SELECTOR,
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    pullRefreshEnabled: false,
                    autoPagingEnabled: true,
                    scrollingEnabled: true,
                    scrollByContent: true,
                    scrollByThumb: false,
                    showScrollbar: true,
                    showNextButton: false,
                    itemHoldAction: null,
                    itemHoldTimeout: 750,
                    itemSwipeAction: null,
                    grouped: false,
                    groupTemplate: "group",
                    groupRender: null
                })
        },
        _itemClass: function() {
            return LIST_ITEM_CLASS
        },
        _itemDataKey: function() {
            return LIST_ITEM_DATA_KEY
        },
        _itemContainer: function() {
            return this._container
        },
        _init: function() {
            this._dataLoading = true;
            this.callBase();
            this._container = this._element;
            this._initScrollView();
            this._feedbackShowTimeout = LIST_FEEDBACK_SHOW_TIMEOUT
        },
        _initScrollView: function() {
            this._scrollView = this.rootElement().dxScrollView({
                disabled: this.option("disabled"),
                pullDownAction: this.option("scrollingEnabled") && this.option("pullRefreshEnabled") ? $.proxy(this._handlePullDown, this) : null,
                reachBottomAction: this.option("scrollingEnabled") && this.option("autoPagingEnabled") && this._dataSource ? $.proxy(this._handleScrollBottom, this) : null,
                locked: !this.option("scrollingEnabled")
            }).data("dxScrollView");
            this._scrollView.toggleLoading(!!this._dataSource);
            this._container = this._scrollView.content()
        },
        _afterItemsRendered: function(tryLoadMore) {
            var allDataLoaded = !tryLoadMore || this._allDataLoaded();
            this._scrollView.option("updateAction", allDataLoaded ? null : $.proxy(this._handleScrollViewUpdated, this));
            this._scrollView.toggleLoading(this._dataLoading);
            this._scrollView.release(allDataLoaded);
            if (this._nextButton)
                this._toggleNextButton(!allDataLoaded)
        },
        _handlePullDown: function() {
            if (this._dataSource)
                this._dataSource.reload();
            else
                this._afterItemsRendered()
        },
        _handleScrollBottom: function() {
            if (this._dataSource)
                this._dataSource.nextPage(true);
            else
                this._afterItemsRendered()
        },
        _handleScrollViewUpdated: function(scrollViewAction) {
            var scrollView = scrollViewAction.component;
            if (!scrollView.isFull())
                this._handleScrollBottom()
        },
        _handleDataSourceLoadError: function(error) {
            if (this._initialized)
                this._afterItemsRendered()
        },
        _render: function() {
            if (!this._dataSource)
                this._dataLoading = false;
            var actionItemStart = new DX.Action(this._handleItemStart, {context: this}),
                actionItemEnd = new DX.Action(this._handleItemEnd, {context: this});
            this.rootElement().addClass(LIST_CLASS);
            this.callBase();
            this._element.on(this._eventHelper.eventName("start"), this._itemSelector(), $.proxy(actionItemStart.execute, actionItemStart)).on(this._eventHelper.eventName("end"), this._itemSelector(), $.proxy(actionItemEnd.execute, actionItemEnd));
            if (this.option("showNextButton") && this._dataSource)
                this._getNextButton()
        },
        _allDataLoaded: function() {
            return !this._dataSource || this._dataSource.isLastPage()
        },
        _getNextButton: function() {
            if (!this._nextButton)
                this._nextButton = this._createNextButton();
            return this._nextButton
        },
        _createNextButton: function() {
            var showButton = !this._allDataLoaded();
            this._element.toggleClass(LIST_HAS_NEXT_CLASS, showButton);
            return $("<div/>").addClass(LIST_NEXT_BUTTON_CLASS).toggle(showButton).append($("<div/>").dxButton({
                    text: "More",
                    clickAction: $.proxy(this._handleNextButton, this)
                })).appendTo(this._element)
        },
        _renderItems: function() {
            if (this.option("grouped"))
                $.each(this.option("items") || [], $.proxy(this._renderGroup, this));
            else
                this.callBase();
            this._afterItemsRendered(true)
        },
        _handleNextButton: function() {
            if (this._dataLoading)
                return;
            this._dataLoading = true;
            this._scrollView.toggleLoading(true);
            this._dataSource.nextPage(true)
        },
        _toggleNextButton: function(showButton) {
            var nextButton = this._getNextButton();
            nextButton.toggle(showButton);
            this._element.toggleClass(LIST_HAS_NEXT_CLASS, showButton)
        },
        _handleItemStart: function(e) {
            if (this._eventHelper.needSkipEvent(e))
                return;
            clearTimeout(this._holdTimer);
            this._holdTimer = setTimeout($.proxy(this._handleItemHold, this, e), this.option("itemHoldTimeout"));
            this._handleSwipe(e)
        },
        _handleItemEnd: function() {
            clearTimeout(this._holdTimer)
        },
        _handleItemHold: function(e) {
            this._handleItemEvent(e, "itemHoldAction")
        },
        _handleSwipe: function(e) {
            var self = this,
                eventHelper = this._eventHelper,
                start = eventHelper.eventData(e),
                end;
            var moveHandler = function(e) {
                    if (!start)
                        return;
                    end = eventHelper.eventData(e);
                    if (Math.abs(start.x - end.x) > ITEM_SWIPE_SCROLL_SUPRESSION_THRESHOLD)
                        e.preventDefault()
                };
            var endHandler = function(e) {
                    self._element.off(eventHelper.eventName("move"));
                    if (start && end) {
                        var delta = eventHelper.eventDelta(end, start);
                        if (delta.time < ITEM_SWIPE_DURATION_THRESHOLD && Math.abs(delta.x) > ITEM_SWIPE_HORIZONTAL_DISTANCE_THRESHOLD && Math.abs(delta.y) < ITEM_SWIPE_VERTICAL_DISTANCE_THRESHOLD)
                            self._handleItemEvent(e, "itemSwipeAction", {direction: delta.x > 0 ? "left" : "right"})
                    }
                    start = end = undefined
                };
            this._element.on(eventHelper.eventName("move"), this._itemSelector(), moveHandler).one(eventHelper.eventName("end"), this._itemSelector(), endHandler)
        },
        _groupRenderDefault: function(group) {
            return String(group.key || group)
        },
        _renderGroup: function(index, group) {
            var self = this;
            var groupElement = $("<div />").addClass(LIST_GROUD_CLASS).appendTo(self._itemContainer());
            var groupRenderer = self.option("groupRender"),
                groupTemplateName = self.option("groupTemplate"),
                groupTemplate = self._getTemplate(group.template || groupTemplateName, index, group),
                groupHeaderElement;
            var renderArgs = {
                    index: index,
                    group: group,
                    container: groupElement
                };
            if (groupRenderer)
                groupHeaderElement = self._createGroupByRenderer(groupRenderer, renderArgs);
            else if (groupTemplate)
                groupHeaderElement = self._createGroupByTemplate(groupTemplate, renderArgs);
            else
                groupHeaderElement = self._createGroupByRenderer(self._groupRenderDefault, renderArgs);
            groupHeaderElement.addClass(LIST_GROUP_HEADER_CLASS);
            $.each(group.items || [], function(index, item) {
                self._renderItem(index, item, groupElement)
            })
        },
        _createGroupByRenderer: function(groupRenderer, renderArgs) {
            var groupElement = $("<div />").appendTo(renderArgs.container);
            var rendererResult = groupRenderer(renderArgs.group, renderArgs.index, groupElement);
            if (rendererResult && groupElement[0] !== rendererResult[0])
                groupElement.append(rendererResult);
            return groupElement
        },
        _createGroupByTemplate: function(groupTemplate, renderArgs) {
            return groupTemplate.render(renderArgs.container, renderArgs.group)
        },
        _handleDataSourceChanged: function(items) {
            this._dataLoading = false;
            this.callBase(items)
        },
        _dispose: function() {
            clearTimeout(this._holdTimer);
            this.callBase()
        },
        _optionChanged: function(name, value, prevValue) {
            switch (name) {
                case"dataSource":
                    this.callBase(name, value, prevValue);
                    this._initScrollView();
                    return;
                case"pullRefreshEnabled":
                case"autoPagingEnabled":
                case"scrollingEnabled":
                case"scrollByContent":
                case"scrollByThumb":
                    this._initScrollView();
                    return;
                default:
                    this.callBase(name, value, prevValue)
            }
        },
        update: function(doAnimate) {
            var self = this,
                deferred = $.Deferred();
            if (self._scrollView)
                self._scrollView.update(doAnimate).done(function() {
                    deferred.resolveWith(self)
                });
            else
                deferred.resolveWith(self);
            return deferred.promise()
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.tileView.js

(function($, DX, undefined) {
    var ui = DX.ui,
        utils = DX.utils;
    var TILEVIEW_CLASS = "dx-tileview",
        TILEVIEW_WRAPPER_CLASS = "dx-tiles-wrapper",
        TILEVIEW_ITEM_CLASS = "dx-tile",
        TILEVIEW_ITEM_SELECTOR = "." + TILEVIEW_ITEM_CLASS,
        TILEVIEW_ITEM_DATA_KEY = "dxTileData";
    ui.registerComponent("dxTileView", ui.CollectionContainerWidget.inherit({
        _activeStateUnit: TILEVIEW_ITEM_SELECTOR,
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    items: null,
                    bounceEnabled: true,
                    showScrollbar: false,
                    listHeight: 500,
                    baseItemWidth: 100,
                    baseItemHeight: 100,
                    itemMargin: 20
                })
        },
        _itemClass: function() {
            return TILEVIEW_ITEM_CLASS
        },
        _itemDataKey: function() {
            return TILEVIEW_ITEM_DATA_KEY
        },
        _itemContainer: function() {
            return this._wrapper
        },
        _init: function() {
            var self = this;
            self.callBase();
            self._refreshHandler = function() {
                self._renderGeometry()
            };
            utils.windowResizeCallbacks.add(self._refreshHandler)
        },
        _dispose: function() {
            this.callBase();
            utils.windowResizeCallbacks.remove(this._refreshHandler)
        },
        _render: function() {
            this.cellsPerColumn = 1;
            this.rootElement().addClass(TILEVIEW_CLASS).height(this.option("listHeight"));
            if (!this._wrapper)
                this._renderWrapper();
            this._initScrollable();
            this.callBase();
            this._renderGeometry()
        },
        _renderWrapper: function() {
            this._wrapper = $("<div />").addClass(TILEVIEW_WRAPPER_CLASS).appendTo(this._element)
        },
        _initScrollable: function() {
            this._element.dxScrollable({
                direction: "horizontal",
                showScrollbar: this.option("showScrollbar"),
                bounceEnabled: this.option("bounceEnabled")
            })
        },
        _renderGeometry: function() {
            var items = this.option("items") || [],
                maxItemHeight = Math.max.apply(Math, $.map(items || [], function(item) {
                    return item.heightRatio || 1
                }));
            this.cellsPerColumn = Math.floor(this.rootElement().height() / (this.option("baseItemHeight") + this.option("itemMargin")));
            this.cellsPerColumn = Math.max(this.cellsPerColumn, maxItemHeight);
            this.cells = [];
            this.cells.push(new Array(this.cellsPerColumn));
            this._arrangeItems(items);
            this._wrapper.width(this.cells.length * this.option("baseItemWidth") + (this.cells.length + 1) * this.option("itemMargin"))
        },
        _arrangeItems: function(items) {
            var self = this;
            $.each(items, function(index, item) {
                item.widthRatio = item.widthRatio || 1;
                item.heightRatio = item.heightRatio || 1;
                item.text = item.text || "";
                var $item = self._items().eq(index),
                    itemPosition = self._getItemPosition(item);
                if (itemPosition.x === -1)
                    itemPosition.x = self.cells.push(new Array(this.cellsPerColumn)) - 1;
                self._occupyCells(item, itemPosition);
                self._arrangeItem($item, item, itemPosition)
            })
        },
        _getItemPosition: function(item) {
            var position = {
                    x: -1,
                    y: 0
                };
            for (var col = 0; col < this.cells.length; col++) {
                for (var row = 0; row < this.cellsPerColumn; row++)
                    if (this._itemFit(col, row, item)) {
                        position.x = col;
                        position.y = row;
                        break
                    }
                if (position.x > -1)
                    break
            }
            return position
        },
        _itemFit: function(column, row, item) {
            var result = true;
            if (row + item.heightRatio > this.cellsPerColumn)
                return false;
            for (var columnIndex = column; columnIndex < column + item.widthRatio; columnIndex++)
                for (var rowIndex = row; rowIndex < row + item.heightRatio; rowIndex++)
                    if (this.cells.length - 1 < columnIndex)
                        this.cells.push(new Array(this.cellsPerColumn));
                    else if (this.cells[columnIndex][rowIndex]) {
                        result = false;
                        break
                    }
            return result
        },
        _occupyCells: function(item, itemPosition) {
            for (var i = itemPosition.x; i < itemPosition.x + item.widthRatio; i++)
                for (var j = itemPosition.y; j < itemPosition.y + item.heightRatio; j++)
                    this.cells[i][j] = true
        },
        _arrangeItem: function($item, item, itemPosition) {
            var baseItemHeight = this.option("baseItemHeight"),
                baseItemWidth = this.option("baseItemWidth"),
                itemMargin = this.option("itemMargin");
            $item.css({
                height: item.heightRatio * baseItemHeight + (item.heightRatio - 1) * itemMargin,
                width: item.widthRatio * baseItemWidth + (item.widthRatio - 1) * itemMargin,
                top: itemPosition.y * baseItemHeight + (itemPosition.y + 1) * itemMargin,
                left: itemPosition.x * baseItemWidth + (itemPosition.x + 1) * itemMargin
            })
        },
        _optionChanged: function(name) {
            if (name === "bounceEnabled" || name === "showScrollbar")
                this._initScrollable();
            else
                this.callBase.apply(this, arguments)
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.gallery.js

(function($, DX, undefined) {
    var ui = DX.ui,
        fx = DX.fx,
        translator = DX.translator,
        GALLERY_CLASS = "dx-gallery",
        GALLERY_ITEM_CONTAINER_CLASS = GALLERY_CLASS + "-wrapper",
        GALLERY_ITEM_CLASS = GALLERY_CLASS + "-item",
        GALLERY_ITEM_SELECTOR = "." + GALLERY_ITEM_CLASS,
        GALLERY_ITEM_SELECTED_CLASS = GALLERY_ITEM_CLASS + "-selected",
        GALLERY_INDICATOR_CLASS = GALLERY_CLASS + "-indicator",
        GALLERY_INDICATOR_SELECTOR = "." + GALLERY_INDICATOR_CLASS,
        GALLERY_INDICATOR_ITEM_CLASS = GALLERY_INDICATOR_CLASS + "-item",
        GALLERY_INDICATOR_ITEM_SELECTOR = "." + GALLERY_INDICATOR_ITEM_CLASS,
        GALLERY_INDICATOR_ITEM_SELECTED_CLASS = GALLERY_INDICATOR_ITEM_CLASS + "-selected",
        GALLERY_NAV_BUTTON_NEXT_CLASS = GALLERY_CLASS + "-nav-button-next",
        GALLERY_NAV_BUTTON_NEXT_SELECTOR = "." + GALLERY_NAV_BUTTON_NEXT_CLASS,
        GALLERY_NAV_BUTTON_PREV_CLASS = GALLERY_CLASS + "-nav-button-prev",
        GALLERY_NAV_BUTTON_PREV_SELECTOR = "." + GALLERY_NAV_BUTTON_PREV_CLASS,
        GALLERY_NAV_BUTTONS_SELECTOR = [GALLERY_NAV_BUTTON_NEXT_SELECTOR, GALLERY_NAV_BUTTON_PREV_SELECTOR].join(","),
        GALLERY_ITEM_DATA_KEY = "dxGalleryItemData";
    ui.registerComponent("dxGallery", ui.CollectionContainerWidget.inherit({
        _activeStateUnit: GALLERY_ITEM_SELECTOR,
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    animationDuration: 400,
                    loop: false,
                    swipeEnabled: true,
                    indicatorEnabled: true,
                    showIndicator: true,
                    selectedIndex: 0,
                    slideshowDelay: 0,
                    showNavButtons: false
                })
        },
        _itemContainer: function() {
            return this._container
        },
        _itemClass: function() {
            return GALLERY_ITEM_CLASS
        },
        _itemDataKey: function() {
            return GALLERY_ITEM_DATA_KEY
        },
        _itemWidth: function() {
            return this._items().first().outerWidth()
        },
        _itemsCount: function() {
            return (this.option("items") || []).length
        },
        _itemRenderDefault: function(item, index, itemElement) {
            this.callBase(item, index, itemElement);
            if (!$.isPlainObject(item))
                itemElement.append($("<img />").attr("src", String(item)))
        },
        _render: function() {
            this.rootElement().addClass(GALLERY_CLASS).on(this._eventHelper.eventName("dragstart"), "img", function() {
                return false
            });
            this._renderItemContainer();
            this.callBase();
            this._renderItemPositions();
            this._renderIndicator();
            this._renderSelectedIndicatorItem();
            this._renderUserInteraction();
            this._renderNavButtons();
            this._setupSlideShow()
        },
        _renderItemContainer: function() {
            if (this._container)
                return;
            this._container = $("<div />").addClass(GALLERY_ITEM_CONTAINER_CLASS).appendTo(this.rootElement())
        },
        _renderItemPositions: function(offset, animate) {
            offset = offset || 0;
            var self = this,
                itemWidth = this._itemWidth(),
                selectedIndex = this.option("selectedIndex"),
                animationDuration = this.option("animationDuration"),
                targetIndex = offset - selectedIndex,
                d = $.Deferred(),
                animationPromises = [];
            this._items().each(function(index) {
                var itemPosition = {left: self._flipIndex(targetIndex + index) * itemWidth};
                if (animate)
                    animationPromises.push(fx.animate(this, {
                        type: "slide",
                        to: itemPosition,
                        duration: animationDuration
                    }));
                else
                    translator.move($(this), itemPosition)
            });
            $.when.apply($, animationPromises).done(function() {
                d.resolveWith(self)
            });
            return d.promise()
        },
        _renderIndicator: function() {
            if (!this.option("showIndicator")) {
                this._cleanIndicators();
                return
            }
            var indicator = this._indicator = $("<div />").addClass(GALLERY_INDICATOR_CLASS).appendTo(this.rootElement());
            $.each(this.option("items") || [], function() {
                $("<div />").addClass(GALLERY_INDICATOR_ITEM_CLASS).appendTo(indicator)
            })
        },
        _cleanIndicators: function() {
            if (this._indicator)
                this._indicator.remove()
        },
        _renderSelectedIndicatorItem: function() {
            var selectedIndex = this.option("selectedIndex");
            this._items().removeClass(GALLERY_ITEM_SELECTED_CLASS).eq(selectedIndex).addClass(GALLERY_ITEM_SELECTED_CLASS);
            this.rootElement().find(GALLERY_INDICATOR_ITEM_SELECTOR).removeClass(GALLERY_INDICATOR_ITEM_SELECTED_CLASS).eq(selectedIndex).addClass(GALLERY_INDICATOR_ITEM_SELECTED_CLASS)
        },
        _renderUserInteraction: function() {
            var self = this,
                swipeEnabled = self.option("swipeEnabled"),
                indicatorEnabled = self.option("indicatorEnabled"),
                cursor = swipeEnabled ? "pointer" : "default";
            self.rootElement().dxSwipeable({
                startAction: swipeEnabled ? $.proxy(self._handleSwipeStart, self) : function(e) {
                    e.cancel = true
                },
                updateAction: $.proxy(self._handleSwipeUpdate, self),
                endAction: $.proxy(self._handleSwipeEnd, self),
                itemWidthFunc: $.proxy(self._itemWidth, self)
            }).find(GALLERY_INDICATOR_ITEM_SELECTOR).css({cursor: cursor}).off(this._eventHelper.eventName("click")).on(this._eventHelper.eventName("click"), function() {
                if (!indicatorEnabled)
                    return;
                var index = $(this).index();
                self._renderItemPositions(self.option("selectedIndex") - index, true).done(function() {
                    this._suppressRenderItemPositions = true;
                    self.option("selectedIndex", index)
                })
            }).end().find(GALLERY_NAV_BUTTONS_SELECTOR).css({cursor: cursor})
        },
        _renderNavButtons: function() {
            if (!this.option("showNavButtons")) {
                this._cleanNavButtons();
                return
            }
            this._prevNavButton = $("<div />").addClass(GALLERY_NAV_BUTTON_PREV_CLASS).appendTo(this.rootElement()).on(this._eventHelper.eventName("click"), $.proxy(function() {
                if (this.option("swipeEnabled"))
                    this.prevItem(true)
            }, this));
            this._nextNavButton = $("<div />").addClass(GALLERY_NAV_BUTTON_NEXT_CLASS).appendTo(this.rootElement()).on(this._eventHelper.eventName("click"), $.proxy(function() {
                if (this.option("swipeEnabled"))
                    this.nextItem(true)
            }, this));
            this._renderNavButtonsVisibility()
        },
        _cleanNavButtons: function() {
            if (this._prevNavButton)
                this._prevNavButton.remove();
            if (this._prevNavButton)
                this._nextNavButton.remove()
        },
        _renderNavButtonsVisibility: function() {
            if (!this.option("showNavButtons"))
                return;
            var selectedIndex = this.option("selectedIndex"),
                loop = this.option("loop"),
                itemsCount = this._itemsCount();
            if (selectedIndex < itemsCount && selectedIndex > 0 || loop) {
                this._prevNavButton.show();
                this._nextNavButton.show()
            }
            if (!loop) {
                if (selectedIndex < 1)
                    this._prevNavButton.hide();
                if (selectedIndex === itemsCount - 1)
                    this._nextNavButton.hide()
            }
        },
        _setupSlideShow: function() {
            var self = this,
                slideshowDelay = self.option("slideshowDelay");
            if (!slideshowDelay)
                return;
            clearTimeout(self._slideshowTimer);
            self._slideshowTimer = setTimeout(function() {
                if (self._userInteraction) {
                    self._setupSlideShow();
                    return
                }
                self.nextItem(true).done(self._setupSlideShow)
            }, slideshowDelay)
        },
        _handleSwipeStart: function(e) {
            var itemsCount = this._itemsCount();
            if (!itemsCount || fx.animating(this._items().eq(0))) {
                e.cancel = true;
                return
            }
            this._userInteraction = true;
            if (!this.option("loop")) {
                var selectedIndex = this.option("selectedIndex");
                e.maxLeftOffset = itemsCount - selectedIndex - 1;
                e.maxRightOffset = selectedIndex
            }
        },
        _handleSwipeUpdate: function(e) {
            this._renderItemPositions(e.offset)
        },
        _handleSwipeEnd: function(e) {
            this._renderItemPositions(e.targetOffset, true).done(function() {
                var selectedIndex = this.option("selectedIndex"),
                    newIndex = this._fitIndex(selectedIndex - e.targetOffset);
                this._suppressRenderItemPositions = true;
                this.option("selectedIndex", newIndex);
                this._userInteraction = false;
                this._setupSlideShow()
            })
        },
        _flipIndex: function(index) {
            if (!this.option("loop"))
                return index;
            var itemsCount = this._itemsCount();
            index = index % itemsCount;
            if (index > (itemsCount + 1) / 2)
                index -= itemsCount;
            if (index < -(itemsCount - 1) / 2)
                index += itemsCount;
            return index
        },
        _fitIndex: function(index) {
            if (!this.option("loop"))
                return index;
            var itemsCount = this._itemsCount();
            index = index % itemsCount;
            if (index < 0)
                index += itemsCount;
            return index
        },
        _clean: function() {
            this.callBase();
            this._cleanIndicators();
            this._cleanNavButtons()
        },
        _dispose: function() {
            clearTimeout(this._slideshowTimer);
            this.callBase()
        },
        _handleSelectedIndexChanged: function() {
            if (!this._suppressRenderItemPositions)
                this._renderItemPositions();
            this._suppressRenderItemPositions = false;
            this._renderSelectedIndicatorItem();
            this._renderNavButtonsVisibility()
        },
        _optionChanged: function(name, value, prevValue) {
            switch (name) {
                case"animationDuration":
                case"loop":
                    this._renderNavButtonsVisibility();
                    return;
                case"selectedIndex":
                    this._handleSelectedIndexChanged();
                    return;
                case"showIndicator":
                    this._renderIndicator();
                    return;
                case"showNavButtons":
                    this._renderNavButtons();
                    return;
                case"slideshowDelay":
                    this._setupSlideShow();
                    return;
                case"swipeEnabled":
                case"indicatorEnabled":
                    this._renderUserInteraction();
                    return;
                default:
                    this.callBase(name, value, prevValue)
            }
        },
        goToItem: function(itemIndex, animation) {
            var d = new $.Deferred,
                selectedIndex = this.option("selectedIndex"),
                itemsCount = this._itemsCount();
            itemIndex = this._fitIndex(itemIndex);
            if (itemIndex > itemsCount - 1 || itemIndex < 0)
                return d.resolveWith(this).promise();
            var firstOffset = selectedIndex - itemIndex,
                secondOffset = selectedIndex + itemIndex - this._itemsCount(),
                offset = Math.abs(firstOffset) <= Math.abs(secondOffset) ? firstOffset : secondOffset;
            this._renderItemPositions(offset, animation).done(function() {
                this._suppressRenderItemPositions = true;
                this.option("selectedIndex", itemIndex);
                d.resolveWith(this)
            });
            return d.promise()
        },
        prevItem: function(animation) {
            return this.goToItem(this.option("selectedIndex") - 1, animation)
        },
        nextItem: function(animation) {
            return this.goToItem(this.option("selectedIndex") + 1, animation)
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.overlay.js

(function($, DX, undefined) {
    var ui = DX.ui,
        utils = DX.utils,
        RESET_TRANSITION_CLASS = 'dx-translate-disabled',
        DROPPED_CLASS = '.dx-scrollable-content, .dx-swipeable',
        OVERLAY_SHOW_EVENT_TOLERANCE = 50,
        ACTIONS = ["showingAction", "shownAction", "hiddingAction", "hiddenAction"];
    var defaultTargetContainer = ".dx-viewport";
    ui.registerComponent("dxOverlay", ui.ContainerWidget.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    activeStateEnabled: false,
                    visible: false,
                    shading: true,
                    closeOnOutsideClick: false,
                    position: {
                        my: "center",
                        at: "center",
                        of: window
                    },
                    animation: {
                        show: {
                            type: "pop",
                            duration: 400
                        },
                        hide: {
                            type: "pop",
                            to: {
                                opacity: 0,
                                scale: 0
                            },
                            from: {
                                opacity: 1,
                                scale: 1
                            },
                            duration: 400
                        }
                    },
                    showingAction: null,
                    shownAction: null,
                    hiddingAction: null,
                    hiddenAction: null,
                    width: function() {
                        return $(window).width() * 0.8
                    },
                    height: function() {
                        return $(window).height() * 0.8
                    },
                    targetContainer: undefined
                })
        },
        _init: function() {
            this.callBase();
            this._actions = {};
            this._deferredAnimate = undefined;
            this._attachCloseOnOutsideClickHandler();
            this._windowResizeCallback = $.proxy(this._refresh, this);
            utils.windowResizeCallbacks.add(this._windowResizeCallback)
        },
        _initOptions: function(options) {
            this._setTarget(options.targetContainer);
            this._setPositionOf(this._target);
            this.callBase(options)
        },
        _setTarget: function(targetContainer) {
            targetContainer = targetContainer !== undefined ? targetContainer : defaultTargetContainer;
            var element = this.rootElement() || this._element,
                $target = element.closest(targetContainer);
            this._target = $target.length ? $target : element.parent()
        },
        _setPositionOf: function(target) {
            this.option("position.of", target)
        },
        _attachCloseOnOutsideClickHandler: function() {
            var self = this,
                clickEventName = self._eventHelper.eventName("click");
            $(document).on(clickEventName, function(e) {
                var closeOnOutsideClick = self.option("closeOnOutsideClick"),
                    visible = self.option("visible");
                if (closeOnOutsideClick && visible) {
                    var contentDomElement = self._element.get(0),
                        outsideClick = e.target !== contentDomElement && !$.contains(contentDomElement, e.target),
                        showingEvent = Math.abs(e.timeStamp - self._showTimestamp) < OVERLAY_SHOW_EVENT_TOLERANCE;
                    if (outsideClick && !showingEvent)
                        self.hide()
                }
            })
        },
        _render: function() {
            this._wrapper = this._element.wrap("<div />").parent();
            this.callBase();
            this.rootElement().addClass("dx-overlay");
            this._element.addClass("dx-overlay-content");
            this._needRenderOnShow = true;
            this._refresh();
            this._renderActions()
        },
        _refresh: function() {
            this._wrapper.toggleClass("dx-overlay-modal dx-overlay-shader", this.option("shading"));
            this._renderDimensions();
            this._renderVisibility()
        },
        _renderActions: function() {
            var self = this;
            $.each(ACTIONS, function(index, itemAction) {
                self._actions[itemAction] = self._createActionByOption(itemAction)
            })
        },
        _dispose: function() {
            DX.fx.stop(this._element);
            utils.windowResizeCallbacks.remove(this._windowResizeCallback);
            this.callBase()
        },
        _renderContent: function() {
            this._templates.template.render(this._element);
            this._moveToTargetContainer()
        },
        _moveToTargetContainer: function() {
            if (!this._target)
                return;
            this._wrapper.appendTo(this._target)
        },
        _renderContentIfNeed: function() {
            if (this._needRenderOnShow) {
                this._renderContent();
                this._needRenderOnShow = false
            }
        },
        rootElement: function() {
            return this._wrapper
        },
        _renderDimensions: function() {
            this._element.width(this.option("width")).height(this.option("height"))
        },
        _renderVisibility: function() {
            var visible = this.option("visible");
            DX.fx.stop(this._element, true);
            if (visible) {
                this._renderContentIfNeed();
                this._renderPosition()
            }
            this._toggleVisibility(visible)
        },
        _renderVisibilityAnimate: function() {
            var visible = this.option("visible");
            if (visible)
                this._showTimestamp = $.now();
            DX.fx.stop(this._element, true);
            if (visible)
                this._makeVisible();
            else
                this._makeHidden()
        },
        _makeVisible: function() {
            var self = this,
                animation = self.option("animation") || {};
            self._actions.showingAction();
            self._renderContentIfNeed();
            self._renderPosition();
            self._toggleVisibility(true);
            if (animation.show) {
                var animationComplete = animation.show.complete || $.noop;
                self._animate($.extend({}, animation.show, {complete: function() {
                        animationComplete();
                        self._notifyShowComplete()
                    }}))
            }
            else
                self._notifyShowComplete()
        },
        _makeHidden: function() {
            var self = this,
                animation = this.option("animation") || {};
            self._actions.hiddingAction();
            if (animation.hide) {
                var animationComplete = animation.hide.complete || $.noop;
                self._animate($.extend({}, animation.hide, {complete: function() {
                        self._toggleVisibility(false);
                        animationComplete();
                        self._cleanupAnimation().done(function() {
                            self._notifyHideComplete()
                        })
                    }}))
            }
            else {
                self._toggleVisibility(false);
                self._notifyHideComplete()
            }
        },
        _notifyShowComplete: function() {
            this._actions.shownAction();
            if (this._deferredAnimate)
                this._deferredAnimate.resolveWith(this)
        },
        _notifyHideComplete: function() {
            this._actions.hiddenAction();
            if (this._deferredAnimate)
                this._deferredAnimate.resolveWith(this)
        },
        _renderPosition: function() {
            this.rootElement().show();
            if (this.option("shading")) {
                DX.position(this.rootElement(), {
                    my: "top left",
                    at: "top left",
                    of: this._target
                });
                this.rootElement().css({
                    width: this._target.outerWidth(),
                    height: this._target.outerHeight()
                })
            }
            DX.position(this._element, this.option("position"))
        },
        _cleanupAnimation: function() {
            var animation = this.option("animation"),
                to;
            if (!animation)
                return $.Deferred().resolve();
            to = animation.hide && animation.hide.from || animation.show && animation.show.to;
            if (to)
                return DX.fx.animate(this._element, {
                        duration: 0,
                        type: animation.hide.type,
                        to: to
                    });
            return $.Deferred().resolve()
        },
        _toggleVisibility: function(visible) {
            this.rootElement().toggle(visible);
            this.rootElement().toggleClass("dx-overlay-shader", this.option("shading") && visible)
        },
        _animate: function(animation) {
            if ($.isPlainObject(animation))
                DX.fx.animate(this._element, animation)
        },
        _optionChanged: function(name, value) {
            if (name === "visible")
                this._renderVisibilityAnimate();
            else if ($.inArray(name, ACTIONS) > -1)
                this._renderActions();
            else if (name === "targetContainer") {
                this._setTarget(value);
                this._moveToTargetContainer();
                this._refresh()
            }
            else if (name !== "closeOnOutsideClick")
                this._refresh()
        },
        toggle: function(showing) {
            showing = showing === undefined ? !this.option("visible") : showing;
            if (showing === this.option("visible"))
                return $.Deferred().resolve().promise();
            this._deferredAnimate = $.Deferred();
            this.option("visible", showing);
            return this._deferredAnimate.promise()
        },
        show: function() {
            return this.toggle(true)
        },
        hide: function() {
            return this.toggle(false)
        },
        content: function() {
            return this._element
        }
    }));
    ui.dxOverlay.defaultTargetContainer = function(targetContainer) {
        if (arguments.length)
            defaultTargetContainer = targetContainer;
        return defaultTargetContainer
    }
})(jQuery, DevExpress);

// Module widgets, file ui.toast.js

(function($, DX, undefined) {
    var ui = DX.ui,
        WIDGET_NAME = "dxToast",
        toastTypes = ["info", "warning", "error", "success"];
    ui.registerComponent(WIDGET_NAME, ui.dxOverlay.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    message: "",
                    type: "info",
                    displayTime: 2000,
                    position: {
                        my: "bottom center",
                        at: "bottom center",
                        of: window,
                        offset: "0 -20"
                    },
                    animation: {
                        show: {
                            type: "fade",
                            duration: 400,
                            to: 1
                        },
                        hide: {
                            type: "fade",
                            duration: 400,
                            to: 0
                        }
                    },
                    shading: false,
                    height: "auto"
                })
        },
        _setPositionOf: $.noop,
        _renderContent: function() {
            if (this.option("message"))
                $("<div>").addClass("dx-toast-message").text(this.option("message")).appendTo(this._element);
            if ($.inArray(this.option("type"), toastTypes) > -1)
                this._element.prepend($("<div>").addClass("dx-toast-icon"));
            this.callBase()
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass("dx-toast");
            this._element.addClass("dx-toast-content dx-toast-" + String(this.option("type")).toLowerCase()).css("opacity", 0)
        },
        _renderVisibilityAnimate: function() {
            this.callBase.apply(this, arguments);
            if (this.option("visible")) {
                clearTimeout(this._hideTimeout);
                this._hideTimeout = setTimeout($.proxy(function() {
                    this.hide()
                }, this), this.option("displayTime"))
            }
        },
        _dispose: function() {
            clearTimeout(this._hideTimeout);
            this.callBase()
        },
        _optionChanged: function(name, value, prevValue) {
            if (name === "type") {
                this._element.removeClass("dx-toast-" + prevValue);
                this._element.addClass("dx-toast-" + String(value).toLowerCase());
                return
            }
            this.callBase.apply(this, arguments)
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.popup.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var POPUP_CLASS = "dx-popup",
        POPUP_CONTENT_CLASS = POPUP_CLASS + "-content",
        POPUP_FULL_SCREEN_CLASS = POPUP_CLASS + "-fullscreen",
        POPUP_TITLE_CLASS = POPUP_CLASS + "-title";
    ui.registerComponent("dxPopup", ui.dxOverlay.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    title: "",
                    showTitle: true,
                    fullScreen: false
                })
        },
        _init: function() {
            this.callBase()
        },
        _render: function() {
            this.callBase();
            this._element.toggleClass(POPUP_FULL_SCREEN_CLASS, this.option("fullScreen"));
            this._content = this._element.wrapInner($("<div />").addClass(POPUP_CONTENT_CLASS)).children().eq(0);
            this._setTitle();
            this.rootElement().addClass(POPUP_CLASS)
        },
        _setTitle: function() {
            var $title = this.rootElement().find("." + POPUP_TITLE_CLASS);
            if (this.option("showTitle") && !$title.length) {
                this._title = $("<div />").addClass(POPUP_TITLE_CLASS);
                this._element.prepend(this._title);
                this._renderTitle()
            }
            else if ($title.length)
                $title.remove()
        },
        _renderContent: function() {
            var contentTemplate = this._templates.content || this._templates.template;
            contentTemplate.render(this._content);
            this._moveToTargetContainer()
        },
        _renderDimensions: function() {
            if (this.option("fullScreen"))
                this._element.css({
                    width: "100%",
                    height: "100%"
                });
            else
                this.callBase()
        },
        _renderPosition: function() {
            if (this.option("fullScreen"))
                this._element.position(0, 0);
            else
                this.callBase()
        },
        _renderTitle: function() {
            if (!this.option("showTitle"))
                return;
            var titleTemplate = this._templates.title;
            if (titleTemplate)
                titleTemplate.render(this._title);
            else
                this._defaultTitleRender()
        },
        _defaultTitleRender: function() {
            this._title.text(this.option("title"))
        },
        _optionChanged: function(name, value) {
            switch (name) {
                case"showTitle":
                    this._setTitle();
                    break;
                case"title":
                    this._renderTitle();
                    break;
                case"fullScreen":
                    this._element.toggleClass(POPUP_FULL_SCREEN_CLASS, value);
                    this.callBase.apply(this, arguments);
                    break;
                default:
                    this.callBase.apply(this, arguments)
            }
        },
        content: function() {
            return this._content
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.loadIndicator.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var LOADINDICATOR_CLASS = "dx-loadindicator",
        LOADINDICATOR_WRAPPER = LOADINDICATOR_CLASS + "-wrapper",
        LOADINDICATOR_ICON = LOADINDICATOR_CLASS + "-icon",
        LOADINDICATOR_SEGMENT = LOADINDICATOR_CLASS + "-segment",
        LOADINDICATOR_SEGMENT_N = LOADINDICATOR_CLASS + "-segment",
        LOADINDICATOR_SEGMENT_WIN8 = LOADINDICATOR_CLASS + "-win8-segment",
        LOADINDICATOR_SEGMENT_N_WIN8 = LOADINDICATOR_CLASS + "-win8-segment",
        LOADINDICATOR_INNER_SEGMENT_WIN8 = LOADINDICATOR_CLASS + "-win8-inner-segment",
        LOADINDICATOR_IMAGE = LOADINDICATOR_CLASS + "-image",
        LOADINDICATOR_SIZES = ["small", "medium", "large"];
    ui.registerComponent("dxLoadIndicator", ui.Widget.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    visible: true,
                    size: ""
                })
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass(LOADINDICATOR_CLASS);
            this._setSize();
            if (DX.support.animation)
                this._renderMarkupForAnimation();
            else
                this._renderMarkupForImage()
        },
        _renderMarkupForAnimation: function() {
            var indicator = $("<div>").addClass(LOADINDICATOR_ICON);
            indicator.append($("<div>").addClass(LOADINDICATOR_SEGMENT).addClass(LOADINDICATOR_SEGMENT_N + "0"));
            for (var i = 15; i > 0; --i)
                indicator.append($("<div>").addClass(LOADINDICATOR_SEGMENT).addClass(LOADINDICATOR_SEGMENT_N + i));
            for (var i = 1; i <= 5; ++i)
                indicator.append($("<div>").addClass(LOADINDICATOR_SEGMENT_WIN8).addClass(LOADINDICATOR_SEGMENT_N_WIN8 + i).append($("<div>").addClass(LOADINDICATOR_INNER_SEGMENT_WIN8)));
            $("<div>").addClass(LOADINDICATOR_WRAPPER).append(indicator).appendTo(this.rootElement())
        },
        _renderMarkupForImage: function() {
            var size = this.option("size");
            if (size === "small" || size === "large")
                this.rootElement().addClass(LOADINDICATOR_IMAGE + "-" + size);
            else
                this.rootElement().addClass(LOADINDICATOR_IMAGE)
        },
        _setSize: function() {
            var size = this.option("size");
            if (size && $.inArray(size, LOADINDICATOR_SIZES) !== -1)
                this.rootElement().addClass(LOADINDICATOR_CLASS + "-" + size)
        },
        _optionChanged: function(name) {
            switch (name) {
                case"size":
                    this._setSize();
                    break;
                default:
                    this.callBase.apply(this, arguments)
            }
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.loadPanel.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var LOADINDICATOR_CLASS = "dx-loadpanel",
        LOADINDICATOR_IMAGE_CLASS = "dx-loadpanel-image",
        LOADINDICATOR_MESSAGE_CLASS = "dx-loadpanel-message",
        LOADINDICATOR_CONTENT_CLASS = "dx-loadpanel-content";
    ui.registerComponent("dxLoadPanel", ui.dxOverlay.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    message: "Loading...",
                    width: 200,
                    height: 70,
                    animation: null
                })
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass(LOADINDICATOR_CLASS);
            var image = $("<div>").dxLoadIndicator();
            var message = $("<div>").addClass(LOADINDICATOR_MESSAGE_CLASS).text(this.option("message"));
            this.content().addClass(LOADINDICATOR_CONTENT_CLASS).append(image).append(message)
        },
        _optionChanged: function(name, value) {
            switch (name) {
                case"message":
                    this.content().find("." + LOADINDICATOR_MESSAGE_CLASS).text(value);
                    break;
                default:
                    this.callBase.apply(this, arguments)
            }
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.lookup.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var LOOKUP_CLASS = "dx-lookup",
        LOOKUP_SELECTED_CLASS = LOOKUP_CLASS + "-selected",
        LOOKUP_SEARCH_CLASS = LOOKUP_CLASS + "-search",
        LOOKUP_FIELD_CLASS = LOOKUP_CLASS + "-field",
        LOOKUP_POPUP_CLASS = LOOKUP_CLASS + "-popup",
        LOOKUP_POPUP_SEARCH_CLASS = LOOKUP_POPUP_CLASS + "-search",
        TOOLBAR_LEFT_CLASS = "dx-toolbar-left",
        LIST_ITEM_SELECTOR = ".dx-list-item",
        LIST_ITEM_DATA_KEY = "dxListItemData",
        POPUP_HIDE_TIMEOUT = 200;
    ui.registerComponent("dxLookup", ui.Widget.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    dataSource: null,
                    items: null,
                    value: undefined,
                    displayValue: undefined,
                    title: "",
                    valueExpr: null,
                    displayExpr: "this",
                    placeholder: "Select...",
                    searchEnabled: true,
                    searchTimeout: 1000,
                    minFilterLength: 0,
                    fullScreen: false,
                    valueChangeAction: null
                })
        },
        _init: function() {
            this.callBase();
            this._initDataSource();
            this._checkExceptions();
            this._searchTimer = null;
            this._compileValueGetter();
            this._compileDisplayGetter();
            if (this._dataSource)
                this._dataSourceOriginalFilter = this._dataSource.filter();
            else
                this._itemsToDataSource()
        },
        _checkExceptions: function() {
            if (this._dataSource && this._dataSource._mapFunc)
                throw Error("Data source with enabled map is not allowed in the lookup");
            if (this.option("minFilterLength") && this.option("value") && typeof this.option("displayValue") !== "string")
                throw Error("The displayValue option is required when minFilterLength is set");
        },
        _render: function() {
            this.callBase();
            this._element.addClass(LOOKUP_CLASS);
            this._renderField();
            this._calcSelectedItem($.proxy(function() {
                this._setFieldText()
            }, this));
            this._renderPopup();
            this._renderSearch();
            this._renderList();
            this._renderCancel()
        },
        _renderField: function() {
            var fieldClickAction = this._createAction(this._handleFieldClick);
            this._field = $("<div/>").addClass(LOOKUP_FIELD_CLASS).appendTo(this._element).on(this._eventHelper.eventName("click"), function(e) {
                fieldClickAction({jQueryEvent: e})
            })
        },
        _renderPopup: function() {
            this._popup = $("<div/>").addClass(LOOKUP_POPUP_CLASS).toggleClass(LOOKUP_POPUP_SEARCH_CLASS, this.option("searchEnabled")).appendTo(this._element).dxPopup({
                title: this.option("title"),
                fullScreen: this.option("fullScreen")
            }).data("dxPopup")
        },
        _renderSearch: function() {
            this._search = $("<div/>").addClass(LOOKUP_SEARCH_CLASS).dxTextbox({
                mode: "search",
                placeholder: "Search",
                valueUpdateEvent: "change keypress paste focus textInput input",
                valueUpdateAction: $.proxy(this._searchChangedHandler, this)
            }).toggle(this.option("searchEnabled")).appendTo(this._popup.content())
        },
        _renderList: function() {
            var self = this;
            self._list = $("<div/>").appendTo(self._popup.content()).dxList({
                dataSource: null,
                itemClickAction: function(e) {
                    self._toggleSelectedClass(e.jQueryEvent);
                    self._updateOptions(e)
                },
                itemRender: $.proxy(self._displayGetter, self),
                itemRenderedAction: function(e) {
                    self._setSelectedClass(e.itemElement, e.itemData)
                }
            }).data("dxList")
        },
        _renderCancel: function() {
            var button = $("<div/>").dxButton({
                    text: "Cancel",
                    clickAction: $.proxy(function() {
                        this._hidePopup()
                    }, this)
                });
            if (DX.devices.current().ios)
                $("<div />").addClass(TOOLBAR_LEFT_CLASS).appendTo(this._popup._title).prepend(button);
            else
                button.appendTo(this._popup.content())
        },
        _toggleSelectedClass: function(e) {
            var selectedItem = this.rootElement().find("." + LOOKUP_SELECTED_CLASS);
            $(e.target).closest(LIST_ITEM_SELECTOR).addClass(LOOKUP_SELECTED_CLASS);
            selectedItem.removeClass(LOOKUP_SELECTED_CLASS)
        },
        _hidePopup: function() {
            this._popup.hide()
        },
        _updateOptions: function(e) {
            this.option("value", this._valueGetter(e.itemData));
            setTimeout($.proxy(this._hidePopup, this), POPUP_HIDE_TIMEOUT);
            this._setFieldText(this._displayGetter(e.itemData))
        },
        _handleFieldClick: function(args) {
            var self = args.component;
            self._setListDataSource();
            self._popup.show()
        },
        _getValueGetterExpr: function() {
            return this.option("valueExpr") || this._dataSource && this._dataSource._store._key || "this"
        },
        _compileValueGetter: function() {
            this._valueGetter = DX.data.utils.compileGetter(this._getValueGetterExpr())
        },
        _compileDisplayGetter: function() {
            this._displayGetter = DX.data.utils.compileGetter(this.option("displayExpr"))
        },
        _itemsToDataSource: function() {
            this._dataSource = new DX.data.ArrayStore(this.option("items")).toDataSource({paginate: false})
        },
        _optionChanged: function(name) {
            var self = this;
            switch (name) {
                case"value":
                    this._checkExceptions();
                    this._calcSelectedItem(function() {
                        self._createActionByOption("valueChangeAction")({selectedItem: self._selectedItem});
                        self._compileValueGetter();
                        self._compileDisplayGetter();
                        self._refreshSelected();
                        self._setFieldText();
                        self._doSearch()
                    });
                    break;
                case"valueExpr":
                    this._compileValueGetter();
                    this._compileDisplayGetter();
                    this._refreshSelected();
                    this._setFieldText();
                    this._doSearch();
                    break;
                case"displayExpr":
                    if (name === "displayExpr") {
                        this._compileDisplayGetter();
                        this._list.option("itemRender", $.proxy(this._displayGetter, this))
                    }
                    this._refreshSelected();
                    this._setFieldText();
                    this._doSearch();
                    break;
                case"displayValue":
                    this._checkExceptions();
                    this._setFieldText();
                    break;
                case"items":
                case"dataSource":
                    if (name === "items")
                        this._itemsToDataSource();
                    else {
                        this._checkExceptions();
                        this._initDataSource()
                    }
                    this._setListDataSource(true);
                    if (this._dataSource)
                        this._dataSourceOriginalFilter = this._dataSource.filter();
                    this._compileValueGetter();
                    var self = this;
                    this._calcSelectedItem(function() {
                        self._setFieldText();
                        self._doSearch()
                    });
                    break;
                case"searchEnabled":
                    this._search.toggle(this.option("searchEnabled"));
                    this._popup.content().toggleClass(LOOKUP_POPUP_SEARCH_CLASS, this.option("searchEnabled"));
                    this._doSearch();
                    break;
                case"minFilterLength":
                    this._checkExceptions();
                    this._setListDataSource();
                    this._setFieldText();
                    this._searchChangedHandler();
                    break;
                case"placeholder":
                    this._setFieldText();
                    break;
                case"title":
                    this._popup.option("title", this.option("title"));
                    break;
                case"fullScreen":
                    this._popup.option("fullScreen", this.option("fullScreen"));
                    break
            }
        },
        _setListDataSource: function(force) {
            var needsToLoad = this._search.data("dxTextbox").option("value").length >= this.option("minFilterLength"),
                dataSourceLoaded = !!this._list.option("dataSource"),
                skip = needsToLoad === dataSourceLoaded;
            if (!force && skip)
                return;
            this._list.option("dataSource", needsToLoad ? this._dataSource : null);
            if (!needsToLoad)
                this._list.option("items", undefined)
        },
        _handleDataSourceChanged: function(items) {
            var self = this;
            this._calcSelectedItem(function() {
                self._setFieldText()
            })
        },
        _clean: function() {
            if (this._popup)
                this._popup.rootElement().remove();
            this.callBase()
        },
        _dispose: function() {
            clearTimeout(this._searchTimer);
            if (this._dataSource)
                this._dataSource.filter(this._dataSourceOriginalFilter);
            this.callBase()
        },
        _searchChangedHandler: function() {
            var searchValue = this._search.data("dxTextbox").option("value"),
                needsToLoad = searchValue.length >= this.option("minFilterLength");
            clearTimeout(this._searchTimer);
            this._setListDataSource();
            if (!needsToLoad)
                return;
            if (this.option("searchTimeout"))
                this._searchTimer = setTimeout($.proxy(this._doSearch, this, searchValue), this.option("searchTimeout"));
            else
                this._doSearch(searchValue)
        },
        _doSearch: function(searchValue) {
            if (!this._dataSource)
                return;
            if (!arguments.length)
                searchValue = this.option("searchEnabled") ? this._search.data("dxTextbox").option("value") : "";
            this._filterStore(searchValue);
            this._list.update(true)
        },
        _filterStore: function(searchValue) {
            this._dataSource.reload({
                searchString: searchValue,
                searchField: this.option("displayExpr")
            })
        },
        _setFieldText: function(text) {
            if (arguments.length) {
                this._field.text(text);
                return
            }
            if (this.option("minFilterLength")) {
                this._field.text(this.option("displayValue"));
                return
            }
            if (this.option("value") === undefined || !this._dataSource) {
                this._field.text(this.option("placeholder"));
                return
            }
            this._field.text(this._displayGetter(this._selectedItem) || this.option("placeholder"))
        },
        _calcSelectedItem: function(callback) {
            var self = this,
                value = self.option("value");
            if (!self._dataSource || value === undefined) {
                self._selectedItem = undefined;
                callback();
                return
            }
            if (value === self._valueGetter(self._selectedItem)) {
                callback();
                return
            }
            self._dataSource.lookup({
                key: value,
                lookupExpression: self._getValueGetterExpr(),
                lookupGetter: self._valueGetter
            }).done(function(result) {
                self._selectedItem = result;
                callback()
            })
        },
        _refreshSelected: function() {
            var self = this;
            $.each(this._list._element.find(LIST_ITEM_SELECTOR), function() {
                var item = $(this);
                self._setSelectedClass(item, item.data(LIST_ITEM_DATA_KEY))
            })
        },
        _setSelectedClass: function(item, itemData) {
            var selected = this._valueGetter(itemData) === this.option("value");
            item.toggleClass(LOOKUP_SELECTED_CLASS, selected)
        }
    }).include(ui.DataHelperMixin))
})(jQuery, DevExpress);

// Module widgets, file ui.actionSheet.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var ACTION_SHEET_CLASS = "dx-action-sheet",
        ACTION_SHEET_CONTAINER_CLASS = "dx-action-sheet-container",
        ACTION_SHEET_POPUP_CLASS = "dx-action-sheet-popup",
        ACTION_SHEET_CANCEL_BUTTON_CLASS = "dx-action-sheet-cancel",
        ACTION_SHEET_ITEM_CLASS = "dx-action-sheet-item",
        POPUP_TITLE_SELECTOR = ".dx-popup-title",
        ACTION_SHEET_ITEM_DATA_KEY = "dxActionSheetItemData";
    ui.registerComponent("dxActionSheet", ui.CollectionContainerWidget.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    title: "",
                    showTitle: true,
                    cancelText: "Cancel",
                    noDataText: ""
                })
        },
        _init: function() {
            this.callBase();
            this._itemContainerElement = $("<div/>").addClass(ACTION_SHEET_CONTAINER_CLASS);
            this.rootElement().addClass(ACTION_SHEET_CLASS)
        },
        _clean: function() {
            if (this._popup)
                this._popup.rootElement().remove();
            this.callBase()
        },
        _render: function() {
            this._popup = this._renderPopup();
            this._popup.content().append(this._itemContainerElement);
            this._cancel = this._renderCancel();
            this._popupTitle = $(POPUP_TITLE_SELECTOR, this.rootElement()).toggle(this.option("showTitle"));
            this.callBase()
        },
        _renderPopup: function() {
            return $("<div/>").addClass(ACTION_SHEET_POPUP_CLASS).appendTo(this.rootElement()).dxPopup({
                    title: this.option("title"),
                    position: {
                        my: "bottom",
                        at: "bottom",
                        of: window
                    },
                    animation: {
                        show: {
                            type: "slide",
                            duration: 400,
                            from: {top: $("body").height()}
                        },
                        hide: {
                            type: "slide",
                            duration: 400,
                            to: {top: $("body").height()}
                        }
                    },
                    width: "100%",
                    height: "auto"
                }).data("dxPopup")
        },
        _renderCancel: function() {
            return $("<div/>").addClass(ACTION_SHEET_CANCEL_BUTTON_CLASS).appendTo(this._popup.content()).dxButton({
                    text: this.option("cancelText"),
                    clickAction: $.proxy(this.hide, this)
                }).data("dxButton")
        },
        _itemRenderDefault: function(item, index, itemElement) {
            itemElement.dxButton(item)
        },
        _itemContainer: function() {
            return this._itemContainerElement
        },
        _itemClass: function() {
            return ACTION_SHEET_ITEM_CLASS
        },
        _itemDataKey: function() {
            return ACTION_SHEET_ITEM_DATA_KEY
        },
        _optionChanged: function(name, value) {
            switch (name) {
                case"title":
                    this._popup.option("title", value);
                    break;
                case"showTitle":
                    this._popupTitle.toggle(value);
                    break;
                case"cancelText":
                    this._cancel.option("text", value);
                default:
                    this.callBase.apply(this, arguments)
            }
        },
        show: function() {
            var self = this,
                deferred = $.Deferred();
            self._popup.show().done(function() {
                deferred.resolveWith(self)
            });
            return deferred.promise()
        },
        hide: function() {
            var self = this,
                deferred = $.Deferred();
            self._popup.hide().done(function() {
                deferred.resolveWith(self)
            });
            return deferred.promise()
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.maps.js

(function($, DX, undefined) {
    var ui = DX.ui,
        utils = DX.utils,
        mapsInit = {},
        mapsHash = {},
        winJS = DX.support.winJS,
        _googleScriptReady = "_googleScriptReady",
        GOOGLE_URL = "https://maps.google.com/maps/api/js?v=3.9&sensor=false&callback=" + _googleScriptReady,
        _bingScriptReady = "_bingScriptReady",
        BING_URL = "https://ecn.dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=7.0&s=1&onScriptLoad=" + _bingScriptReady,
        BING_LOCATOR_URL = "https://dev.virtualearth.net/REST/v1/Locations/",
        GOOGLE_STATIC_URL = "https://maps.google.com/maps/api/staticmap?",
        BING_LOCAL_FILES1 = "ms-appx:///Bing.Maps.JavaScript/js/veapicore.js",
        BING_LOCAL_FILES2 = "ms-appx:///Bing.Maps.JavaScript/js/veapiModules.js",
        BING_CREDENTIALS = "AhuxC0dQ1DBTNo8L-H9ToVMQStmizZzBJdraTSgCzDSWPsA1Qd8uIvFSflzxdaLH";
    var compare_objects = function(x, y) {
            if (x === y)
                return true;
            if (!(x instanceof Object) || !(y instanceof Object))
                return false;
            if (x.constructor !== y.constructor)
                return false;
            for (var p in x) {
                if (!x.hasOwnProperty(p))
                    continue;
                if (!y.hasOwnProperty(p))
                    return false;
                if (x[p] === y[p])
                    continue;
                if (typeof x[p] !== "object")
                    return false;
                if (!compare_objects(x[p], y[p]))
                    return false
            }
            for (p in y)
                if (y.hasOwnProperty(p) && !x.hasOwnProperty(p))
                    return false;
            return true
        };
    ui.registerComponent("dxMaps", ui.Widget.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    location: {
                        lat: 0,
                        lng: 0
                    },
                    width: 300,
                    height: 300,
                    zoom: 1,
                    mapType: "roadmap",
                    provider: "google",
                    markers: [],
                    routes: []
                })
        },
        _init: function() {
            this.callBase();
            utils.windowResizeCallbacks.add(this._wrappedRenderMapHandle = $.proxy(this._renderMapHandle, this))
        },
        _clean: function() {
            var eventHelper = this._eventHelper;
            this.mapAdapter._clean();
            this.rootElement().removeClass("dx-map").off(eventHelper.eventName("start"), this._removeGestures).empty()
        },
        _dispose: function() {
            this.callBase();
            utils.windowResizeCallbacks.remove(this._wrappedRenderMapHandle)
        },
        _removeGestures: function(e) {
            if (e.button === 0 && !DX.designMode)
                return false
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass("dx-maps");
            if (this.option("width"))
                this.rootElement().css("width", this.option("width"));
            if (this.option("height"))
                this.rootElement().css("height", this.option("height"));
            this._renderMapContainer();
            this._renderShield();
            var provider = winJS && this.option("provider") === "google" ? "bing" : this.option("provider");
            this.mapAdapter = new adapters[provider](this._mapContainer, this._options);
            var eventHelper = this._eventHelper;
            this.rootElement().on(eventHelper.eventName("start"), $.proxy(this._removeGestures, this));
            this._initMap()
        },
        _initMap: function() {
            return this.mapAdapter._initMap()
        },
        _renderMapContainer: function() {
            this._mapContainer = $("<div />").addClass("dx-maps-container").appendTo(this.rootElement())
        },
        _renderShield: function() {
            if (!DX.designMode)
                return;
            $("<div />").addClass("dx-maps-shield").appendTo(this.rootElement())
        },
        _optionChanged: function(name, value, prevValue) {
            switch (name) {
                case"markers":
                    this.mapAdapter._renderMarkers(value, prevValue);
                    break;
                case"routes":
                    this.mapAdapter._renderRoutes(value, prevValue);
                    break;
                default:
                    this.callBase(name, value, prevValue)
            }
        },
        _renderMapHandle: function() {
            if (this.mapAdapter._renderMapHandle)
                this.mapAdapter._renderMapHandle()
        },
        addMarker: function() {
            var self = this,
                deferred = $.Deferred();
            self.mapAdapter.addMarker.apply(self.mapAdapter, arguments).done(function() {
                deferred.resolveWith(self)
            });
            return deferred.promise()
        },
        removeMarker: function() {
            this.mapAdapter.removeMarker.apply(this.mapAdapter, arguments)
        },
        addRoute: function() {
            var self = this,
                deferred = $.Deferred();
            self.mapAdapter.addRoute.apply(self.mapAdapter, arguments).done(function() {
                deferred.resolveWith(self)
            });
            return deferred.promise()
        },
        removeRoute: function() {
            this.mapAdapter.removeRoute.apply(this.mapAdapter, arguments)
        }
    }));
    var adapters = ui.dxMaps.adapters = {},
        protoAdapter = DX.Class.inherit({
            ctor: function(rootElement, options) {
                this.rootElement = rootElement;
                this._options = options;
                this.map = null;
                this._markers = [];
                this._routes = []
            },
            _renderMarkers: function(newValue, oldValue) {
                var self = this,
                    markers = self._options.markers;
                newValue = newValue || markers || [];
                oldValue = oldValue || self._markers || [];
                if (!self.map)
                    return;
                $.each(oldValue, function() {
                    self.removeMarker(this)
                });
                self._markers = [];
                $.each(newValue, function() {
                    self.addMarker(this)
                })
            },
            _renderRoutes: function(newValue, oldValue) {
                var self = this,
                    routes = self._options.routes;
                newValue = newValue || routes || [];
                oldValue = oldValue || self._routes || [];
                if (!self.map)
                    return;
                $.each(oldValue, function() {
                    self.removeRoute(this)
                });
                self._routes = [];
                $.each(newValue, function() {
                    self.addRoute(this)
                })
            },
            _clean: function() {
                this._routes = [];
                this._markers = [];
                this.map = null
            }
        });
    adapters.google = protoAdapter.inherit({
        _getMapType: function(type) {
            var mapTypes = {
                    hybrid: google.maps.MapTypeId.HYBRID,
                    roadmap: google.maps.MapTypeId.ROADMAP,
                    satellite: google.maps.MapTypeId.SATELLITE,
                    terrain: google.maps.MapTypeId.TERRAIN
                };
            return mapTypes[type] || mapTypes.roadmap
        },
        _initMap: function() {
            if (!mapsInit.google) {
                window[_googleScriptReady] = $.proxy(this._scriptReady, this);
                $.getScript(GOOGLE_URL);
                mapsInit.google = new $.Deferred
            }
            mapsInit.google.done($.proxy(this._renderMap, this));
            return mapsInit.google
        },
        _scriptReady: function() {
            try {
                delete window[_googleScriptReady]
            }
            catch(e) {
                window[_googleScriptReady] = undefined
            }
            mapsInit.google.resolve()
        },
        _renderMap: function() {
            var self = this,
                locationResolved = self._resolveLocation(self._options.location);
            var options = {
                    zoom: self._options.zoom,
                    center: new google.maps.LatLng(0, 0),
                    mapTypeId: self._getMapType(self._options.mapType)
                };
            self.map = new google.maps.Map(self.rootElement[0], options);
            self._bounds = new google.maps.LatLngBounds;
            self._renderRoutes();
            self._renderMarkers();
            $.when(locationResolved).done(function(location) {
                self.map.setCenter(location)
            })
        },
        _renderMapHandle: function() {
            if ("google" in window)
                google.maps.event.trigger(this.map, 'resize')
        },
        _resolveLocation: function(location) {
            var d = $.Deferred();
            if (typeof location === "string") {
                if (!mapsHash.google)
                    mapsHash.google = {};
                if (mapsHash.google[location]) {
                    d.resolve(mapsHash.google[location]);
                    return d.promise()
                }
                var geocoder = new google.maps.Geocoder;
                geocoder.geocode({address: location}, function(results, status) {
                    if (status === google.maps.GeocoderStatus.OK) {
                        mapsHash.google[location] = results[0].geometry.location;
                        d.resolve(mapsHash.google[location])
                    }
                })
            }
            else if ($.isPlainObject(location) && location.lat && location.lng)
                d.resolve(new google.maps.LatLng(location.lat, location.lng));
            else if ($.isArray(location))
                d.resolve(new google.maps.LatLng(location[0], location[1]));
            return d.promise()
        },
        tooltipByMarker: function(marker) {
            var isConfig = $.isPlainObject(marker);
            var result = $.grep(this._markers, function(value) {
                    return isConfig ? marker === value.options : marker === value.instance
                })[0];
            if (result)
                return result.tooltip
        },
        addMarker: function(options, callback) {
            var self = this,
                map = google.maps,
                locationResolved = self._resolveLocation(options.location);
            return $.when(locationResolved).done(function(location) {
                    self._bounds.extend(location);
                    var tooltip,
                        marker = new map.Marker({
                            position: location,
                            map: self.map,
                            title: options.text
                        });
                    if (options.tooltip)
                        self.addTooltip(options.tooltip, marker, function(infoWindow) {
                            tooltip = infoWindow
                        });
                    if (options.click || tooltip)
                        map.event.addListener(marker, "click", function() {
                            var result = options.click ? options.click.call(self, marker) : true;
                            if (result !== false && tooltip)
                                tooltip.open(self.map, marker)
                        });
                    self.map.setCenter(self._bounds.getCenter());
                    self.map.fitBounds(self._bounds);
                    if (callback)
                        callback.call(self, marker);
                    self._markers.push({
                        instance: marker,
                        tooltip: tooltip,
                        options: options
                    })
                })
        },
        removeMarker: function(point) {
            var self = this;
            if ($.isPlainObject(point))
                $.each(self._markers, function(index) {
                    if (compare_objects(this.options, point) || compare_objects(this, point)) {
                        if (this.tooltip)
                            this.tooltip.setMap(null);
                        this.instance.setMap(null);
                        self._markers.splice(index, 1);
                        return false
                    }
                });
            else if ($.isNumeric(point) && self._markers[point]) {
                var marker = self._markers[point];
                if (marker.tooltip)
                    marker.tooltip.setMap(null);
                marker.instance.setMap(null);
                self._markers.splice(point, 1)
            }
        },
        addRoute: function(options, callback) {
            var self = this,
                map = google.maps,
                directionsService = new map.DirectionsService;
            var rawPoints = $.map(options.locations, function(point) {
                    return self._resolveLocation(point)
                });
            return $.when.apply(self, rawPoints).done(function() {
                    var latLongPoints = $.makeArray(arguments),
                        origin = latLongPoints.shift(),
                        destination = latLongPoints.pop();
                    var waypoints = $.map(latLongPoints, function(rawPoint) {
                            return {
                                    location: rawPoint,
                                    stopover: true
                                }
                        });
                    var request = {
                            origin: origin,
                            destination: destination,
                            waypoints: waypoints,
                            optimizeWaypoints: true,
                            provideRouteAlternatives: true,
                            travelMode: map.TravelMode.DRIVING
                        };
                    var route = new map.DirectionsRenderer({suppressMarkers: true});
                    route.setMap(self.map);
                    self._routes.push({
                        instance: route,
                        options: options
                    });
                    directionsService.route(request, function(response, status) {
                        if (status === map.DirectionsStatus.OK)
                            route.setDirections(response);
                        else
                            self.removeRoute(route);
                        if (callback)
                            callback.call(self, response)
                    })
                })
        },
        removeRoute: function(route) {
            var self = this;
            if ($.isPlainObject(route))
                $.each(self._routes, function(index) {
                    if (compare_objects(this.options, route)) {
                        this.instance.setMap(null);
                        self._routes.splice(index, 1);
                        return false
                    }
                });
            else if ($.isNumeric(route) && self._routes[route]) {
                self._routes[route].instance.setMap(null);
                self._routes.splice(route, 1)
            }
        },
        addTooltip: function(options, marker, callback) {
            var self = this,
                map = google.maps,
                tooltipOptions = typeof options === "string" ? {content: options} : options;
            var infoWindow = new map.InfoWindow({content: tooltipOptions.content});
            if (tooltipOptions.close)
                map.event.addListener(infoWindow, "closeclick", function() {
                    tooltipOptions.close.call(self, infoWindow)
                });
            if (tooltipOptions.opened)
                infoWindow.open(self.map, marker);
            else
                infoWindow.close();
            if (callback)
                callback.call(self, infoWindow)
        }
    });
    adapters.bing = protoAdapter.inherit({
        ctor: function(rootElement, options) {
            this.callBase(rootElement, options);
            BING_CREDENTIALS = options.credentials || BING_CREDENTIALS
        },
        _getMapType: function(type) {
            var mapTypes = {
                    roadmap: Microsoft.Maps.MapTypeId.road,
                    satellite: Microsoft.Maps.MapTypeId.birdseye
                };
            return mapTypes[type] || mapTypes.roadmap
        },
        _initMap: function() {
            if (!mapsInit.bing) {
                mapsInit.bing = new $.Deferred;
                window[_bingScriptReady] = $.proxy(this._scriptReady, this);
                if (!winJS)
                    $.getScript(BING_URL);
                else
                    $.when($.getScript(BING_LOCAL_FILES1), $.getScript(BING_LOCAL_FILES2)).done(function() {
                        Microsoft.Maps.loadModule('Microsoft.Maps.Map', {callback: window[_bingScriptReady]})
                    })
            }
            mapsInit.bing.done($.proxy(this._renderMap, this));
            return mapsInit.bing
        },
        _scriptReady: function() {
            try {
                delete window[_bingScriptReady]
            }
            catch(e) {
                window[_bingScriptReady] = undefined
            }
            mapsInit.bing.resolve()
        },
        _resolveLocation: function(location) {
            var d = $.Deferred();
            if (!mapsHash.bing)
                mapsHash.bing = {};
            if (typeof location === "string") {
                if (mapsHash.bing[location]) {
                    d.resolve(mapsHash.bing[location]);
                    return d.promise()
                }
                var url = BING_LOCATOR_URL + location + "?output=json&key=" + BING_CREDENTIALS;
                $.getJSON(winJS ? url : url + "&jsonp=?").done(function(result) {
                    var boundsBox = result.resourceSets[0].resources[0].geocodePoints[0].coordinates,
                        point = new Microsoft.Maps.Location(boundsBox[0], boundsBox[1]);
                    mapsHash.bing[location] = point;
                    d.resolve(point)
                })
            }
            else if ($.isPlainObject(location) && location.lat && location.lng)
                d.resolve(new Microsoft.Maps.Location(location.lat, location.lng));
            else if ($.isArray(location))
                d.resolve(new Microsoft.Maps.Location(location[0], location[1]));
            return d.promise()
        },
        _renderMap: function() {
            var self = this,
                locationResolved = self._resolveLocation(self._options.location);
            var options = {
                    zoom: self._options.zoom,
                    mapTypeId: self._getMapType(self._options.mapType),
                    credentials: BING_CREDENTIALS
                };
            self.map = new Microsoft.Maps.Map(self.rootElement[0], options);
            $.when(locationResolved).done(function(location) {
                self.map.setView({center: location})
            });
            self._renderMarkers();
            self._renderRoutes()
        },
        addMarker: function(options, callback) {
            var self = this,
                locationResolved = self._resolveLocation(options.location);
            return $.when(locationResolved).done(function(location) {
                    var pushpin = new Microsoft.Maps.Pushpin(location, null);
                    self.map.entities.push(pushpin);
                    if (callback)
                        callback.call(self, pushpin);
                    self._markers.push({
                        instance: pushpin,
                        options: options
                    })
                })
        },
        removeMarker: function(point) {
            var self = this;
            if ($.isPlainObject(point))
                $.each(self._markers, function(index) {
                    if (compare_objects(this.options, point)) {
                        self.map.entities.remove(this.instance);
                        self._markers.splice(index, 1);
                        return false
                    }
                });
            else if ($.isNumeric(point) && self._markers[point]) {
                self.map.entities.remove(self._markers[point].instance);
                self._markers.splice(point, 1)
            }
        },
        addRoute: function(options, callback) {
            var self = this,
                directions = Microsoft.Maps.Directions;
            if (!directions) {
                Microsoft.Maps.loadModule('Microsoft.Maps.Directions', {callback: function() {
                        self.addRoute.call(self, options, callback)
                    }});
                return false
            }
            var rawPoints = $.map(options.locations, function(point) {
                    return self._resolveLocation(point)
                });
            return $.when.apply(self, rawPoints).done(function() {
                    var latLongPoints = $.makeArray(arguments),
                        route = new directions.DirectionsManager(self.map);
                    route.setRequestOptions({
                        routeMode: directions.RouteMode.driving,
                        displayRouteSelector: false
                    });
                    $.each(latLongPoints, function() {
                        var m_point = new directions.Waypoint({location: this});
                        route.addWaypoint(m_point)
                    });
                    route.calculateDirections();
                    if (callback)
                        callback.call(self, route);
                    self._routes.push({
                        instance: route,
                        options: options
                    })
                })
        },
        removeRoute: function(route) {
            var self = this;
            if ($.isPlainObject(route))
                $.each(self._routes, function(index) {
                    if (compare_objects(this.options, route)) {
                        self.map.entities.remove(this.instance);
                        self._routes.splice(index, 1);
                        return false
                    }
                });
            else if ($.isNumeric(route) && self._routes[route]) {
                var linkRoute = self._routes[route];
                self.map.entities.remove(linkRoute.instance);
                self._routes.splice(route, 1)
            }
        },
        addTooltip: function(options, callback){}
    });
    adapters.googleStatic = protoAdapter.inherit({
        _getMapType: adapters.google._getMapType,
        _initMap: function() {
            var d = $.Deferred();
            d.done($.proxy(this._renderMap, this));
            d.resolve();
            return d.promise()
        },
        _renderMap: function() {
            var root = this.rootElement,
                options = this._options,
                maptype = options.maptype,
                location = options.location,
                width = options.width || root.width(),
                height = options.height || root.height(),
                zoom = options.zoom,
                markers = options.markers,
                routes = options.routes,
                autoScale = options.autoScale,
                size = width + "x" + height,
                markersToString = "",
                routeToString = "";
            this.map = root;
            this._renderMarkers();
            this._renderRoutes();
            if (width === 0 || height === 0)
                return;
            $.each(markers || [], function(index, marker) {
                markersToString += "&markers=";
                if ($.isPlainObject(marker)) {
                    if (marker.color)
                        markersToString += "color:" + marker.color + "|";
                    if (marker.label)
                        markersToString += "label:" + marker.label + "|";
                    if (marker.size)
                        markersToString += "size:" + marker.size + "|";
                    if (marker.icon)
                        markersToString += "icon:" + marker.icon + "|";
                    markersToString += marker.location
                }
                else
                    markersToString += marker
            });
            $.each(routes || [], function(index, route) {
                routeToString += "&path=";
                if (route.color)
                    routeToString += "color:" + route.color + "|";
                if (route.weight)
                    routeToString += "weight:" + route.weight + "|";
                routeToString += route.locations.join("|")
            });
            var apiURL = GOOGLE_STATIC_URL + "maptype=" + maptype + "&size=" + size + "&sensor=false" + markersToString + routeToString;
            if (!autoScale)
                apiURL += "&center=" + location + "&zoom=" + zoom;
            root.css("background", "url('" + apiURL + "') no-repeat 0 0");
            if (this.width)
                root.css("width", width);
            if (this.height)
                root.css("height", height)
        },
        addMarker: function(options) {
            this._markers.push(options);
            return $.Deferred().resolve().promise()
        },
        removeMarker: function(point) {
            var self = this;
            if ($.isPlainObject(point))
                $.each(self._markers, function(index) {
                    if (compare_objects(this, point)) {
                        self._markers.splice(index, 1);
                        return false
                    }
                });
            else if ($.isNumeric(point) && self._markers[point])
                self._markers.splice(point, 1)
        },
        addRoute: function(options) {
            this._routes.push(options);
            return $.Deferred().resolve().promise()
        },
        removeRoute: function(route) {
            var self = this;
            if ($.isPlainObject(route))
                $.each(self._routes, function(index) {
                    if (this === route) {
                        self._routes.splice(index, 1);
                        return false
                    }
                });
            else if ($.isNumeric(route) && self._routes[route])
                self._routes.splice(route, 1)
        },
        addTooltip: function(options){},
        _clean: function() {
            this.callBase();
            this.rootElement.css("background-image", "none")
        }
    });
    ui.dxMaps.__internals = {
        remapConstant: function(variable, newValue) {
            var allowedVars = ["GOOGLE_URL", "GOOGLE_STATIC_URL", "BING_LOCAL_FILES1", "BING_LOCAL_FILES2", "BING_URL", "BING_LOCATOR_URL", "BING_CREDENTIALS"];
            if ($.inArray(variable, allowedVars) !== -1)
                eval(variable + ' = newValue;')
        },
        mapsInit: mapsInit
    }
})(jQuery, DevExpress);

// Module widgets, file ui.autocomplete.js

(function($, DX, undefined) {
    var ui = DX.ui,
        utils = DX.utils;
    var KEY_DOWN = 40,
        KEY_UP = 38,
        KEY_ENTER = 13,
        KEY_ESC = 27,
        KEY_RIGHT = 39,
        KEY_TAB = 9,
        AUTOCOMPLETE_CLASS = "dx-autocomplete",
        AUTOCOMPLETE_POPUP = AUTOCOMPLETE_CLASS + "-popup",
        SELECTED_ITEM_CLASS = "dx-autocomplete-selected",
        SELECTED_ITEM_SELECTOR = "." + SELECTED_ITEM_CLASS,
        LIST_SELECTOR = ".dx-list",
        EDITBOX_INPUT_SELECTOR = ".dx-editbox-input",
        LIST_ITEM_SELECTOR = ".dx-list-item",
        LIST_ITEM_DATA_KEY = "dxListItemData",
        SEARCH_OPERATORS = ["startswith", "contains", "endwith", "notcontains"];
    ui.registerComponent("dxAutocomplete", ui.ContainerWidget.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    value: "",
                    items: [],
                    dataSource: new DevExpress.data.ArrayStore,
                    itemTemplate: "item",
                    itemRender: null,
                    minSearchLength: 1,
                    searchTimeout: 0,
                    placeholder: "",
                    filterOperator: "contains",
                    displayExpr: "this"
                })
        },
        _listElement: function() {
            return this._popup.rootElement().find(LIST_SELECTOR)
        },
        _listItemElement: function() {
            return this._popup.rootElement().find(LIST_ITEM_SELECTOR)
        },
        _listSelectedItemElement: function() {
            return this._popup.rootElement().find(SELECTED_ITEM_SELECTOR)
        },
        _inputElement: function() {
            return this.rootElement().find(EDITBOX_INPUT_SELECTOR)
        },
        _textboxElement: function() {
            return this._textbox.rootElement()
        },
        _init: function() {
            this.callBase();
            this._validateFilterOperator();
            this._compileDisplayGetter()
        },
        _validateFilterOperator: function() {
            var filterOperator = this.option("filterOperator"),
                normalizedFilterOperator = filterOperator.toLowerCase();
            if ($.inArray(normalizedFilterOperator, SEARCH_OPERATORS) > -1)
                return;
            throw Error("Filter operator '" + filterOperator + "' is unavailable");
        },
        _compileDisplayGetter: function() {
            this._displayGetter = DX.data.utils.compileGetter(this.option("displayExpr"))
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass(AUTOCOMPLETE_CLASS);
            this._renderTextbox();
            this._checkExceptions();
            this._renderPopup();
            this._renderList()
        },
        _renderTextbox: function() {
            this._textbox = $("<div />").dxTextbox({
                value: this.option("value"),
                placeholder: this.option("placeholder"),
                valueUpdateEvent: "keyup change",
                keyDownAction: $.proxy(this._handleTextboxKeyDown, this),
                keyUpAction: $.proxy(this._handleTextboxKeyUp, this),
                valueUpdateAction: $.proxy(this._updateValue, this)
            }).appendTo(this.rootElement()).data("dxTextbox")
        },
        _handleTextboxKeyDown: function(e) {
            var $list = this._listElement(),
                preventedKeys = [KEY_TAB, KEY_UP, KEY_DOWN],
                key = e.jQueryEvent.which;
            if ($list.is(":hidden"))
                return;
            if ($.inArray(key, preventedKeys) > -1)
                e.jQueryEvent.preventDefault()
        },
        _updateValue: function() {
            var inputElement = this._inputElement();
            this.option("value", this._textbox.option("value"));
            inputElement.prop("selectionStart", this._caretPosition);
            inputElement.prop("selectionEnd", this._caretPosition)
        },
        _handleTextboxKeyUp: function(e) {
            var key = e.jQueryEvent.which;
            this._caretPosition = this._inputElement().prop("selectionStart");
            switch (key) {
                case KEY_DOWN:
                    this._handleTextboxDownKey();
                    break;
                case KEY_UP:
                    this._handleTextboxUpKey();
                    break;
                case KEY_ENTER:
                    this._handleTextboxEnterKey();
                    break;
                case KEY_RIGHT:
                case KEY_TAB:
                    this._handleTextboxCompleteKeys();
                    break;
                case KEY_ESC:
                    this._handleTextboxEscKey();
                    break;
                default:
                    return
            }
        },
        _handleTextboxDownKey: function() {
            var $rootElement = this.rootElement(),
                $selectedItem = this._listSelectedItemElement(),
                $nextItem;
            this._refreshVisibility();
            if ($selectedItem.length) {
                $nextItem = $selectedItem.next();
                if (!$nextItem.length)
                    return;
                $nextItem.addClass(SELECTED_ITEM_CLASS);
                $selectedItem.removeClass(SELECTED_ITEM_CLASS)
            }
            else
                this._listItemElement().first().addClass(SELECTED_ITEM_CLASS)
        },
        _handleTextboxUpKey: function() {
            var $selectedItem = this._listSelectedItemElement(),
                $prevItem;
            if (!$selectedItem.length)
                return;
            $selectedItem.removeClass(SELECTED_ITEM_CLASS);
            $prevItem = $selectedItem.prev();
            if ($prevItem.length)
                $prevItem.addClass(SELECTED_ITEM_CLASS);
            else
                this._popup.hide()
        },
        _handleTextboxEnterKey: function() {
            var $selectedItem = this._listSelectedItemElement(),
                receivedValue;
            if (!$selectedItem.length)
                return;
            receivedValue = this._selectedItemDataGetter();
            this._caretPosition = receivedValue.length;
            this.option("value", receivedValue);
            this._popup.hide();
            this._reloadDataSource(receivedValue, "equals")
        },
        _handleTextboxCompleteKeys: function() {
            var $list = this._listElement(),
                newValue,
                receivedValue;
            if ($list.is(":hidden"))
                return;
            receivedValue = this._selectedItemDataGetter();
            newValue = receivedValue.length ? receivedValue : this._dataSource().items()[0];
            this._caretPosition = newValue.length;
            newValue = this._displayGetter(newValue);
            this.option("value", newValue);
            this._popup.hide();
            this._reloadDataSource(newValue, "equals")
        },
        _selectedItemDataGetter: function() {
            var $selectedItem = this._listSelectedItemElement();
            if (!$selectedItem.length)
                return [];
            return this._displayGetter($selectedItem.data(LIST_ITEM_DATA_KEY))
        },
        _handleTextboxEscKey: function() {
            this._popup.hide()
        },
        _renderPopup: function() {
            var $textbox = this._textboxElement(),
                textWidth = $textbox.width(),
                $input = this._textbox._input();
            this._popup = $("<div/>").addClass(AUTOCOMPLETE_POPUP).appendTo(this.rootElement()).dxPopup({
                shading: false,
                closeOnOutsideClick: true,
                showTitle: false,
                width: textWidth,
                height: "auto",
                position: {
                    my: "left top",
                    at: "left bottom",
                    of: $input,
                    collision: "none"
                },
                animation: {
                    show: {
                        type: "slide",
                        duration: 400
                    },
                    hide: {
                        type: "slide",
                        duration: 400
                    }
                }
            }).data("dxPopup");
            this._autocompleteResizeCallback = $.proxy(this._calculatePopupWidth, this);
            utils.windowResizeCallbacks.add(this._autocompleteResizeCallback)
        },
        _calculatePopupWidth: function() {
            var $textbox = this._textboxElement(),
                textWidth = $textbox.width();
            this._popup.option("width", textWidth)
        },
        _renderList: function() {
            this._list = $("<div />").appendTo(this._popup.content()).dxList({
                itemClickAction: $.proxy(this._handleListItemClick, this),
                itemTemplate: this.option("itemTemplate"),
                itemRender: this.option("itemRender"),
                showScrollbar: false,
                scrollingEnabled: false,
                noDataText: "",
                showNextButton: false
            }).data("dxList");
            this._list._templates = this._templates;
            this._setupDataSource()
        },
        _setupDataSource: function() {
            var self = this;
            if (this.option("items").length > 0)
                this._list.option("items", this.option("items"));
            else
                this._list.option("dataSource", this.option("dataSource"));
            this._list._initDataSource()
        },
        _handleListItemClick: function(e) {
            var value = this._displayGetter(e.itemData);
            this._caretPosition = value.length;
            this.option("value", value);
            this._popup.hide()
        },
        _dataSource: function() {
            return this._list._dataSource
        },
        _filterDataSource: function() {
            var searchValue = this._textbox.option("value");
            this._reloadDataSource(searchValue);
            this._clearSearchTimer()
        },
        _reloadDataSource: function(searchValue, searchMethod) {
            var self = this;
            self._dataSource().reload({
                searchField: self.option("displayExpr"),
                searchString: searchValue,
                searchMethod: searchMethod || self.option("filterOperator")
            }).done(function() {
                self._refreshVisibility()
            })
        },
        _refreshVisibility: function() {
            var canFilter = this._textbox.option("value").length >= this.option("minSearchLength"),
                dataSource = this._dataSource(),
                items = dataSource && dataSource.items(),
                hasResults = items.length;
            if (this._textbox.option("value") && canFilter && hasResults)
                if (items.length === 1 && this._displayGetter(dataSource.items()[0]) === this.option("value"))
                    this._popup.hide();
                else
                    this._popup.show();
            else
                this._popup.hide()
        },
        _dispose: function() {
            this._clearSearchTimer();
            utils.windowResizeCallbacks.remove(this._autocompleteResizeCallback);
            this.callBase()
        },
        _optionChanged: function(name, value) {
            switch (name) {
                case"value":
                    this._checkExceptions();
                    this._textbox.option(name, value);
                    this._applyFilter();
                    this._refreshVisibility();
                    break;
                case"placeholder":
                    this._textbox.option(name, value);
                    break;
                case"items":
                case"dataSource":
                case"itemTemplate":
                case"itemRender":
                    this._list.option(name, value);
                    break;
                case"filterOperator":
                    this._validateFilterOperator();
                    break;
                case"displayExpr":
                    this._compileDisplayGetter();
                    break;
                case"minSearchLength":
                case"searchTimeout":
                    break;
                default:
                    this.callBase.apply(this, arguments)
            }
        },
        _applyFilter: function() {
            var searchValue = this._textbox.option("value"),
                canFilter = searchValue.length >= this.option("minSearchLength");
            if (!canFilter)
                return;
            if (this.option("searchTimeout") > 0) {
                if (!this._searchTimer)
                    this._searchTimer = setTimeout($.proxy(this._filterDataSource, this), this.option("searchTimeout"))
            }
            else
                this._filterDataSource()
        },
        _clearSearchTimer: function() {
            clearTimeout(this._searchTimer);
            delete this._searchTimer
        },
        _checkExceptions: function() {
            if (this.option("value") === undefined)
                throw Error("Value option should not be undefined");
        }
    }))
})(jQuery, DevExpress);

// Module widgets, file ui.dropDownMenu.js

(function($, DX, undefined) {
    var ui = DX.ui;
    var DROP_DOWN_MENU_CLASS = "dx-dropdownmenu",
        DROP_DOWN_MENU_POPUP_CLASS = DROP_DOWN_MENU_CLASS + "-popup",
        DROP_DOWN_MENU_LIST_CLASS = "dx-dropdownmenu-list",
        DROP_DOWN_MENU_BUTTON_CLASS = "dx-dropdownmenu-button";
    ui.registerComponent("dxDropDownMenu", ui.ContainerWidget.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    items: [],
                    itemClickAction: null,
                    dataSource: null,
                    itemTemplate: "item",
                    itemRender: null,
                    buttonText: "",
                    buttonIcon: null,
                    buttonIconSrc: null,
                    buttonClickAction: null
                })
        },
        _render: function() {
            this.rootElement().addClass(DROP_DOWN_MENU_CLASS);
            this._renderButton();
            this._renderPopup();
            this._renderList();
            this.callBase()
        },
        _renderButton: function() {
            var buttonIconSrc = this.option("buttonIconSrc"),
                buttonIcon = this.option("buttonIcon");
            if (!buttonIconSrc && !buttonIcon)
                buttonIcon = "overflow";
            this._button = this.rootElement().addClass(DROP_DOWN_MENU_BUTTON_CLASS).dxButton({
                text: this.option("buttonText"),
                icon: buttonIcon,
                iconSrc: buttonIconSrc,
                clickAction: this.option("buttonClickAction")
            }).data("dxButton")
        },
        _renderClick: function() {
            this.rootElement().off("." + this.NAME).on(this._eventHelper.eventName("click"), this._createAction(this._handleButtonClick))
        },
        _handleButtonClick: function(e) {
            e.component._popup.show()
        },
        _renderList: function() {
            this._list = this._popup.content().addClass(DROP_DOWN_MENU_LIST_CLASS).dxList({
                scrollingEnabled: false,
                showScrollbar: false,
                noDataText: "",
                itemRender: this.option("itemRender"),
                itemClickAction: this.option("itemClickAction")
            }).data("dxList");
            this._list._templates = this._templates;
            this._list.option("dataSource", this.option("items"));
            this._attachListClick()
        },
        _toggleVisibility: function(visible) {
            this.callBase(visible);
            this._button.option("visible", visible)
        },
        _attachListClick: function() {
            this._list.rootElement().off("." + this.NAME).on(this._eventHelper.eventName("click"), this._createAction(this._handleListClick))
        },
        _handleListClick: function(e) {
            e.component._popup.hide()
        },
        _renderPopup: function() {
            this._popup = $("<div />").addClass(DROP_DOWN_MENU_POPUP_CLASS).appendTo(this.rootElement()).dxPopup({
                showTitle: false,
                shading: false,
                closeOnOutsideClick: true,
                width: "auto",
                height: "auto",
                position: {
                    my: "right top",
                    at: "right bottom",
                    of: this.rootElement(),
                    collision: "fit flip"
                },
                animation: {
                    show: {
                        type: "fade",
                        to: 1
                    },
                    hide: {
                        type: "fade",
                        to: 0
                    }
                }
            }).data("dxPopup")
        },
        _optionChanged: function(name, value) {
            if (/^button/.test(name))
                this._renderButton();
            else if (name === "dataSource" || name === "items")
                this._list.option("dataSource", value);
            else if (name === "itemRender")
                this._list.option("itemRender", value);
            else
                this.callBase.apply(this, arguments)
        }
    }))
})(jQuery, DevExpress);


// Module framework, file framework.js

(function($, DX, undefined) {
    var mergeWithReplace = function(destination, source, needReplaceFn) {
            var result = [];
            for (var i = 0, destinationLength = destination.length; i < destinationLength; i++)
                if (!needReplaceFn(destination[i], source))
                    result.push(destination[i]);
            result.push.apply(result, source);
            return result
        };
    var getMergeCommands = function() {
            return function(destination, source) {
                    return mergeWithReplace(destination, source, function(destObject, source) {
                            return $.grep(source, function(srcObject) {
                                    return destObject.option("id") === srcObject.option("id") && srcObject.option("id") || destObject.option("behavior") === srcObject.option("behavior") && destObject.option("behavior")
                                }).length
                        })
                }
        };
    DX.framework = {utils: {mergeCommands: getMergeCommands()}}
})(jQuery, DevExpress);

// Module framework, file framework.routing.js

(function($, DX) {
    var Class = DX.Class;
    DX.framework.Route = Class.inherit({
        _trimSeparators: function(str) {
            return str.replace(/^[\/.]+|\/+$/g, "")
        },
        _escapeRe: function(str) {
            return str.replace(/\W/g, "\\$1")
        },
        _checkConstraint: function(param, constraint) {
            param = String(param);
            if (typeof constraint === "string")
                constraint = new RegExp(constraint);
            var match = constraint.exec(param);
            if (!match || match[0] !== param)
                return false;
            return true
        },
        _ensureReady: function() {
            var p,
                pos,
                self = this;
            if (this._patternRe)
                return false;
            this._pattern = this._trimSeparators(this._pattern);
            this._patternRe = "";
            this._params = [];
            this._segments = [];
            this._separators = [];
            this._pattern.replace(/[^\/]+/g, function(segment, index) {
                self._segments.push(segment);
                if (index)
                    self._separators.push(self._pattern.substr(index - 1, 1))
            });
            $.each(this._segments, function(index) {
                var isStatic = true,
                    segment = this,
                    separator = index ? self._separators[index - 1] : "";
                if (segment.charAt(0) === ":") {
                    isStatic = false;
                    segment = segment.substr(1);
                    self._params.push(segment);
                    self._patternRe += "(?:" + separator + "([^/]+))";
                    if (segment in self._defaults)
                        self._patternRe += "?"
                }
                else
                    self._patternRe += separator + self._escapeRe(segment)
            });
            this._patternRe = new RegExp("^" + this._patternRe + "$")
        },
        ctor: function(pattern, defaults, constraints) {
            this._pattern = pattern || "";
            this._defaults = defaults || {};
            this._constraints = constraints || {}
        },
        parse: function(uri) {
            var self = this;
            this._ensureReady();
            var matches = this._patternRe.exec(uri);
            if (!matches)
                return false;
            var result = $.extend({}, this._defaults);
            $.each(this._params, function(i) {
                var index = i + 1;
                if (matches.length >= index && matches[index])
                    result[this] = self.parseSegment(matches[index])
            });
            $.each(this._constraints, function(key) {
                if (!self._checkConstraint(result[key], self._constraints[key])) {
                    result = false;
                    return false
                }
            });
            return result
        },
        format: function(routeValues) {
            var self = this;
            this._ensureReady();
            var mergeValues = $.extend({}, this._defaults),
                useStatic = 0,
                ret = [],
                dels = [],
                unusedRouteValues = {};
            $.each(routeValues, function(paramName, paramValue) {
                routeValues[paramName] = self.formatSegment(paramValue);
                if (!(paramName in mergeValues))
                    unusedRouteValues[paramName] = true
            });
            $.each(this._segments, function(index, segment) {
                ret[index] = index ? self._separators[index - 1] : '';
                if (segment.charAt(0) === ':') {
                    var paramName = segment.substr(1);
                    if (!(paramName in routeValues) && !(paramName in self._defaults)) {
                        ret = null;
                        return false
                    }
                    if (paramName in self._constraints && !self._checkConstraint(routeValues[paramName], self._constraints[paramName])) {
                        ret = null;
                        return false
                    }
                    if (paramName in routeValues) {
                        if (routeValues[paramName] !== undefined) {
                            mergeValues[paramName] = routeValues[paramName];
                            ret[index] += routeValues[paramName];
                            useStatic = index
                        }
                        delete unusedRouteValues[paramName]
                    }
                    else if (paramName in mergeValues) {
                        ret[index] += mergeValues[paramName];
                        dels.push(index)
                    }
                }
                else {
                    ret[index] += segment;
                    useStatic = index
                }
            });
            $.each(mergeValues, function(key, value) {
                if (!!value && $.inArray(":" + key, self._segments) === -1 && routeValues[key] !== value) {
                    ret = null;
                    return false
                }
            });
            if (!$.isEmptyObject(unusedRouteValues))
                return false;
            $.each(routeValues, function(i) {
                if (!this in mergeValues) {
                    ret = null;
                    return false
                }
            });
            if (ret === null)
                return false;
            if (dels.length)
                $.map(dels, function(i) {
                    if (i >= useStatic)
                        ret[i] = ''
                });
            var result = ret.join('');
            result = result.replace(/(.*)\/$/, "$1");
            return result
        },
        formatSegment: function(value) {
            if ($.isArray(value) || $.isPlainObject(value))
                return "json:" + JSON.stringify(value);
            return value
        },
        parseSegment: function(value) {
            if (value.substr(0, 5) === "json:")
                try {
                    value = $.parseJSON(value.substr(5))
                }
                catch(x) {}
            return value
        }
    });
    DX.framework.MvcRouter = DX.Class.inherit({
        ctor: function() {
            this._registry = []
        },
        _trimSeparators: function(str) {
            return str.replace(/^[\/.]+|\/+$/g, "")
        },
        _createRoute: function(pattern, defaults, constraints) {
            return new DX.framework.Route(pattern, defaults, constraints)
        },
        register: function(pattern, defaults, constraints) {
            this._registry.push(this._createRoute(pattern, defaults, constraints))
        },
        parse: function(uri) {
            var ret;
            uri = this._trimSeparators(uri);
            $.each(this._registry, function() {
                var result = this.parse(uri);
                if (result !== false) {
                    ret = result;
                    return false
                }
            });
            return ret ? ret : false
        },
        format: function(obj) {
            var ret;
            obj = obj || {};
            $.each(this._registry, function() {
                var result = this.format(obj);
                if (result !== false) {
                    ret = result;
                    return false
                }
            });
            if (typeof ret === "string")
                return ret;
            return false
        }
    })
})(jQuery, DevExpress);

// Module framework, file framework.command.js

(function($, DX) {
    var ui = DX.ui;
    DX.framework.dxCommand = ui.Component.inherit({
        ctor: function(element, options) {
            if ($.isPlainObject(element)) {
                options = element;
                element = $("<div />")
            }
            this.beforeExecute = $.Callbacks();
            this.afterExecute = $.Callbacks();
            this.callBase(element, options)
        },
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    action: null,
                    id: null,
                    title: "",
                    icon: "",
                    iconSrc: "",
                    location: "",
                    visible: true
                })
        },
        execute: function() {
            var isDisabled = this._options.disabled;
            if ($.isFunction(isDisabled))
                isDisabled = !!isDisabled.apply(this, arguments);
            if (isDisabled)
                throw new Error("Cannot execute command: " + this._options.id);
            this.beforeExecute.fire(arguments);
            this._createActionByOption("action").apply(this, arguments);
            this.afterExecute.fire(arguments)
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass("dx-command")
        },
        _renderDisabledState: $.noop,
        _dispose: function() {
            this.callBase();
            this.beforeExecute.empty();
            this.afterExecute.empty()
        }
    });
    ui.registerComponent("dxCommand", DX.framework.dxCommand)
})(jQuery, DevExpress);

// Module framework, file framework.viewCache.js

(function($, DX, undefined) {
    var DX = DevExpress,
        Class = DX.Class;
    DX.framework.ViewCache = Class.inherit({
        ctor: function() {
            this._cache = {}
        },
        setView: function(key, viewInfo) {
            this._cache[key] = viewInfo
        },
        getView: function(key) {
            return this._cache[key]
        },
        removeView: function(key) {
            var result = this._cache[key];
            delete this._cache[key];
            return result
        },
        clear: function() {
            this._cache = {}
        }
    });
    DX.framework.NullViewCache = Class.inherit({
        setView: $.noop,
        getView: $.noop,
        removeView: $.noop,
        clear: $.noop
    })
})(jQuery, DevExpress);

// Module framework, file framework.stateManager.js

(function($, DX, undefined) {
    var DX = DevExpress,
        Class = DX.Class;
    DX.framework.MemoryKeyValueStorage = Class.inherit({
        ctor: function() {
            this.storage = {}
        },
        getItem: function(key) {
            return this.storage[key]
        },
        setItem: function(key, value) {
            this.storage[key] = value
        },
        removeItem: function(key) {
            delete this.storage[key]
        }
    });
    DX.framework.StateManager = Class.inherit({
        ctor: function(options) {
            options = options || {};
            this.storage = options.storage || new DX.framework.MemoryKeyValueStorage;
            this.stateSources = options.stateSources || []
        },
        addStateSource: function(stateSource) {
            this.stateSources.push(stateSource)
        },
        removeStateSource: function(stateSource) {
            var index = $.inArray(stateSource, this.stateSources);
            if (index > -1) {
                this.stateSources.splice(index, 1);
                stateSource.removeState(this.storage)
            }
        },
        saveState: function() {
            var self = this;
            $.each(this.stateSources, function(index, stateSource) {
                stateSource.saveState(self.storage)
            })
        },
        restoreState: function() {
            var self = this;
            $.each(this.stateSources, function(index, stateSource) {
                stateSource.restoreState(self.storage)
            })
        },
        clearState: function() {
            var self = this;
            $.each(this.stateSources, function(index, stateSource) {
                stateSource.removeState(self.storage)
            })
        }
    })
})(jQuery, DevExpress);

// Module framework, file framework.browserAdapters.js

(function($, DX, undefined) {
    var Class = DX.Class;
    var ROOT_PAGE_URL = "__root__";
    DX.framework.DefaultBrowserAdapter = Class.inherit({
        ctor: function(options) {
            options = options || {};
            this._window = options.window || window;
            this.popState = $.Callbacks();
            $(this._window).on("hashchange", $.proxy(this._onHashChange, this))
        },
        replaceState: function(uri) {
            uri = this._normalizeUri(uri);
            this._window.history.replaceState(null, null, "#" + uri)
        },
        pushState: function(uri) {
            uri = this._normalizeUri(uri);
            this._window.history.pushState(null, null, "#" + uri)
        },
        createRootPage: function() {
            this._window.history.replaceState(null, null, "#" + ROOT_PAGE_URL)
        },
        _onHashChange: function() {
            this.popState.fire()
        },
        getWindowName: function() {
            return this._window.name
        },
        setWindowName: function(windowName) {
            this._window.name = windowName
        },
        back: function() {
            this._window.history.back()
        },
        getHash: function() {
            return this._normalizeUri(this._window.location.hash)
        },
        isRootPage: function() {
            return this.getHash() === ROOT_PAGE_URL
        },
        _normalizeUri: function(uri) {
            return (uri || "").replace(/^#+/, "")
        }
    });
    DX.framework.OldBrowserAdapter = DX.framework.DefaultBrowserAdapter.inherit({
        ctor: function() {
            this._innerEventCount = 0;
            this.callBase.apply(this, arguments)
        },
        replaceState: function(uri) {
            uri = this._normalizeUri(uri);
            if (this.getHash() !== uri) {
                this._skipNextEvent();
                this.back();
                this._skipNextEvent();
                this._window.location.hash = uri
            }
        },
        pushState: function(uri) {
            uri = this._normalizeUri(uri);
            if (this.getHash() !== uri) {
                this._skipNextEvent();
                this._window.location.hash = uri
            }
        },
        createRootPage: function() {
            this.pushState(ROOT_PAGE_URL)
        },
        _onHashChange: function() {
            if (this._innerEventCount)
                this._innerEventCount--;
            else
                this.popState.fire()
        },
        _skipNextEvent: function() {
            this._innerEventCount++
        }
    });
    DX.framework.InFrameBrowserAdapter = DX.framework.OldBrowserAdapter.inherit({
        ctor: function() {
            var self = this;
            this.callBase.apply(this, arguments);
            this._window.history.back = function() {
                self._window.location.hash = ROOT_PAGE_URL
            }
        },
        back: function() {
            if (!this.isRootPage())
                this._window.history.back()
        }
    })
})(jQuery, DevExpress);

// Module framework, file framework.browserNavigationDevice.js

(function($, DX, undefined) {
    var Class = DX.Class;
    var WINDOW_NAME = "dxApplication";
    DX.framework.BrowserNavigationDevice = Class.inherit({
        ctor: function(options) {
            options = options || {};
            this._browserAdapter = this._createBrowserAdapter(options);
            this.uriChanged = $.Callbacks();
            this.backInitiated = $.Callbacks();
            this._deferredNavigate = null;
            this._browserAdapter.popState.add($.proxy(this._onPopState, this));
            if (this._browserAdapter.getWindowName() !== WINDOW_NAME)
                this._prepareBrowserHistory();
            if (this._browserAdapter.isRootPage())
                this._browserAdapter.pushState("")
        },
        _createBrowserAdapter: function(options) {
            var sourceWindow = options.window || window;
            if (sourceWindow === sourceWindow.top)
                if (sourceWindow.history.replaceState && sourceWindow.history.pushState)
                    return new DX.framework.DefaultBrowserAdapter(options);
                else
                    return new DX.framework.OldBrowserAdapter(options);
            else
                return new DX.framework.InFrameBrowserAdapter(options)
        },
        _prepareBrowserHistory: function() {
            var hash = this.getUri();
            this._browserAdapter.setWindowName(WINDOW_NAME);
            this._browserAdapter.createRootPage();
            this._browserAdapter.pushState(hash)
        },
        getUri: function() {
            return this._browserAdapter.getHash()
        },
        setUri: function(uri) {
            if (this._browserAdapter.isRootPage())
                this._browserAdapter.pushState(uri);
            else
                this._browserAdapter.replaceState(uri)
        },
        _onPopState: function(uri) {
            var self = this,
                currentHash = this.getUri();
            if (this._deferredNavigate && this._deferredNavigate.state() === "pending")
                if (this._browserAdapter.isRootPage())
                    this._deferredNavigate.resolve();
                else
                    this._browserAdapter.back();
            else if (this._browserAdapter.isRootPage())
                this.backInitiated.fire();
            else {
                this._deferredNavigate = $.Deferred().done(function() {
                    self.uriChanged.fire(currentHash)
                });
                this._browserAdapter.back()
            }
        },
        back: function() {
            this._browserAdapter.back()
        }
    })
})(jQuery, DevExpress);

// Module framework, file framework.navigationManager.js

(function($, DX, undefined) {
    var Class = DX.Class;
    var NAVIGATION_TARGETS = {
            current: "current",
            blank: "blank",
            back: "back"
        },
        STORAGE_HISTORY_KEY = "__history";
    DX.framework.NavigationStack = Class.inherit({
        ctor: function(options) {
            options = options || {};
            this.itemsRemoved = $.Callbacks();
            this.clear()
        },
        currentItem: function() {
            return this.items[this.currentIndex]
        },
        back: function() {
            this.currentIndex--;
            if (this.currentIndex < 0)
                throw Error("Unable to go back");
        },
        forward: function() {
            this.currentIndex++;
            if (this.currentIndex >= this.items.length)
                throw Error("Unable to go forward");
        },
        navigate: function(uri, replaceCurrent) {
            if (this.currentIndex < this.items.length && this.currentIndex > -1 && this.items[this.currentIndex].uri === uri)
                return;
            if (replaceCurrent)
                this.currentIndex--;
            else if (this.currentIndex > 1 && this.items[this.currentIndex - 1].uri === uri) {
                this.back();
                return
            }
            if (this.currentIndex + 1 < this.items.length && this.items[this.currentIndex + 1].uri === uri)
                this.currentIndex++;
            else {
                var toDelete = this.items.splice(this.currentIndex + 1);
                var newItem = {uri: uri};
                this.items.push(newItem);
                newItem.key = this.items[0].uri + "_" + (this.items.length - 1) + "_" + uri;
                this.currentIndex++;
                this._deleteItems(toDelete)
            }
            return newItem
        },
        _deleteItems: function(items) {
            if (items)
                this.itemsRemoved.fire(items)
        },
        getPreviousItem: function() {
            return this.items.length > 1 ? this.items[this.currentIndex - 1] : undefined
        },
        canBack: function() {
            return this.currentIndex > 0
        },
        clear: function() {
            this._deleteItems(this.items);
            this.items = [];
            this.currentIndex = -1
        }
    });
    DX.framework.NavigationManager = Class.inherit({
        ctor: function(options) {
            options = options || {};
            var self = this;
            self.navigationStacks = {};
            self.currentStack = new DX.framework.NavigationStack;
            self.currentUri = undefined;
            self.navigating = $.Callbacks();
            self.navigated = $.Callbacks();
            self.itemRemoved = $.Callbacks();
            self._navigationDevice = options.navigationDevice || new DX.framework.BrowserNavigationDevice;
            self._navigationDevice.uriChanged.add($.proxy(self.navigate, self));
            self._navigationDevice.backInitiated.add($.proxy(self.back, self));
            self._stateStorageKey = options.stateStorageKey || STORAGE_HISTORY_KEY
        },
        navigate: function(uri, options) {
            var self = this;
            options = $.extend({target: NAVIGATION_TARGETS.blank}, options || {});
            if (uri === undefined)
                uri = self._navigationDevice.getUri();
            if (/^_back$/.test(uri)) {
                self.back();
                return
            }
            if (self.currentUri !== uri) {
                var navigatingEventArgs = {
                        currentUri: self.currentUri,
                        uri: uri,
                        options: options
                    };
                self.navigating.fire(navigatingEventArgs);
                if (navigatingEventArgs.cancel)
                    self._navigationDevice.setUri(self.currentUri);
                else
                    DX.utils.executeAsync(function() {
                        var previousUri = self.currentUri;
                        self.currentUri = uri;
                        self._navigationDevice.setUri(uri);
                        self._updateHistory(uri, options);
                        self.navigated.fire({
                            uri: uri,
                            previousUri: previousUri,
                            options: options,
                            item: self.currentItem()
                        })
                    })
            }
        },
        _createNavigationStack: function() {
            var result = new DX.framework.NavigationStack;
            result.itemsRemoved.add($.proxy(this._removeItems, this));
            return result
        },
        _updateHistory: function(uri, options) {
            var isRoot = options.root || !!this.navigationStacks[uri] && options.target === NAVIGATION_TARGETS.blank,
                direction = "none",
                prevItemDirection = (this.currentItem() || {}).direction;
            if (isRoot || !this.currentStack.items.length) {
                this.navigationStacks[uri] = this.navigationStacks[uri] || this._createNavigationStack();
                this.currentStack = this.navigationStacks[uri]
            }
            if (isRoot && this.currentStack.items.length)
                this.currentStack.currentIndex = 0;
            else {
                var prevIndex = this.currentStack.currentIndex;
                switch (options.target) {
                    case NAVIGATION_TARGETS.blank:
                        this.currentStack.navigate(uri);
                        break;
                    case NAVIGATION_TARGETS.current:
                        this.currentStack.navigate(uri, true);
                        break;
                    case NAVIGATION_TARGETS.back:
                        this.currentStack.back();
                        break;
                    default:
                        throw Error("Unknown navigation target: '" + target + "'. Use the DevExpress.framework.NavigationManager.NAVIGATION_TARGETS enumerable values.");
                }
                var indexDelta = this.currentStack.currentIndex - prevIndex;
                if (indexDelta < 0 && prevItemDirection != "none")
                    direction = "backward";
                else if (indexDelta > 0 && this.currentStack.currentIndex > 0)
                    direction = "forward"
            }
            options.direction = options.direction || direction;
            if (options.target === NAVIGATION_TARGETS.current)
                this.currentItem().direction = prevItemDirection;
            else if (options.target === NAVIGATION_TARGETS.blank)
                this.currentItem().direction = options.direction
        },
        _removeItems: function(items) {
            var self = this;
            $.each(items, function(index, item) {
                self.itemRemoved.fire(item)
            })
        },
        back: function(alternate) {
            var item = this.getPreviousItem();
            if (item)
                this.navigate(item.uri, {
                    target: NAVIGATION_TARGETS.back,
                    item: item
                });
            else if (alternate)
                this.navigate(alternate);
            else
                this._navigationDevice.back()
        },
        getPreviousItem: function() {
            return this.currentStack.getPreviousItem()
        },
        currentItem: function() {
            return this.currentStack.currentItem()
        },
        currentIndex: function() {
            return this.currentStack.currentIndex
        },
        canBack: function() {
            return this.currentStack.canBack()
        },
        getItemByIndex: function(index) {
            return this.currentStack.items[index]
        },
        saveState: function(storage) {
            if (this.currentStack.items.length) {
                var state = {
                        items: this.currentStack.items,
                        currentIndex: this.currentStack.currentIndex,
                        currentStackKey: this.currentStack.items[0].uri
                    };
                var json = JSON.stringify(state);
                storage.setItem(this._stateStorageKey, json)
            }
            else
                this.removeState(storage)
        },
        restoreState: function(storage) {
            var json = storage.getItem(this._stateStorageKey);
            if (json)
                try {
                    var state = JSON.parse(json),
                        stack = this._createNavigationStack();
                    if (!state.items[0].uri)
                        throw Error("Error while application state restoring. State has been cleared. Refresh the page.");
                    stack.items = state.items;
                    stack.currentIndex = state.currentIndex;
                    this.navigationStacks[stack.items[0].uri] = stack;
                    this.currentStack = this.navigationStacks[state.currentStackKey];
                    this._navigationDevice.setUri(this.currentItem().uri)
                }
                catch(e) {
                    this.removeState(storage);
                    throw e;
                }
        },
        removeState: function(storage) {
            storage.removeItem(this._stateStorageKey)
        },
        clearHistory: function() {
            this.currentStack.clear()
        }
    });
    DX.framework.NavigationManager.NAVIGATION_TARGETS = NAVIGATION_TARGETS
})(jQuery, DevExpress);

// Module framework, file framework.actionExecutors.js

(function($, DX, undefined) {
    DX.framework.createActionExecutors = function(app) {
        return {
                routing: {execute: function(e) {
                        if ($.isPlainObject(e.action)) {
                            var toBack = e.action.backBehaviour;
                            if (e.action.backBehaviour)
                                delete e.action.backBehaviour;
                            var routeValues = e.action,
                                uri = app.router.format(routeValues);
                            if (toBack)
                                app.back(uri);
                            else
                                app.navigate(uri);
                            e.handled = true
                        }
                    }},
                hash: {execute: function(e) {
                        if (typeof e.action !== "string" || e.action.charAt(0) !== "#")
                            return;
                        var uriTemplate = e.action.substr(1);
                        var uri = uriTemplate.replace(/\{([^}]+)\}/g, function(entry, expr) {
                                if (expr.indexOf(",") > -1)
                                    expr = $.map(expr.split(","), $.trim);
                                var getter = DX.data.utils.compileGetter(expr),
                                    model = e.args[0].model,
                                    value = getter(model);
                                value = DX.framework.Route.prototype.formatSegment(value);
                                return value !== undefined ? value : entry
                            });
                        var navigateOptions = (e.component || {}).NAME === "dxCommand" ? e.component.option() : {};
                        app.navigate(uri, navigateOptions);
                        e.handled = true
                    }}
            }
    }
})(jQuery, DevExpress);

// Module framework, file framework.application.js

(function($, DX) {
    var Class = DX.Class,
        NAVIGATION_TARGETS = DX.framework.NavigationManager.NAVIGATION_TARGETS,
        BACK_COMMAND_TITLE = "Back",
        frameworkNS = DX.framework;
    DX.framework.Application = Class.inherit({
        ctor: function(options) {
            options = options || {};
            this.namespace = options.namespace || options.ns || window;
            this.components = [];
            this.router = options.router || new DX.framework.MvcRouter;
            this.navigationManager = options.navigationManager || new DX.framework.NavigationManager;
            this.navigationManager.navigating.add($.proxy(this._onNavigating, this));
            this.navigationManager.navigated.add($.proxy(this._onNavigated, this));
            this.navigationManager.itemRemoved.add($.proxy(this._onNavigationItemRemoved, this));
            this.stateManager = options.stateManager || new DX.framework.StateManager({storage: options.stateStorage || sessionStorage});
            this.stateManager.addStateSource(this.navigationManager);
            this._viewCache = options.disableViewCache ? new DX.framework.NullViewCache : new DX.framework.ViewCache;
            this.navigation = this._createNavigationCommands(options.navigation);
            this.beforeViewSetup = $.Callbacks();
            this.afterViewSetup = $.Callbacks();
            this.viewShowing = $.Callbacks();
            this.viewShown = $.Callbacks();
            this.viewDisposing = $.Callbacks();
            this.viewDisposed = $.Callbacks();
            DX.registerActionExecutor(DX.framework.createActionExecutors(this));
            DX.ui.dxOverlay.defaultTargetContainer(".dx-layout");
            this.components.push(this.router);
            this.components.push(this.navigationManager)
        },
        _createNavigationCommands: function(commandConfig) {
            var self = this;
            if (!commandConfig)
                return [];
            return $.map(commandConfig, function(item) {
                    var command;
                    if (item instanceof frameworkNS.dxCommand)
                        command = item;
                    else
                        command = new frameworkNS.dxCommand($.extend({
                            location: "navigation",
                            root: true
                        }, item));
                    return command
                })
        },
        _callComponentMethod: function(methodName, args) {
            var tasks = [];
            $.each(this.components, function(index, component) {
                if (component[methodName]) {
                    var result = component[methodName](args);
                    if (result && result.done)
                        tasks.push(result)
                }
            });
            return $.when.apply($, tasks)
        },
        init: function() {
            return this._callComponentMethod("init")
        },
        _onNavigating: function(args) {
            var self = this;
            var routeData = this.router.parse(args.uri);
            var uri = this.router.format(routeData);
            if (args.uri !== uri && uri) {
                args.cancel = true;
                this.navigate(uri)
            }
        },
        _onNavigated: function(args) {
            var viewInfo = this._acquireView(args.item);
            this._setCurrentView(viewInfo, args.options.direction)
        },
        _onNavigationItemRemoved: function(item) {
            var viewInfo = this._viewCache.removeView(item.key);
            if (viewInfo) {
                this._processEvent("viewDisposing", viewInfo, viewInfo.model);
                this._disposeView(viewInfo);
                this._processEvent("viewDisposed", viewInfo, viewInfo.model)
            }
        },
        _disposeView: function(viewInfo){},
        _acquireView: function(navigationItem) {
            var viewInfo = this._viewCache.getView(navigationItem.key);
            if (!viewInfo) {
                viewInfo = this._createView(navigationItem.uri);
                this._viewCache.setView(navigationItem.key, viewInfo)
            }
            return viewInfo
        },
        _processEvent: function(eventName, args, model) {
            this._callComponentMethod(eventName, args);
            if (this[eventName] && this[eventName].fire)
                this[eventName].fire(args);
            var modelMethod = (model || {})[eventName];
            if (modelMethod)
                modelMethod.call(model, args)
        },
        _createView: function(uri) {
            var routeData = this.router.parse(uri);
            var viewInfo = {
                    viewName: routeData.view,
                    uri: uri
                };
            this._processEvent("beforeViewSetup", {
                routeData: routeData,
                viewInfo: viewInfo
            });
            viewInfo.model = viewInfo.model || this._createModel(routeData);
            this._processEvent("afterViewSetup", viewInfo);
            if (this.navigationManager.canBack())
                this._appendBackCommand(viewInfo);
            return viewInfo
        },
        _createModel: function(routeData) {
            var setupFunc = $.noop;
            if (routeData.view in this.namespace)
                setupFunc = this.namespace[routeData.view];
            return setupFunc.call(this.namespace, routeData) || {}
        },
        _appendBackCommand: function(viewInfo) {
            var commands = viewInfo.model.commands = viewInfo.model.commands || [];
            var toMergeTo = [new DX.framework.dxCommand({
                        id: "back",
                        title: BACK_COMMAND_TITLE,
                        location: "back",
                        behavior: "back",
                        action: "#_back",
                        icon: "arrowleft",
                        type: "back"
                    })];
            var result = DX.framework.utils.mergeCommands(toMergeTo, commands);
            commands.length = 0;
            commands.push.apply(commands, result)
        },
        _setCurrentView: function(viewInfo, direction) {
            var self = this;
            var eventArgs = {
                    viewInfo: viewInfo,
                    direction: direction
                };
            self._processEvent("viewShowing", eventArgs, viewInfo.model);
            if (eventArgs.cancel)
                return;
            DX.data.utils.DataSourceLoadLock.obtain();
            return self._setCurrentViewAsyncImpl(eventArgs.viewInfo, direction).done(function() {
                    DX.data.utils.DataSourceLoadLock.release();
                    self._processEvent("viewShown", eventArgs, viewInfo.model)
                })
        },
        _highlightCurrentNavigationCommand: function(viewInfo) {
            var self = this;
            $.each(this.navigation, function(index, command) {
                if ('currentNavigationItemId' in viewInfo.model)
                    command.option("highlighted", viewInfo.model.currentNavigationItemId === command.option("id"));
                else
                    self._selectNavigationItemByUri(command, viewInfo.uri)
            })
        },
        _selectNavigationItemByUri: function(command, uri) {
            var currentUri = "#" + uri,
                commandUri = command.option("action");
            if (typeof commandUri === 'string' && /^#/.test(commandUri) && commandUri === currentUri)
                command.option("highlighted", true);
            else
                command.option("highlighted", false)
        },
        _setCurrentViewAsyncImpl: DX.abstract,
        navigate: function(uri, options) {
            var self = this;
            if (!self._inited)
                self.init().done(function() {
                    self._inited = true;
                    self.restoreState();
                    self.navigate(uri, options)
                });
            else
                self.navigationManager.navigate(uri, options)
        },
        canBack: function() {
            return this.navigationManager.canBack()
        },
        back: function() {
            this.navigationManager.back()
        },
        saveState: function() {
            this.stateManager.saveState()
        },
        restoreState: function() {
            this.stateManager.restoreState()
        },
        clearState: function() {
            this.stateManager.clearState()
        }
    })
})(jQuery, DevExpress);

// Module framework, file framework.html.js

(function($, DX, undefined) {
    var removeFromViewPort = function($items) {
            $items.appendTo($("#__hidden-bag"))
        };
    DX.framework.html = {
        layoutControllers: {},
        utils: {removeFromViewPort: removeFromViewPort}
    };
    $(function() {
        $("<div id=\"__hidden-bag\"></div>").appendTo($(document.body)).hide()
    })
})(jQuery, DevExpress);

// Module framework, file framework.widgetCommandAdapters.js

(function($, DX) {
    var adapters = DX.framework.html.commandToDXWidgetAdapters = {
            _updateItems: [],
            addCommandBase: function(widget, command, containerOptions, inialItemOptions, customizeItem) {
                var itemOptions = $.extend(inialItemOptions, command.option());
                var items = widget.option("items");
                items.push(itemOptions);
                var updateItem = function(name, newValue, oldValue) {
                        $.extend(itemOptions, command.option());
                        customizeItem(itemOptions, name, newValue, oldValue);
                        if (name !== "highlighted")
                            widget.option("items", items)
                    };
                this._updateItems.push(updateItem);
                updateItem();
                command.optionChanged.add(updateItem);
                widget.disposing.add(function() {
                    command.optionChanged.remove(updateItem)
                })
            }
        };
    adapters.dxToolbar = {addCommand: function($container, command, containerOptions) {
            var toolbar = $container.data("dxToolbar");
            var isMenu = containerOptions.menu || containerOptions.name === "menu";
            function customizeOption(itemOptions) {
                var options = {
                        text: resolveTextValue(command, containerOptions),
                        clickAction: function() {
                            command.execute()
                        },
                        disabled: command.option("disabled"),
                        icon: resolveIconValue(command, containerOptions, "icon"),
                        iconSrc: resolveIconValue(command, containerOptions, "iconSrc"),
                        type: resolveTypeValue(command, containerOptions)
                    };
                var align = containerOptions.align || undefined;
                itemOptions.options = options;
                itemOptions.align = align
            }
            if (isMenu) {
                var dropdown = $.grep(toolbar.option("items"), function(item, index) {
                        return item.widget && item.widget === 'dropDownMenu'
                    })[0];
                if (!dropdown) {
                    var itemRender = function(itemData, itemIndex, itemElement) {
                            $(itemElement).text(itemData.command.option("title"))
                        };
                    dropdown = $.extend({
                        widget: 'dropDownMenu',
                        options: {
                            items: [],
                            itemRender: itemRender,
                            itemTemplate: containerOptions.itemTemplate,
                            itemClickAction: function(e) {
                                e.itemData.command.execute()
                            }
                        }
                    }, containerOptions);
                    var items = toolbar.option("items");
                    items.push(dropdown);
                    toolbar.option("items", items)
                }
                var menuItem = $.extend({command: command}, command.option());
                dropdown.options.items.push(menuItem);
                command.optionChanged.add(function() {
                    $.extend(menuItem, command.option());
                    toolbar._refresh()
                })
            }
            else
                adapters.addCommandBase(toolbar, command, containerOptions, {widget: "button"}, customizeOption);
            toolbar.option("visible", true)
        }};
    adapters.dxActionSheet = {addCommand: function($container, command, containerOptions) {
            var actionSheet = $container.data("dxActionSheet"),
                initialItemData = {command: command};
            adapters.addCommandBase(actionSheet, command, containerOptions, initialItemData, function(itemOptions) {
                itemOptions.text = resolveTextValue(command, containerOptions);
                itemOptions.icon = resolveIconValue(command, containerOptions, "icon");
                itemOptions.iconSrc = resolveIconValue(command, containerOptions, "iconSrc")
            })
        }};
    adapters.dxList = {addCommand: function($container, command, containerOptions) {
            var list = $container.data("dxList");
            adapters.addCommandBase(list, command, containerOptions, {}, function(itemOptions) {
                itemOptions.title = resolveTextValue(command, containerOptions);
                itemOptions.clickAction = function() {
                    if (!itemOptions.disabled)
                        command.execute()
                };
                itemOptions.icon = resolveIconValue(command, containerOptions, "icon");
                itemOptions.iconSrc = resolveIconValue(command, containerOptions, "iconSrc")
            })
        }};
    adapters.dxNavBar = {addCommand: function($container, command, containerOptions) {
            var navbar = $container.data("dxNavBar");
            var initialItemData = {command: command};
            navbar.option("itemClickAction", function(e) {
                e.itemData.command.execute()
            });
            var updateSelectedIndex = function() {
                    var items = navbar.option("items");
                    for (var i = 0, itemsCount = items.length; i < itemsCount; i++)
                        if (items[i].highlighted) {
                            navbar.option("selectedIndex", i);
                            break
                        }
                };
            adapters.addCommandBase(navbar, command, containerOptions, initialItemData, function(itemOptions, name, newValue, oldValue) {
                if (name === "highlighted") {
                    if (newValue)
                        updateSelectedIndex()
                }
                else {
                    itemOptions.text = resolveTextValue(command, containerOptions);
                    itemOptions.icon = resolveIconValue(command, containerOptions, "icon");
                    itemOptions.iconSrc = resolveIconValue(command, containerOptions, "iconSrc");
                    updateSelectedIndex()
                }
            })
        }};
    var resolvePropertyValue = function(command, containerOptions, propertyName) {
            var defaultOption = containerOptions.defaultCommandOptions ? containerOptions.defaultCommandOptions[propertyName] : undefined;
            return command.option(propertyName) || defaultOption
        };
    var resolveTextValue = function(command, containerOptions) {
            var hasIcon = !!command.option("icon") || command.option("iconSrc"),
                titleValue = resolvePropertyValue(command, containerOptions, "title");
            return containerOptions.showText || !hasIcon ? titleValue : ""
        };
    var resolveIconValue = function(command, containerOptions, propertyName) {
            var hasText = !!command.option("title"),
                iconValue = resolvePropertyValue(command, containerOptions, propertyName);
            return containerOptions.showIcon || !hasText ? iconValue : undefined
        };
    var resolveTypeValue = function(command, containerOptions) {
            return resolvePropertyValue(command, containerOptions, "type")
        }
})(jQuery, DevExpress);

// Module framework, file framework.commandManager.js

(function($, DX, undefined) {
    var Class = DX.Class,
        ui = DevExpress.ui;
    DX.framework.dxCommandContainer = ui.Component.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    locations: [],
                    defaultOptions: {
                        showText: true,
                        showIcon: true
                    }
                })
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass("dx-command-container")
        },
        arrangeCommands: function(commands, attachCommandToContainerImpl) {
            var self = this;
            var locations = [];
            $.each(self.option("locations"), function(index, locationOptions) {
                var filteredcommands = $.grep(commands, function(command) {
                        return command && command.option("location") === locationOptions.name && !locationOptions.processed
                    });
                if (filteredcommands.length > 0) {
                    locations.push($.extend({commands: filteredcommands}, self.option("defaultOptions"), locationOptions));
                    locationOptions.processed = true
                }
            });
            attachCommandToContainerImpl(self.rootElement(), locations)
        }
    });
    ui.registerComponent("dxCommandContainer", DX.framework.dxCommandContainer);
    DX.framework.html.CommandManager = Class.inherit({
        ctor: function(options) {
            options = options || {};
            this.globalCommands = options.globalCommands || [];
            this.commandsToWidgetRegistry = [this._commandsToDXWidget]
        },
        _commandsToDXWidget: function($container, locations) {
            var result = false;
            var componentNames = $container.data("dxComponents");
            var adapters = DX.framework.html.commandToDXWidgetAdapters;
            if (componentNames)
                for (var index in componentNames) {
                    var widgetName = componentNames[index];
                    if (widgetName in adapters) {
                        var widget = $container.data(widgetName);
                        widget.beginUpdate();
                        $.each(locations, function(index, location) {
                            $.each(location.commands, function(index, command) {
                                adapters[widgetName].addCommand($container, command, location)
                            })
                        });
                        widget.endUpdate();
                        return true
                    }
                }
            return false
        },
        _findCommands: function($view) {
            var result = $.map($view.children(".dx-command"), function(element) {
                    return $(element).data("dxCommand")
                });
            return result
        },
        _findCommandContainers: function($markup) {
            var result = $.map($markup.find(".dx-command-container"), function(element) {
                    return $(element).data("dxCommandContainer")
                });
            return result
        },
        _arrangeCommandsToContainers: function(commands, containers) {
            var self = this;
            $.each(containers, function(index, container) {
                container.arrangeCommands(commands, $.proxy(self._attachCommandsToContainer, self))
            })
        },
        _attachCommandsToContainer: function(commands, $container, options) {
            var handled = false;
            $.each(this.commandsToWidgetRegistry, function(index, commandsToWidget) {
                handled = commandsToWidget(commands, $container, options);
                return !handled
            });
            if (!handled)
                this._defaultCommandsToContainer(commands, $container, options)
        },
        _defaultCommandsToContainer: function($container, locations) {
            $.each(locations, function(index, location) {
                $.each(location.commands, function(index, command) {
                    var $source = command.rootElement();
                    if ($source) {
                        $container.append($source);
                        $source.on("click", function() {
                            command.execute()
                        })
                    }
                })
            })
        },
        layoutCommands: function($markup, extraCommands) {
            extraCommands = extraCommands || [];
            var markupCommands = this._findCommands($markup);
            var viewRelatedCommands = DX.framework.utils.mergeCommands(extraCommands, markupCommands);
            var allCommands = DX.framework.utils.mergeCommands(this.globalCommands, viewRelatedCommands);
            var commandContainers = this._findCommandContainers($markup);
            this._arrangeCommandsToContainers(allCommands, commandContainers)
        }
    })
})(jQuery, DevExpress);

// Module framework, file framework.layoutController.js

(function($, DX, undefined) {
    var Class = DX.Class,
        NAVIGATION_TARGETS = DX.framework.NavigationManager.NAVIGATION_TARGETS;
    var PLACEHOLDERS_SELECTOR = ".dx-content-placeholder:not(.dx-content-placeholder .dx-content-placeholder)";
    var placeholderSelector = function(placeholderId) {
            return ".dx-content-placeholder-" + placeholderId
        };
    DX.framework.html.DefaultLayoutController = Class.inherit({
        ctor: function(options) {
            if (options)
                this.init(options)
        },
        init: function(options) {
            this._navigationManager = options.navigationManager;
            this.$viewPort = options.$viewPort;
            this._prevViewInfo = {}
        },
        activate: function(){},
        deactivate: function(){},
        showView: function(viewInfo, direction) {
            return this._showViewImpl(viewInfo, direction)
        },
        _onRenderComplete: function(viewInfo){},
        _showViewImpl: function(viewInfo, direction) {
            var self = this,
                $markup = viewInfo.renderResult.$markup,
                deferred = $.Deferred();
            viewInfo.renderResult.renderComplete.add(function() {
                self._onRenderComplete(viewInfo)
            });
            if (viewInfo.layoutName === self._prevViewInfo.layoutName) {
                var transitions = $.map(self.$viewPort.find(PLACEHOLDERS_SELECTOR), function(placeholderElement) {
                        var $placeholder = $(placeholderElement),
                            placeholder = $placeholder.data("dxContentPlaceholder"),
                            transitionType = self._disableTransitions ? "none" : placeholder.option("transition");
                        return {
                                destination: $placeholder,
                                source: $markup.find(placeholderSelector(placeholder.option("name"))),
                                type: transitionType || "none",
                                direction: direction || "none"
                            }
                    });
                setTimeout(function() {
                    self._executeTransitions(transitions).done(function() {
                        self._changeView(viewInfo);
                        deferred.resolve()
                    })
                })
            }
            else {
                self._changeView(viewInfo);
                deferred.resolve()
            }
            self._prevViewInfo = viewInfo;
            return deferred.promise()
        },
        _changeView: function(viewInfo) {
            var $markup = viewInfo.renderResult.$markup;
            DX.framework.html.utils.removeFromViewPort(this.$viewPort.children());
            this.$viewPort.append($markup);
            $markup.show()
        },
        _executeTransitions: function(transitions) {
            var self = this;
            var animatedTransitions = $.map(transitions, function(transitionOptions) {
                    return transitionOptions.type !== "none" ? DX.framework.html.TransitionExecutor.create(self.$viewPort, transitionOptions) : null
                });
            var animatedDeferreds = $.map(animatedTransitions, function(transition) {
                    return transition.exec()
                });
            var result = $.when.apply($, animatedDeferreds).done(function() {
                    $.each(animatedTransitions, function(index, transition) {
                        transition.finalize()
                    })
                });
            return result
        },
        _executeTransition: function(options) {
            return transitionsExecutor.exec(options)
        }
    });
    $(function() {
        DX.framework.html.layoutControllers.empty = new DX.framework.html.DefaultLayoutController
    })
})(jQuery, DevExpress);

// Module framework, file framework.templateEngine.js

(function($, DX, undefined) {
    var Class = DX.Class;
    DX.framework.html.KnockoutJSTemplateEngine = Class.inherit({
        ctor: function(options) {
            this.navigationManager = options.navigationManager
        },
        applyTemplate: function(template, model) {
            ko.applyBindings(model, $(template).get(0))
        }
    })
})(jQuery, DevExpress);

// Module framework, file framework.viewEngine.js

(function($, DX, undefined) {
    var isEqual = function(a, b) {
            for (var p in a)
                switch (typeof a[p]) {
                    case'object':
                        if (!isEqual(a[p], b[p]))
                            return false;
                        break;
                    default:
                        if (a[p] != b[p])
                            return false
                }
            for (var p in b)
                if (!a || typeof a[p] == 'undefined')
                    return false;
            return true
        };
    var Class = DX.Class;
    var ui = DX.ui;
    var _VIEW_ROLE = "dxView",
        _LAYOUT_ROLE = "dxLayout";
    DX.framework[_VIEW_ROLE] = ui.Component.inherit({_defaultOptions: function() {
            return $.extend(this.callBase(), {
                    name: null,
                    title: null,
                    layout: null
                })
        }});
    ui.registerComponent(_VIEW_ROLE, DX.framework.dxView);
    DX.framework[_LAYOUT_ROLE] = ui.Component.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {
                    name: null,
                    controller: "empty"
                })
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass("dx-layout")
        }
    });
    ui.registerComponent(_LAYOUT_ROLE, DX.framework.dxLayout);
    DX.framework.dxViewPlaceholder = ui.Component.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {viewName: null})
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass("dx-view-placeholder")
        }
    });
    ui.registerComponent("dxViewPlaceholder", DX.framework.dxViewPlaceholder);
    DX.framework.dxContentPlaceholder = ui.Component.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {name: null})
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass("dx-content-placeholder").addClass("dx-content-placeholder-" + this.option("name"))
        }
    });
    ui.registerComponent("dxContentPlaceholder", DX.framework.dxContentPlaceholder);
    DX.framework.dxContent = ui.Component.inherit({
        _defaultOptions: function() {
            return $.extend(this.callBase(), {targetPlaceholder: null})
        },
        _render: function() {
            this.callBase();
            this.rootElement().addClass("dx-content")
        }
    });
    ui.registerComponent("dxContent", DX.framework.dxContent);
    DX.framework.html.ViewEngine = Class.inherit({
        ctor: function(options) {
            options = options || {};
            this.$root = options.$root;
            this.device = options.device || {};
            this.templateEngine = options.templateEngine;
            this.commandManager = options.commandManager;
            this.dataOptionsAttributeName = options.dataOptionsAttributeName || "data-options";
            this._defaultLayout = options.defaultLayout;
            this._templateMap = {};
            this._pendingViewContainer = null;
            this.viewSelecting = $.Callbacks();
            this.layoutSelecting = $.Callbacks();
            this.modelFromViewDataExtended = $.Callbacks();
            this.layoutApplying = $.Callbacks();
            this.layoutApplied = $.Callbacks()
        },
        init: function() {
            this._initDefaultLayout();
            return this._loadTemplates()
        },
        _initDefaultLayout: function() {
            this._$defaultLayout = $("<div class=\"layout\" data-options=\"dxLayout : { name: 'default', controller: 'default' } \"> \
                <div class=\"content\" data-options=\"dxContentPlaceholder : { name: 'default', transition: 'none' } \" ></div> \
            </div>")
        },
        _getDefaultLayout: function() {
            var $result = this._$defaultLayout.clone();
            this._createComponents($result);
            return $result
        },
        _findTemplate: function(name, role) {
            var self = this,
                $template;
            var $templates = $.grep(this._templateMap[name] || [], function($item) {
                    return $item.data(role)
                });
            if (!$templates.length)
                throw new Error("Error 404: Template not found. role:  " + role + ", name: " + name);
            var fitCount = -1;
            $.each($templates, function(index, $tmpl) {
                var templateFitCount = 0;
                var options = $tmpl.data(role).option();
                $.each(self.device, function(paramName) {
                    var value = options[paramName];
                    if (value === self.device[paramName])
                        templateFitCount++
                });
                if (templateFitCount > fitCount) {
                    fitCount = templateFitCount;
                    $template = $tmpl
                }
            });
            var $result = $template.clone(true, true);
            this._createComponents($result);
            return $result
        },
        findViewTemplate: function(viewName) {
            var findViewEventArgs = {viewName: viewName};
            this.viewSelecting.fire(findViewEventArgs);
            return findViewEventArgs.view ? $(findViewEventArgs.view) : this._findTemplate(viewName, _VIEW_ROLE)
        },
        findLayoutTemplate: function(layoutName) {
            var findLayoutEventArgs = {layoutName: layoutName};
            this.layoutSelecting.fire(findLayoutEventArgs);
            return findLayoutEventArgs.layout ? $(findLayoutEventArgs.layout) : this._findTemplate(layoutName, _LAYOUT_ROLE)
        },
        _extendModelFromViewData: function($view, model) {
            DX.utils.extendFromObject(model, $view.data(_VIEW_ROLE).option());
            this.modelFromViewDataExtended.fire({
                view: $view,
                model: model
            })
        },
        _createComponents: function($markup, types) {
            var self = this;
            var result = [];
            $markup.find("*").addBack().filter("[" + self.dataOptionsAttributeName + "]").each(function(index, element) {
                var $element = $(element),
                    optionsString = $element.attr(self.dataOptionsAttributeName),
                    options;
                try {
                    options = new Function("return {" + optionsString + "}")()
                }
                catch(ex) {
                    throw new Error("Unable to parse options.\nMessage: " + ex + ";\nOptions value: " + optionsString);
                }
                for (var componentName in options)
                    if (!types || $.inArray(componentName, types) > -1)
                        if ($element[componentName]) {
                            $element[componentName](options[componentName]);
                            result.push($element.data(componentName))
                        }
            });
            return result
        },
        _loadTemplatesFromMarkup: function($markup) {
            if ($markup.find("[data-dx-role]").length)
                throw Error("View templates should be updated according to the 13.1 changes. See the ... for more details.");
            var self = this,
                components = self._createComponents($markup, [_VIEW_ROLE, _LAYOUT_ROLE]);
            $.each(components, function(index, component) {
                var $element = component.rootElement(),
                    role = component.NAME,
                    options = component.option(),
                    templateName = options.name,
                    list = self._templateMap[templateName] || [];
                $.each(list, function(index, $item) {
                    var itemComponent = $item.data(role);
                    if (itemComponent && isEqual(options, itemComponent.option()))
                        throw new Error("Several markup templates with the same parameters are found.\r\nDetails: " + $element.attr("data-options"));
                });
                list.push($element);
                self._templateMap[templateName] = list;
                $element.detach()
            })
        },
        _applyLayout: function($view, $layout) {
            var layoutApplyingEventArgs = {
                    $view: $view,
                    $layout: $layout
                };
            this.layoutApplying.fire(layoutApplyingEventArgs);
            var $markup = layoutApplyingEventArgs.$markup ? $(layoutApplyingEventArgs.$markup) : this._applyLayoutCore($view, $layout);
            this.layoutApplied.fire({$markup: $markup});
            return $markup
        },
        _applyLayoutCore: function($view, $layout) {
            if ($view.children(".dx-content").length === 0)
                throw Error("View is being rendered doesn't contain any root element with the data-options=\"dxContent: { targetPlaceholder: '...' }\" attribute defined.");
            var $toMerge = $().add($layout).add($view);
            var $placeholderContents = $toMerge.find(".dx-content");
            $.each($placeholderContents, function() {
                var $placeholderContent = $(this);
                var placeholderId = $placeholderContent.data("dxContent").option("targetPlaceholder");
                var $placeholder = $toMerge.find(".dx-content-placeholder-" + placeholderId);
                $placeholder.empty();
                $placeholder.append($placeholderContent)
            });
            $view.children().hide().appendTo($layout);
            return $layout
        },
        _applyPartialViews: function($render) {
            var self = this;
            $.each($render.find(".dx-view-placeholder"), function() {
                var $partialPlaceholder = $(this);
                var viewName = $partialPlaceholder.data("dxViewPlaceholder").option("viewName");
                var $view = self._findTemplate(viewName, _VIEW_ROLE);
                self._applyPartialViews($view);
                $partialPlaceholder.append($view);
                $view.show()
            })
        },
        _ajaxImpl: function() {
            return $.ajax.apply($, arguments)
        },
        _loadTemplates: function() {
            var self = this;
            this._templateMap = {};
            this._loadTemplatesFromMarkup(this.$root.children());
            var tasks = [];
            var winPhonePrefix;
            if (location.protocol.indexOf("wmapp") >= 0)
                winPhonePrefix = location.protocol + "www/";
            $("head").find("link[rel='dx-template']").each(function(index, link) {
                var url = $(link).attr("href");
                var task = self._ajaxImpl({
                        url: (winPhonePrefix || "") + url,
                        isLocal: winPhonePrefix ? true : undefined,
                        success: function(data) {
                            self._loadTemplatesFromMarkup(DX.utils.createMarkupFromString(data))
                        },
                        dataType: "html"
                    });
                tasks.push(task)
            });
            return $.when.apply($, tasks)
        },
        afterViewSetup: function(viewInfo) {
            this._ensureViewTemplate(viewInfo);
            this._extendModelFormViewTemplate(viewInfo.$viewTemplate, viewInfo.model)
        },
        _extendModelFormViewTemplate: function($viewTemplate, model) {
            this._extendModelFromViewData($viewTemplate, model)
        },
        _ensureTemplates: function(viewInfo) {
            this._ensureViewTemplate(viewInfo);
            this._ensureLayoutTemplate(viewInfo)
        },
        _ensureViewTemplate: function(viewInfo) {
            viewInfo.$viewTemplate = viewInfo.$viewTemplate || this.findViewTemplate(viewInfo.viewName);
            return viewInfo.$viewTemplate
        },
        _ensureLayoutTemplate: function(viewInfo) {
            if (!viewInfo.$layoutTemplate) {
                var $viewTemplate = viewInfo.$viewTemplate;
                var layoutName = $viewTemplate.data(_VIEW_ROLE).option("layout") || this._defaultLayout,
                    $layoutTemplate;
                viewInfo.layoutName = layoutName;
                if (layoutName)
                    $layoutTemplate = this.findLayoutTemplate(layoutName);
                else {
                    $layoutTemplate = this._getDefaultLayout();
                    $viewTemplate.wrapInner("<div data-options=\"dxContent : { targetPlaceholder: 'default' } \"></div>");
                    this._createComponents($viewTemplate)
                }
                viewInfo.$layoutTemplate = $layoutTemplate
            }
        },
        renderBlankView: function(viewInfo, $renderTarget) {
            this._ensureTemplates(viewInfo);
            var $markup = viewInfo.$layoutTemplate;
            $markup.appendTo($renderTarget);
            this._applyPartialViews($markup);
            this.templateEngine.applyTemplate($markup, viewInfo.model);
            this.commandManager.layoutCommands($markup);
            viewInfo.renderResult = {
                $markup: $markup,
                layoutControllerName: $markup.data(_LAYOUT_ROLE).option("controller"),
                renderComplete: $.Callbacks()
            }
        },
        renderCompleteView: function(viewInfo) {
            if (viewInfo.renderResult.rendered)
                return;
            viewInfo.renderResult.rendered = true;
            var model = viewInfo.model || {};
            var $viewTemplate = viewInfo.$viewTemplate;
            var $markup = viewInfo.renderResult.$markup;
            this._applyPartialViews($viewTemplate);
            this._applyLayout($viewTemplate, $markup);
            this.templateEngine.applyTemplate($markup, model);
            this.commandManager.layoutCommands($markup, model.commands);
            viewInfo.renderResult.renderComplete.fire()
        }
    })
})(jQuery, DevExpress);

// Module framework, file framework.htmlApplication.js

(function($, DX, undefined) {
    var frameworkNS = DX.framework,
        htmlNS = frameworkNS.html;
    htmlNS.HtmlApplication = frameworkNS.Application.inherit({
        ctor: function(options) {
            options = options || {};
            this.callBase(options);
            this._initViewPort(options.viewPort);
            this.device = options.device || DX.devices.current();
            this._$root = $(options.rootNode || document.body);
            this._$viewPort = $(".dx-viewport");
            if (!this._$viewPort.length)
                this._$viewPort = $("<div class='dx-viewport'></div>").appendTo(document.body);
            this.viewEngine = options.viewEngine || new htmlNS.ViewEngine({
                $root: this._$root,
                device: this.device,
                defaultLayout: options.defaultLayout,
                templateEngine: options.templateEngine || new htmlNS.KnockoutJSTemplateEngine({navigationManager: this.navigationManager}),
                commandManager: options.commandManager || new htmlNS.CommandManager({globalCommands: this.navigation})
            });
            this.components.push(this.viewEngine);
            this.viewRendered = $.Callbacks();
            this._initLayoutControllers();
            this._applyCssTheme(options)
        },
        _disposeView: function(viewInfo) {
            if (viewInfo.renderResult) {
                viewInfo.renderResult.$markup.remove();
                delete viewInfo.renderResult
            }
            this.callBase(viewInfo)
        },
        viewPort: function() {
            return this._$viewPort
        },
        _initViewPort: function(options) {
            options = options || {};
            if (DX.devices.current().platform === "desktop")
                options = $.extend({disabled: true}, options);
            if (!options.disabled)
                DX.ui.initViewport(options)
        },
        _applyCssTheme: function(options) {
            var self = this,
                resultClasses = "dx-viewport ",
                customClasses = options.themeClasses || {},
                iosStripes = options.iosStripes === undefined ? true : options.iosStripes;
            if ($.isFunction(customClasses))
                resultClasses += customClasses(this.device);
            else if ($.isPlainObject(customClasses))
                resultClasses += this._getThemeClasses(this.device, customClasses);
            else if (typeof customClasses === "string")
                resultClasses += customClasses;
            self._$viewPort.addClass(resultClasses)
        },
        _getThemeClasses: function(device, customClasses) {
            var platformToThemeMap = $.extend({
                    ios: "dx-theme-ios dx-theme-ios-typography",
                    android: "dx-theme-android dx-theme-android-typography",
                    desktop: "dx-theme-desktop dx-theme-desktop-typography",
                    win8: "dx-theme-win8 dx-theme-win8-typography",
                    win8phone: "dx-theme-win8 dx-theme-win8-typography"
                }, customClasses);
            var key = device.platform;
            if (device.platform === "win8" && device.phone)
                return platformToThemeMap[key] + " dx-theme-win8phone dx-theme-win8phone-typography";
            return platformToThemeMap[key]
        },
        _initLayoutControllers: function() {
            var self = this;
            $.each(htmlNS.layoutControllers, function(index, controller) {
                if (controller.init)
                    controller.init({
                        app: self,
                        $viewPort: self._$viewPort,
                        navigationManager: self.navigationManager
                    })
            })
        },
        _afterCreateViewModel: function(viewInfo) {
            this.callBase(viewInfo);
            if (this.viewEngine.afterCreateViewModel)
                this.viewEngine.afterCreateViewModel(viewInfo)
        },
        _setCurrentViewAsyncImpl: function(viewInfo, direction) {
            var self = this;
            var result = $.Deferred();
            DX.enqueueAsync(function() {
                self._ensureBlankViewRendered(viewInfo);
                self._highlightCurrentNavigationCommand(viewInfo)
            }).done(function() {
                self._showRenderedView(viewInfo, direction).done(function() {
                    DX.enqueueAsync(function() {
                        self._ensureViewRendered(viewInfo);
                        result.resolve()
                    })
                })
            });
            return result
        },
        _showRenderedView: function(viewInfo, direction) {
            var self = this;
            var layoutControllerName = viewInfo.renderResult.layoutControllerName || "empty";
            var layoutController = htmlNS.layoutControllers[layoutControllerName];
            if (layoutController === undefined)
                throw Error("The '" + layoutControllerName + "' layout controller not found. But the view being shown supposes to use it. Make sure you have a corresponding *.js reference in your app.html");
            var deferred = new $.Deferred;
            DX.enqueue(function() {
                if (self._activeLayoutController !== layoutController) {
                    if (self._activeLayoutController)
                        self._activeLayoutController.deactivate();
                    layoutController.activate();
                    self._activeLayoutController = layoutController
                }
                return layoutController.showView(viewInfo, direction).done(function() {
                        deferred.resolve()
                    })
            });
            return deferred.promise()
        },
        _ensureBlankViewRendered: function(viewInfo) {
            if (!viewInfo.renderResult) {
                this.viewEngine.renderBlankView(viewInfo, this._$viewPort);
                this._processEvent("blankViewRendered", viewInfo);
                var modelBlankViewRendered = viewInfo.model.blankViewRendered;
                if (modelBlankViewRendered)
                    modelBlankViewRendered.call(viewInfo.model, viewInfo)
            }
        },
        _ensureViewRendered: function(viewInfo) {
            if (!viewInfo.renderResult.rendered) {
                this.viewEngine.renderCompleteView(viewInfo, this._$viewPort);
                this._processEvent("viewRendered", viewInfo);
                var modelViewRendered = viewInfo.model.viewRendered;
                if (modelViewRendered)
                    modelViewRendered.call(viewInfo.model, viewInfo)
            }
        }
    })
})(jQuery, DevExpress);

// Module framework, file framework.transitionExecutor.js

(function($, DX) {
    var TRANSITION_DURATION = 400;
    var TransitionExecutor = DX.Class.inherit({
            ctor: function(container, options) {
                this.container = container;
                this.options = options
            },
            exec: function() {
                var self = this,
                    options = self.options;
                var $source = options.source,
                    $destination = options.destination;
                var wrapperProps = self._createWrapperProps($destination);
                var $sourceWrapper = self._wrapElementContent($source, wrapperProps),
                    $destinationWrapper = self._wrapElementContent($destination, wrapperProps);
                var sourceDomLocation = self._getElementDomLocation($sourceWrapper);
                $sourceWrapper.insertAfter($destinationWrapper);
                this._finalize = function() {
                    self._restoreElementDomLocation($sourceWrapper, sourceDomLocation);
                    self._unwrapElement($destination);
                    self._unwrapElement($source)
                };
                return self._animate($.extend({}, options, {
                        source: $sourceWrapper,
                        destination: $destinationWrapper
                    }))
            },
            finalize: function() {
                if (!this._finalize)
                    throw Error("The 'exec' method should be called before the 'finalize' one.");
                this._finalize()
            },
            _createWrapperProps: function($element) {
                return {
                        position: "absolute",
                        top: 0,
                        left: $element.css("left"),
                        width: $element.outerWidth(true),
                        height: $element.outerHeight(true),
                        overflow: "hidden"
                    }
            },
            _wrapElementContent: function($element, wrapperProps) {
                var $relativeWrapper = $("<div />").css(wrapperProps).css({position: "relative"});
                $element.wrapInner($relativeWrapper);
                $relativeWrapper = $element.children().eq(0);
                var $absoluteWrapper = $("<div />").css(wrapperProps);
                $relativeWrapper.wrapInner($absoluteWrapper);
                return $relativeWrapper.children().eq(0)
            },
            _unwrapElement: function($element) {
                var $relativeWrapper = $element.children().eq(0);
                var $absoluteWrapper = $relativeWrapper.children().eq(0);
                $absoluteWrapper.children().eq(0).unwrap().unwrap()
            },
            _getElementDomLocation: function($element) {
                return {$parent: $element.parent()}
            },
            _restoreElementDomLocation: function($element, location) {
                var $parent = location.$parent;
                $parent.append($element)
            },
            _animate: function() {
                return (new $.Deferred).resolve().promise()
            }
        });
    var SlideTransitionExecutor = TransitionExecutor.inherit({_animate: function(options) {
                if (options.direction === "none")
                    return $.Deferred().resolve().promise();
                var $source = options.source,
                    $destination = options.destination;
                var containerWidth = this.container.width(),
                    destinationLeft = $destination.position().left;
                if (options.direction === "backward")
                    containerWidth = -containerWidth;
                var promiseSource = DX.fx.animate($source, {
                        type: "slide",
                        from: {left: containerWidth + destinationLeft},
                        to: {left: destinationLeft},
                        duration: TRANSITION_DURATION
                    });
                var promiseDestination = DX.fx.animate($destination, {
                        type: "slide",
                        from: {left: destinationLeft},
                        to: {left: destinationLeft - containerWidth},
                        duration: TRANSITION_DURATION
                    });
                return $.when(promiseSource, promiseDestination)
            }});
    var OverflowTransitionExecutor = TransitionExecutor.inherit({_animate: function(options) {
                var $source = options.source,
                    $destination = options.destination,
                    destinationTop = $destination.position().top,
                    destinationLeft = $destination.position().left,
                    containerWidth = this.container.width();
                if (options.direction === "backward")
                    containerWidth = -containerWidth;
                var animations = [];
                if (options.direction === "forward")
                    animations.push(DX.fx.animate($source, {
                        type: "slide",
                        from: {
                            top: destinationTop,
                            left: containerWidth + destinationLeft
                        },
                        to: {left: destinationLeft},
                        duration: TRANSITION_DURATION
                    }));
                else {
                    animations.push(DX.fx.animate($source, {
                        type: "slide",
                        from: {
                            left: destinationLeft,
                            "z-index": 1
                        },
                        to: {left: destinationLeft},
                        duration: TRANSITION_DURATION
                    }));
                    animations.push(DX.fx.animate($destination, {
                        type: "slide",
                        from: {"z-index": 2},
                        to: {left: destinationLeft - containerWidth},
                        duration: TRANSITION_DURATION
                    }))
                }
                return $.when.apply($, animations)
            }});
    var FadeTransitionExecutor = TransitionExecutor.inherit({_animate: function(options) {
                var $source = options.source,
                    $destination = options.destination,
                    d = new $.Deferred;
                $source.css({opacity: 0});
                $destination.animate({opacity: 0}, TRANSITION_DURATION);
                $source.animate({opacity: 1}, TRANSITION_DURATION, function() {
                    d.resolve()
                });
                return d.promise()
            }});
    TransitionExecutor.create = function(container, options) {
        switch (options.type) {
            case"slide":
                return new SlideTransitionExecutor(container, options);
            case"fade":
                return new FadeTransitionExecutor(container, options);
            case"overflow":
                return new OverflowTransitionExecutor(container, options);
            default:
                throw Error("Unknown transition type \"" + options.type + "\"");
        }
    };
    DX.framework.html.TransitionExecutor = TransitionExecutor
})(jQuery, DevExpress);


// Module viz, file namespaces.js

(function(DevExpress) {
    DevExpress.viz = {}
})(DevExpress);

// Module viz, file namespaces.js

(function(DevExpress) {
    DevExpress.viz.core = {}
})(DevExpress);

// Module viz, file tickProvider.js

(function($, DX, undefined) {
    var utils = DX.utils,
        core = DX.viz.core;
    var TICKS_COUNT_LIMIT = 2000;
    core.outOfScreen = {
        x: -1000,
        y: -1000
    };
    core.tickIntervalCalculator = {
        _defaultNumberMultipliers: [1, 2, 3, 5],
        _defaultGridSpacingFactor: 30,
        _getNumericTickInterval: function(deltaCoef, numberMultipliers) {
            var factor,
                result = 0,
                newResult,
                hasResult = false,
                i;
            if (deltaCoef > 1.0)
                for (factor = 1; !hasResult; factor *= 10)
                    for (i = 0; i < numberMultipliers.length; i++) {
                        result = numberMultipliers[i] * factor;
                        if (deltaCoef <= result) {
                            hasResult = true;
                            break
                        }
                    }
            else if (deltaCoef > 0) {
                result = 1;
                for (factor = 0.1; !hasResult; factor /= 10)
                    for (i = numberMultipliers.length - 1; i >= 0; i--) {
                        newResult = numberMultipliers[i] * factor;
                        if (deltaCoef > newResult) {
                            hasResult = true;
                            break
                        }
                        result = newResult
                    }
            }
            return utils.adjustValue(result)
        },
        _getDatetimeTickInterval: function(deltaCoef, numberMultipliers) {
            var datetimeMultipliers = {
                    millisecond: [1, 2, 5, 10, 25, 100, 250, 300, 500],
                    second: [1, 2, 3, 5, 10, 15, 20, 30],
                    minute: [1, 2, 3, 5, 10, 15, 20, 30],
                    hour: [1, 2, 3, 4, 6, 8, 12],
                    day: [1, 2, 3, 5, 7, 10, 14],
                    month: [1, 2, 3, 6]
                },
                result = {},
                factor,
                key,
                specificMultipliers,
                yearsCount,
                i;
            if (deltaCoef < 1.0)
                return {milliseconds: 1};
            for (key in datetimeMultipliers)
                if (datetimeMultipliers.hasOwnProperty(key)) {
                    specificMultipliers = datetimeMultipliers[key];
                    for (i = 0; i < specificMultipliers.length; i++)
                        if (deltaCoef <= utils.convertDateUnitToMilliseconds(key, specificMultipliers[i])) {
                            result[key + 's'] = specificMultipliers[i];
                            return result
                        }
                }
            for (factor = 1; ; factor *= 10)
                for (i = 0; i < numberMultipliers.length; i++) {
                    yearsCount = factor * numberMultipliers[i];
                    if (deltaCoef <= utils.convertDateUnitToMilliseconds('year', yearsCount))
                        return {years: yearsCount}
                }
            return null
        },
        getTickInterval: function(type, businessDelta, screenDelta, gridSpacingFactor, numberMultipliers) {
            var self = this,
                gridSpacingFactor = gridSpacingFactor || self._defaultGridSpacingFactor,
                numberMultipliers = numberMultipliers || self._defaultNumberMultipliers,
                deltaCoef = screenDelta > 0 ? gridSpacingFactor * businessDelta / screenDelta : 0;
            self._testNumberMultipliers = numberMultipliers;
            switch (type) {
                case'numeric':
                    return self._getNumericTickInterval(deltaCoef, numberMultipliers);
                case'dateTime':
                    return self._getDatetimeTickInterval(deltaCoef, numberMultipliers)
            }
            return null
        }
    };
    core.minorTickIntervalCalculator = {
        _defaultNumberMultipliers: [2, 4, 5, 8, 10],
        _defaultGridSpacingFactor: 15,
        _getDatetimeTickInterval: function(businessDelta, deltaCoef, numberMultipliers) {
            var result,
                i;
            for (i = numberMultipliers.length - 1; i >= 0; i--) {
                this.testResultNumberMultiplier = numberMultipliers[i];
                result = Math.floor(businessDelta / numberMultipliers[i]);
                if (deltaCoef <= result)
                    return utils.convertMillisecondsToDateUnits(result)
            }
            return 0
        },
        _getNumericTickInterval: function(businessDelta, deltaCoef, numberMultipliers) {
            var result,
                i;
            for (i = numberMultipliers.length - 1; i >= 0; i--) {
                this.testResultNumberMultiplier = numberMultipliers[i];
                result = businessDelta / numberMultipliers[i];
                if (deltaCoef <= result)
                    return utils.adjustValue(result)
            }
            return 0
        },
        getTickInterval: function(type, businessDelta, screenDelta, gridSpacingFactor, numberMultipliers) {
            var self = this,
                gridSpacingFactor = !utils.isDefined(gridSpacingFactor) ? self._defaultGridSpacingFactor : gridSpacingFactor,
                numberMultipliers = numberMultipliers || self._defaultNumberMultipliers,
                deltaCoef = gridSpacingFactor * businessDelta / screenDelta;
            switch (type) {
                case'numeric':
                    return self._getNumericTickInterval(businessDelta, deltaCoef, numberMultipliers);
                case'dateTime':
                    return self._getDatetimeTickInterval(businessDelta, deltaCoef, numberMultipliers)
            }
            return 0
        }
    };
    core.tickProvider = {
        _areDisplayValuesValid: function(value1, value2, options) {
            var self = this,
                getText = self._getTextFunc(options),
                svgElement1 = options.renderer.drawText(getText(value1), core.outOfScreen.x + options.translator.translateX(value1), core.outOfScreen.y, options.textOptions),
                svgElement2 = options.renderer.drawText(getText(value2), core.outOfScreen.x + options.translator.translateX(value2), core.outOfScreen.y, options.textOptions),
                bBox1 = svgElement1.getBBox(),
                bBox2 = svgElement2.getBBox(),
                result;
            result = bBox1.x + bBox1.width < bBox2.x;
            self._removeElement(svgElement1.element, options);
            self._removeElement(svgElement2.element, options);
            return result
        },
        _removeInvalidDatesWithUnitBegining: function(dates, options) {
            var self = this;
            if (dates.length < 1 || !options.setTicksAtUnitBeginning || !utils.isDate(options.min))
                return;
            if (!self._areDisplayValuesValid(dates[0], dates[1], options))
                dates.splice(1, 1)
        },
        _getMaxDisplayValue: function(values, options) {
            var self = this,
                maxDisplayValue = null,
                getText = self._getTextFunc(options),
                currentDisplayValue,
                i;
            if (values.length > 0) {
                maxDisplayValue = getText(values[0]);
                for (i = 1; i < values.length; i++) {
                    currentDisplayValue = getText(values[i]);
                    if (maxDisplayValue.length < currentDisplayValue.length)
                        maxDisplayValue = currentDisplayValue
                }
            }
            return maxDisplayValue
        },
        _removeElement: function(element, options) {
            options.renderer.svgRoot.element.removeChild(element)
        },
        _getMaxDisplayValueWidth: function(values, options) {
            var self = this,
                value = self._getMaxDisplayValue(values, options),
                svgElement,
                result;
            if (value !== null) {
                svgElement = options.renderer.drawText(value, core.outOfScreen.x, core.outOfScreen.y, options.textOptions);
                result = svgElement.getBBox().width;
                self._removeElement(svgElement.element, options);
                return Math.ceil(result)
            }
            return 0
        },
        _generateStartTick: function(tickInterval, options) {
            var self = this,
                milliseconds = 0,
                boundedRule = options.min - options.max < 0,
                startTick = options.min,
                isDate = utils.isDate(options.min),
                currentTickInterval = isDate ? utils.convertDateTickIntervalToMilliseconds(tickInterval) : tickInterval;
            startTick = Math.floor(options.min / currentTickInterval) * currentTickInterval;
            startTick = isDate ? new Date(startTick) : startTick;
            while (boundedRule === startTick - options.min < 0 && startTick !== options.min)
                startTick = self._nextTick(startTick, tickInterval, options);
            return startTick
        },
        _nextTick: function(tick, tickInterval, options) {
            var nextTick = utils.addInterval(tick, tickInterval, options.min > options.max);
            if (utils.isNumber(options.min))
                nextTick = utils.isExponential(nextTick) ? utils.adjustValue(nextTick) : utils.applyPrecisionByMinDelta(options.min, tickInterval, nextTick);
            if (utils.isDate(options.min) && options.setTicksAtUnitBeginning)
                utils.correctDateWithUnitBeginning(nextTick, tickInterval);
            return nextTick
        },
        _addMinorTicks: function(majorTick1, majorTick2, ticksInfo, options, isReverse) {
            var self = this,
                i,
                dataType = utils.isDate(majorTick1) ? 'dateTime' : 'numeric',
                businessDelta,
                minorTicks = [],
                interval = 0,
                minorTickIntervalsCount = options.minorTickCount + 1,
                intervalsCount,
                tickInterval;
            options.min = majorTick1;
            options.max = majorTick2;
            if (!utils.isDefined(options.tickInterval)) {
                businessDelta = Math.abs(options.max - options.min);
                if (utils.isDefined(options.minorTickCount)) {
                    if (!ticksInfo.majorTicks.autoArrangementStep || ticksInfo.majorTicks.autoArrangementStep <= 1) {
                        intervalsCount = options.minorTickCount + 1;
                        interval = dataType === 'dateTime' ? utils.convertDateTickIntervalToMilliseconds(ticksInfo.majorTickInterval) : ticksInfo.majorTickInterval;
                        minorTickIntervalsCount = Math.round(businessDelta / interval * intervalsCount) || 1
                    }
                    tickInterval = dataType === 'dateTime' ? utils.convertMillisecondsToDateUnits(businessDelta / minorTickIntervalsCount) : businessDelta / minorTickIntervalsCount;
                    if ($.isNumeric(tickInterval))
                        tickInterval = utils.adjustValue(tickInterval)
                }
                else if (utils.isDate(majorTick1))
                    tickInterval = core.minorTickIntervalCalculator.getTickInterval(dataType, businessDelta, businessDelta * options.deltaCoef, options.gridSpacingFactor, options.numberMultipliers)
            }
            options = $.extend(true, {}, options, {tickInterval: tickInterval});
            minorTicks = self.getTicks(options);
            if (isReverse)
                minorTicks.reverse();
            if (minorTicks.length > 0)
                if (Math.ceil(Math.abs(majorTick2 - minorTicks[minorTicks.length - 1]) * options.deltaCoef) < 2)
                    minorTicks.pop();
            for (i = 0; i < minorTicks.length; i++) {
                ticksInfo.minorTicks.push(minorTicks[i]);
                ticksInfo.fullTicks.push(minorTicks[i])
            }
        },
        _addLeftBoudedTicks: function(ticksInfo, min, minorTicksOptions) {
            if (utils.isDefined(min) && ticksInfo.majorTicks[0].valueOf() !== min.valueOf()) {
                minorTicksOptions.addMinMax.max = true;
                this._addMinorTicks(ticksInfo.majorTicks[0], min, ticksInfo, minorTicksOptions, true);
                minorTicksOptions.addMinMax.max = false;
                if (minorTicksOptions.showCustomBoundaryTicks) {
                    if (ticksInfo.minorTicks.length > 0 && ticksInfo.minorTicks[0].valueOf() === min.valueOf())
                        ticksInfo.minorTicks.shift(min);
                    ticksInfo.customBoundaryTicks.push(min);
                    ticksInfo.fullTicks.unshift(min)
                }
            }
        },
        _addRightBoudedTicks: function(ticksInfo, max, minorTicksOptions) {
            var lastMajorTick = ticksInfo.majorTicks[ticksInfo.majorTicks.length - 1];
            ticksInfo.fullTicks.push(lastMajorTick);
            if (utils.isDefined(max) && lastMajorTick.valueOf() !== max.valueOf()) {
                minorTicksOptions.addMinMax.min = false;
                minorTicksOptions.addMinMax.max = true;
                this._addMinorTicks(lastMajorTick, max, ticksInfo, minorTicksOptions);
                if (minorTicksOptions.showCustomBoundaryTicks) {
                    if (ticksInfo.minorTicks.length > 0 && ticksInfo.minorTicks[ticksInfo.minorTicks.length - 1].valueOf() === max.valueOf())
                        ticksInfo.minorTicks.pop(max);
                    ticksInfo.customBoundaryTicks.push(max);
                    ticksInfo.fullTicks.push(max)
                }
            }
        },
        _correctBoundedTicks: function(min, max, ticks, addMinMax) {
            addMinMax = $.extend({}, {
                min: true,
                max: true
            }, addMinMax);
            if (ticks.length > 0) {
                if (!addMinMax.min && ticks[0].valueOf() === min.valueOf())
                    ticks.shift();
                if (!addMinMax.max || ticks[ticks.length - 1].valueOf() !== max.valueOf())
                    ticks.pop()
            }
        },
        _initializeMinorTicksOptions: function(dataType, min, max, screenDelta, ticksInfo, options) {
            var self = this,
                businessDelta,
                hasMinorsCount = utils.isDefined(options.minorTickCount);
            $.extend(true, options, {
                addMinMax: {
                    min: false,
                    max: false
                },
                deltaCoef: self._getDeltaCoef(screenDelta, min, max)
            }, options);
            options.numberMultipliers = hasMinorsCount ? [options.minorTickCount + 1] : options.numberMultipliers;
            options.gridSpacingFactor = hasMinorsCount ? 0 : options.gridSpacingFactor;
            if (!hasMinorsCount && ticksInfo.majorTicks.length > 1) {
                businessDelta = Math.abs(ticksInfo.majorTicks[0] - ticksInfo.majorTicks[1]);
                if (self.needTickIntervalCalculation(businessDelta, ticksInfo.minorTickInterval, options.incidentOccured)) {
                    ticksInfo.minorTickInterval = core.minorTickIntervalCalculator.getTickInterval(dataType, businessDelta, businessDelta * options.deltaCoef, options.gridSpacingFactor, options.numberMultipliers);
                    if (utils.isNumber(min))
                        options.tickInterval = ticksInfo.minorTickInterval;
                    else
                        options.tickInterval = undefined
                }
            }
        },
        _getDataType: function(value) {
            return utils.isDate(value) ? 'dateTime' : 'numeric'
        },
        _getDeltaCoef: function(screenDelta, max, min) {
            return screenDelta / Math.abs(max - min)
        },
        _initializeMajorTicksOptions: function(dataType, min, max, screenDelta, ticksInfo, options) {
            var businessDelta;
            $.extend(true, options, {
                min: min,
                max: max,
                screenDelta: screenDelta,
                isHorizontal: true
            });
            if (utils.isDefined(min) && utils.isDefined(max)) {
                businessDelta = Math.abs(max - min);
                if (this.needTickIntervalCalculation(businessDelta, ticksInfo.majorTickInterval, options.incidentOccured)) {
                    options.isStartTickGenerated = true;
                    ticksInfo.majorTickInterval = core.tickIntervalCalculator.getTickInterval(dataType, businessDelta, screenDelta, options.gridSpacingFactor, options.numberMultipliers);
                    options.tickInterval = ticksInfo.majorTickInterval
                }
            }
        },
        _getTextFunc: function(options) {
            return options.getText || function(value) {
                    return value.toString()
                }
        },
        needTickIntervalCalculation: function(businessDelta, tickInterval, incidentOccured) {
            var date;
            if (utils.isDefined(tickInterval)) {
                if (!utils.isNumber(tickInterval)) {
                    date = new Date;
                    tickInterval = utils.addInterval(date, tickInterval) - date;
                    if (!tickInterval)
                        return true
                }
                if (utils.isNumber(tickInterval))
                    if (tickInterval > 0 && businessDelta / tickInterval > TICKS_COUNT_LIMIT) {
                        if (incidentOccured)
                            incidentOccured('Tick count is too big. So, the tick interval is specified automatically.')
                    }
                    else
                        return false
            }
            return true
        },
        getAutoArrangementStep: function(ticks, options) {
            var self = this,
                maxDisplayValueWidth = self._getMaxDisplayValueWidth(ticks, options),
                requiredValuesCount;
            if (maxDisplayValueWidth > 0) {
                requiredValuesCount = Math.floor(options.screenDelta / (maxDisplayValueWidth + options.textSpacing));
                return Math.ceil(ticks.length / requiredValuesCount)
            }
            return 1
        },
        getAutoArrangementTicks: function(ticks, options, step) {
            var self = this,
                resultTicks = ticks,
                step = utils.isNumber(step) ? step : self.getAutoArrangementStep(ticks, options),
                i;
            if (step > 1) {
                resultTicks = [];
                for (i = 0; i < ticks.length; i += step)
                    resultTicks.push(ticks[i])
            }
            self._removeInvalidDatesWithUnitBegining(resultTicks, options);
            resultTicks.autoArrangementStep = step;
            return resultTicks
        },
        getTickIntervals: function(min, max, screenDelta, majorTicksOptions, minorTicksOptions) {
            var self = this,
                i,
                businessDelta,
                dataType = self._getDataType(min),
                ticksInfo = {
                    majorTickInterval: majorTicksOptions.tickInterval,
                    minorTickInterval: minorTicksOptions.tickInterval,
                    majorTicks: []
                };
            self._initializeMajorTicksOptions(dataType, min, max, screenDelta, ticksInfo, majorTicksOptions);
            if (utils.isDefined(min) && utils.isDefined(max)) {
                ticksInfo.majorTicks.push(min);
                ticksInfo.majorTicks.push(self._nextTick(min, ticksInfo.majorTickInterval, {
                    min: min,
                    max: max,
                    setTicksAtUnitBeginning: majorTicksOptions.setTicksAtUnitBeginning
                }));
                businessDelta = Math.abs(ticksInfo.majorTicks[0] - ticksInfo.majorTicks[1]);
                self._initializeMinorTicksOptions(dataType, min, max, screenDelta, ticksInfo, minorTicksOptions)
            }
            return ticksInfo
        },
        getFullTicks: function(min, max, screenDelta, majorTicksOptions, minorTicksOptions) {
            var self = this,
                i,
                dataType = self._getDataType(min),
                ticksInfo = {
                    customBoundaryTicks: [],
                    fullTicks: [],
                    majorTickInterval: majorTicksOptions.tickInterval,
                    majorTicks: [],
                    minorTickInterval: minorTicksOptions.tickInterval,
                    minorTicks: []
                };
            self._initializeMajorTicksOptions(dataType, min, max, screenDelta, ticksInfo, majorTicksOptions);
            ticksInfo.majorTicks = self.getTicks(majorTicksOptions);
            if (utils.isDefined(min) && utils.isDefined(max) && ticksInfo.majorTicks.length > 0) {
                if (ticksInfo.majorTicks.autoArrangementStep && ticksInfo.majorTicks.autoArrangementStep > 1 && !utils.isDefined(minorTicksOptions.tickInterval) && !utils.isDefined(minorTicksOptions.minorTickCount))
                    minorTicksOptions.tickInterval = ticksInfo.minorTickInterval = majorTicksOptions.tickInterval;
                self._initializeMinorTicksOptions(dataType, min, max, screenDelta, ticksInfo, minorTicksOptions);
                self._addLeftBoudedTicks(ticksInfo, min, minorTicksOptions);
                for (i = 0; i < ticksInfo.majorTicks.length - 1; i++) {
                    ticksInfo.fullTicks.push(ticksInfo.majorTicks[i]);
                    self._addMinorTicks(ticksInfo.majorTicks[i], ticksInfo.majorTicks[i + 1], ticksInfo, minorTicksOptions)
                }
                self._addRightBoudedTicks(ticksInfo, max, minorTicksOptions)
            }
            return ticksInfo
        },
        getTicks: function(options) {
            var self = this,
                ticks = [],
                tick,
                boundedRule = options.max - options.min > 0,
                leftBound,
                rightBound,
                tickInterval,
                isStartTickGenerated = options.isStartTickGenerated,
                businessDelta,
                useTicksAutoArrangement = options.useTicksAutoArrangement;
            if (!utils.isDefined(options.min) || !utils.isDefined(options.max) || isNaN(options.min) || isNaN(options.max)) {
                ticks = options.isHorizontal ? ['canvas_position_left', 'canvas_position_center', 'canvas_position_right'] : ['canvas_position_bottom', 'canvas_position_middle', 'canvas_position_top'];
                useTicksAutoArrangement = false;
                ticks.hideLabels = true
            }
            else {
                tickInterval = $.isNumeric(options.min) && $.isNumeric(options.max) && !$.isNumeric(options.tickInterval) ? undefined : options.tickInterval;
                businessDelta = Math.abs(options.max - options.min);
                if (this.needTickIntervalCalculation(businessDelta, tickInterval, options.incidentOccured)) {
                    isStartTickGenerated = utils.isDefined(isStartTickGenerated) ? isStartTickGenerated : true;
                    tickInterval = core.tickIntervalCalculator.getTickInterval(utils.isDate(options.min) ? 'dateTime' : 'numeric', Math.abs(options.max - options.min), options.screenDelta, options.gridSpacingFactor, options.numberMultipliers)
                }
                self.isTestStartTickGenerated = isStartTickGenerated;
                self.isTestTickInterval = tickInterval;
                if (tickInterval.valueOf() !== 0 && options.min.valueOf() !== options.max.valueOf()) {
                    tick = isStartTickGenerated ? self._generateStartTick(tickInterval, options) : options.min;
                    do {
                        ticks.push(tick);
                        tick = self._nextTick(tick, tickInterval, options);
                        leftBound = tick - options.min > 0;
                        rightBound = options.max - tick > 0
                    } while (boundedRule === leftBound && boundedRule === rightBound);
                    ticks.push(tick);
                    self._correctBoundedTicks(options.min, options.max, ticks, options.addMinMax)
                }
            }
            if (options.beforeTicksAutoArrangement)
                options.beforeTicksAutoArrangement(ticks);
            return useTicksAutoArrangement ? self.getAutoArrangementTicks(ticks, options) : ticks
        }
    }
})(jQuery, DevExpress);

// Module viz, file linearTranslator.js

(function($, DX, undefined) {
    var Class = DX.Class,
        utils = DX.utils,
        math = Math;
    DX.viz.core.LinearTranslator = Class.inherit(function() {
        var ctor = function(businessRanges, canvas) {
                var self = this;
                self.canvas = canvas;
                self.updateBusinessRange(businessRanges)
            };
        var init = function() {
                var self = this,
                    canvas = self.canvas,
                    range = self.businessRange,
                    categoriesX = self.businessRange.categoriesX,
                    categoriesY = self.businessRange.categoriesY,
                    i,
                    category;
                self.width = canvas.width - canvas.left - canvas.right;
                self.height = canvas.height - canvas.top - canvas.bottom;
                if (categoriesX) {
                    self.categoriesXNumber = categoriesX.length;
                    if (range.stickX)
                        self.horizontalInterval = self.width / (self.categoriesXNumber - 1);
                    else
                        self.horizontalInterval = self.width / self.categoriesXNumber;
                    self.categoriesXToPoints = makeCategoriesToPoints(categoriesX, self.businessRange.invertX);
                    self.translateX = translateCategoryX;
                    self.getIntervalX = getCategoryIntervalX
                }
                else {
                    self.translateX = translateContinousX;
                    self.getIntervalX = getContinousIntervalX;
                    if (utils.isNumber(range.minX))
                        self.untranslateX = untranslateContinousX;
                    else if (utils.isDate(range.minX))
                        self.untranslateX = untranslateDatetimeX
                }
                if (categoriesY) {
                    self.categoriesYNumber = categoriesY.length;
                    if (range.stickY)
                        self.verticalInterval = self.height / (self.categoriesYNumber - 1);
                    else
                        self.verticalInterval = self.height / self.categoriesYNumber;
                    self.categoriesYToPoints = makeCategoriesToPoints(categoriesY, self.businessRange.invertY);
                    self.translateY = translateCategoryY;
                    self.getIntervalY = getCategoryIntervalY
                }
                else {
                    self.translateY = translateContinousY;
                    self.getIntervalY = getContinousIntervalY;
                    if (utils.isNumber(range.minY))
                        self.untranslateY = untranslateContinousY;
                    else if (utils.isDate(range.minY))
                        self.untranslateY = untranslateDatetimeY
                }
            };
        var updateBusinessRange = function(businessRange) {
                var self = this;
                self.businessRange = businessRange;
                if (businessRange.minVisibleX === undefined)
                    businessRange.minVisibleX = businessRange.minX;
                if (businessRange.maxVisibleX === undefined)
                    businessRange.maxVisibleX = businessRange.maxX;
                if (businessRange.minVisibleY === undefined)
                    businessRange.minVisibleY = businessRange.minY;
                if (businessRange.maxVisibleY === undefined)
                    businessRange.maxVisibleY = businessRange.maxY;
                self.init()
            };
        var getBusinessRange = function() {
                return this.businessRange
            };
        var zoomX = function(min, max) {
                var self = this,
                    businessRange = self.businessRange;
                businessRange.minVisibleX = min;
                businessRange.maxVisibleX = max;
                businessRange.applyEqualLimitsMargins();
                self.init()
            };
        var zoomY = function(min, max) {
                var self = this,
                    businessRange = self.businessRange;
                businessRange.minVisibleY = min;
                businessRange.maxVisibleY = max;
                businessRange.applyEqualLimitsMargins();
                self.init()
            };
        var translateSpecialCases = function(self, value, position) {
                var parsedValue = (value + '').match(/canvas_position_(.*)/),
                    canvas = self.canvas,
                    categoryRecord,
                    range = self.businessRange;
                if (parsedValue) {
                    value = parsedValue[1];
                    if (value === 'default') {
                        if (range['minVisible' + position] <= 0 && 0 <= range['maxVisible' + position])
                            return self['translate' + position](0);
                        if (position === 'X')
                            if (range.invertX)
                                return canvas.left + self.width;
                            else
                                return canvas.left;
                        else if (range.invertY)
                            return canvas.top;
                        else
                            return canvas.top + self.height
                    }
                    if (position === "X") {
                        if (value === 'left')
                            return canvas.left;
                        if (value === 'center')
                            return canvas.left + self.width / 2;
                        if (value === 'right')
                            return canvas.left + self.width
                    }
                    else {
                        if (value === 'bottom')
                            return canvas.top + self.height;
                        if (value === 'middle')
                            return canvas.top + self.height / 2;
                        if (value === 'top')
                            return canvas.top
                    }
                }
                return null
            };
        var translateContinousX = function(bpX) {
                var self = this,
                    ranges = self.businessRange,
                    canvas = self.canvas,
                    result;
                var specialValue = translateSpecialCases(self, bpX, "X");
                if (utils.isDefined(specialValue))
                    return specialValue;
                if (bpX < ranges.minX)
                    return null;
                if (bpX > ranges.maxX)
                    return null;
                if (ranges.invertX)
                    result = canvas.left + (1 - (bpX - ranges.minVisibleX) / (ranges.maxVisibleX - ranges.minVisibleX)) * self.width;
                else
                    result = canvas.left + (bpX - ranges.minVisibleX) / (ranges.maxVisibleX - ranges.minVisibleX) * self.width;
                return math.round(result)
            };
        var untranslateContinousX = function(posX) {
                var self = this,
                    ranges = self.businessRange,
                    canvas = self.canvas;
                if (posX < canvas.left)
                    return null;
                if (posX > canvas.left + self.width)
                    return null;
                if (ranges.invertX)
                    return ranges.minVisibleX + (self.width - (posX - canvas.left)) * (ranges.maxVisibleX - ranges.minVisibleX) / self.width;
                else
                    return ranges.minVisibleX + (posX - canvas.left) * (ranges.maxVisibleX - ranges.minVisibleX) / self.width
            };
        var untranslateDatetimeX = function(posX) {
                var self = this,
                    ranges = self.businessRange,
                    canvas = self.canvas;
                if (posX < canvas.left)
                    return null;
                if (posX > canvas.left + self.width)
                    return null;
                if (ranges.invertX)
                    return new Date(ranges.minVisibleX.valueOf() + (self.width - (posX - canvas.left)) * (ranges.maxVisibleX - ranges.minVisibleX) / self.width);
                else
                    return new Date(ranges.minVisibleX.valueOf() + (posX - canvas.left) * (ranges.maxVisibleX - ranges.minVisibleX) / self.width)
            };
        var translateContinousY = function(bpY) {
                var self = this,
                    ranges = self.businessRange,
                    canvas = self.canvas,
                    result;
                var specialValue = translateSpecialCases(self, bpY, "Y");
                if (utils.isDefined(specialValue))
                    return specialValue;
                if (bpY < ranges.minY)
                    return null;
                if (bpY > ranges.maxY)
                    return null;
                if (ranges.invertY)
                    result = canvas.height - canvas.bottom - (1 - (bpY - ranges.minVisibleY) / (ranges.maxVisibleY - ranges.minVisibleY)) * self.height;
                else
                    result = canvas.height - canvas.bottom - (bpY - ranges.minVisibleY) / (ranges.maxVisibleY - ranges.minVisibleY) * self.height;
                return math.round(result)
            };
        var untranslateContinousY = function(posY) {
                var self = this,
                    ranges = self.businessRange,
                    canvas = self.canvas;
                if (posY < canvas.top)
                    return null;
                if (posY > canvas.top + self.height)
                    return null;
                if (ranges.invertY)
                    return ranges.maxVisibleY - (self.height - (posY - canvas.top)) * (ranges.maxVisibleY - ranges.minVisibleY) / self.height;
                else
                    return ranges.maxVisibleY - (posY - canvas.top) * (ranges.maxVisibleY - ranges.minVisibleY) / self.height
            };
        var untranslateDatetimeY = function(posY) {
                var self = this,
                    ranges = self.businessRange,
                    canvas = self.canvas;
                if (posY < canvas.top)
                    return null;
                if (posY > canvas.top + self.height)
                    return null;
                if (ranges.invertY)
                    return new Date(ranges.maxVisibleY.valueOf() - (self.height - (posY - canvas.top)) * (ranges.maxVisibleY - ranges.minVisibleY) / self.height);
                else
                    return new Date(ranges.maxVisibleY.valueOf() - (posY - canvas.top) * (ranges.maxVisibleY - ranges.minVisibleY) / self.height)
            };
        var translateCategoryX = function(category) {
                var self = this,
                    canvas = self.canvas,
                    categoryRecord,
                    stickX = self.businessRange.stickX,
                    result = 0;
                var specialValue = translateSpecialCases(self, category, "X");
                if (utils.isDefined(specialValue))
                    return specialValue;
                categoryRecord = self.categoriesXToPoints[category];
                if (categoryRecord)
                    if (stickX)
                        result = canvas.left + self.horizontalInterval * categoryRecord.index;
                    else
                        result = canvas.left + self.horizontalInterval * (categoryRecord.index + 0.5);
                return math.round(result)
            };
        var getCategoryIntervalX = function() {
                var self = this;
                return self.horizontalInterval
            };
        var translateCategoryY = function(category) {
                var self = this,
                    canvas = self.canvas,
                    categoryRecord,
                    stickY = self.businessRange.stickY,
                    result = 0;
                var specialValue = translateSpecialCases(self, category, "Y");
                if (utils.isDefined(specialValue))
                    return specialValue;
                categoryRecord = self.categoriesYToPoints[category];
                if (categoryRecord)
                    if (stickY)
                        result = canvas.top + self.verticalInterval * categoryRecord.index;
                    else
                        result = canvas.top + self.verticalInterval * (categoryRecord.index + 0.5);
                return math.round(result)
            };
        var getCategoryIntervalY = function() {
                var self = this;
                return self.verticalInterval
            };
        var getContinousIntervalX = function() {
                var self = this,
                    result = 0;
                if (self.businessRange.intervalX !== undefined)
                    result = self.width * self.businessRange.intervalX / (self.businessRange.maxX - self.businessRange.minX);
                return Math.round(result)
            };
        var getContinousIntervalY = function() {
                var self = this,
                    result = 0;
                if (self.businessRange.intervalY !== undefined)
                    result = self.height * self.businessRange.intervalY / (self.businessRange.maxY - self.businessRange.minY);
                return Math.round(result)
            };
        var getBusinessVisibleArea = function() {
                var self = this,
                    range = self.businessRange,
                    visibleArea = {};
                visibleArea.minX = range.minVisibleX;
                visibleArea.maxX = range.maxVisibleX;
                visibleArea.minY = range.minVisibleY;
                visibleArea.maxY = range.maxVisibleY;
                if (range.categoriesX) {
                    visibleArea.categoriesX = range.categoriesX;
                    visibleArea.minCategoryXPos = 0;
                    visibleArea.maxCategoryXPos = visibleArea.minCategoryXPos + visibleArea.categoriesX.length - 1
                }
                if (range.categoriesY) {
                    visibleArea.categoriesY = range.categoriesY;
                    visibleArea.minCategoryYPos = 0;
                    visibleArea.maxCategoryYPos = visibleArea.minCategoryYPos + visibleArea.categoriesY.length - 1
                }
                return visibleArea
            };
        var getCanvasVisibleArea = function() {
                var self = this,
                    range = self.businessRange,
                    canvas = self.canvas,
                    visibleArea = {};
                visibleArea.minX = canvas.left;
                visibleArea.maxX = canvas.width - canvas.right;
                visibleArea.minY = canvas.top;
                visibleArea.maxY = canvas.height - canvas.bottom;
                return visibleArea
            };
        var makeCategoriesToPoints = function(categories, invert) {
                var categoriesToPoints = {},
                    category,
                    i;
                if (invert)
                    for (i = categories.length - 1; i >= 0; i--) {
                        category = categories[categories.length - 1 - i];
                        categoriesToPoints[category] = {
                            name: category,
                            index: i
                        }
                    }
                else
                    for (i = 0; i < categories.length; i++) {
                        category = categories[i];
                        categoriesToPoints[category] = {
                            name: category,
                            index: i
                        }
                    }
                return categoriesToPoints
            };
        var prototypeObject = {
                ctor: ctor,
                init: init,
                getCanvasVisibleArea: getCanvasVisibleArea,
                getBusinessVisibleArea: getBusinessVisibleArea,
                updateBusinessRange: updateBusinessRange,
                getBusinessRange: getBusinessRange,
                zoomX: zoomX,
                zoomY: zoomY
            };
        prototypeObject.translateCategoryX = translateCategoryX;
        prototypeObject.translateCategoryY = translateCategoryY;
        prototypeObject.getCategoryIntervalX = getCategoryIntervalX;
        prototypeObject.getCategoryIntervalY = getCategoryIntervalY;
        prototypeObject.translateContinousX = translateContinousX;
        prototypeObject.translateContinousY = translateContinousY;
        prototypeObject.getContinousIntervalX = getContinousIntervalX;
        prototypeObject.getContinousIntervalY = getContinousIntervalY;
        prototypeObject.untranslateContinousX = untranslateContinousX;
        prototypeObject.untranslateContinousY = untranslateContinousY;
        prototypeObject.untranslateDatetimeX = untranslateDatetimeX;
        prototypeObject.untranslateDatetimeY = untranslateDatetimeY;
        return prototypeObject
    }())
})(jQuery, DevExpress);

// Module viz, file translator1D.js

(function(DX, undefined) {
    var NaN = window.NaN,
        Number = window.Number;
    DX.viz.core.Translator1D = DX.Class.inherit({
        ctor: function(domainStart, domainEnd, codomainStart, codomainEnd) {
            DX.utils.debug.assertParam(domainStart, 'domainStart was not passed');
            DX.utils.debug.assertParam(domainEnd, 'domainEnd was not passed');
            DX.utils.debug.assertParam(codomainStart, 'codomainStart was not passed');
            DX.utils.debug.assertParam(codomainEnd, 'codomainEnd was not passed');
            var self = this;
            self._domainStart = Number(domainStart);
            self._domainEnd = Number(domainEnd);
            self._codomainStart = Number(codomainStart);
            self._codomainEnd = Number(codomainEnd);
            self._domainDelta = self._domainEnd - self._domainStart;
            self._codomainDelta = self._codomainEnd - self._codomainStart
        },
        getDomainStart: function() {
            return this._domainStart
        },
        getDomainEnd: function() {
            return this._domainEnd
        },
        getCodomainStart: function() {
            return this._codomainStart
        },
        getCodomainEnd: function() {
            return this._codomainEnd
        },
        getDomainRange: function() {
            return this._domainDelta
        },
        getCodomainRange: function() {
            return this._codomainDelta
        },
        translate: function(value) {
            var self = this,
                ratio = (value - self._domainStart) / self._domainDelta;
            return 0 <= ratio && ratio <= 1 ? self._codomainStart + ratio * self._codomainDelta : NaN
        },
        adjust: function(value) {
            var self = this,
                ratio = (value - self._domainStart) / self._domainDelta,
                result = NaN;
            if (ratio < 0)
                result = self._domainStart;
            else if (ratio > 1)
                result = self._domainEnd;
            else if (0 <= ratio && ratio <= 1)
                result = Number(value);
            return result
        }
    })
})(DevExpress);

// Module viz, file rectangle.js

(function(DX, undefined) {
    var isFinite = window.isFinite;
    DX.viz.core.Rectangle = DX.Class.inherit({
        ctor: function(options) {
            var self = this;
            options = options || {};
            self.left = Number(options.left) || 0;
            self.right = Number(options.right) || 0;
            self.top = Number(options.top) || 0;
            self.bottom = Number(options.bottom) || 0
        },
        width: function() {
            return this.right - this.left
        },
        height: function() {
            return this.bottom - this.top
        },
        horizontalMiddle: function() {
            return (this.left + this.right) / 2
        },
        verticalMiddle: function() {
            return (this.top + this.bottom) / 2
        },
        raw: function() {
            var self = this;
            return {
                    left: self.left,
                    top: self.top,
                    right: self.right,
                    bottom: self.bottom
                }
        },
        clone: function() {
            return new this.constructor(this.raw())
        },
        move: function(dx, dy) {
            var result = this.clone();
            if (isFinite(dx) && isFinite(dy)) {
                result.left += Number(dx);
                result.right += Number(dx);
                result.top += Number(dy);
                result.bottom += Number(dy)
            }
            return result
        },
        inflate: function(dx, dy) {
            var result = this.clone();
            if (isFinite(dx) && isFinite(dy)) {
                result.left -= Number(dx);
                result.right += Number(dx);
                result.top -= Number(dy);
                result.bottom += Number(dy)
            }
            return result
        },
        scale: function(factor) {
            var self = this;
            if (factor > 0)
                return self.inflate(self.width() * (factor - 1) / 2, self.height() * (factor - 1) / 2);
            return self.clone()
        }
    })
})(DevExpress);

// Module viz, file themes.js

(function($, DX, undefined) {
    var core = DX.viz.core,
        viz = DX.viz;
    core.findTheme = function(themeName) {
        var themes = viz.themes,
            theme,
            themeId;
        for (themeId = 0; themeId < themes.length; themeId++) {
            theme = themes[themeId];
            if (theme.name === themeName)
                return theme
        }
    };
    core.registerTheme = function(theme, basedOnThemeName) {
        var baseTheme,
            extendedTheme;
        if (!theme || !theme.name || core.findTheme(theme.name))
            return;
        if (basedOnThemeName) {
            baseTheme = core.findTheme(basedOnThemeName);
            if (baseTheme) {
                extendedTheme = $.extend(true, {}, baseTheme, theme);
                viz.themes.push(extendedTheme)
            }
        }
        else
            viz.themes.push(theme)
    }
})(jQuery, DevExpress);

// Module viz, file palette.js

(function($, DX, undefined) {
    var core = DX.viz.core,
        Class = DX.Class,
        utils = DX.utils;
    core.palettes = {
        'default': ['#5F8B95', '#BA4D51', '#AF8A53', '#955F71', '#859666', '#7E688C'],
        'Harmony Light': ['#FCB65E', '#679EC5', '#AD79CE', '#A6C567', '#E18E92', '#DDED6E', '#B7ABEA', '#A8E7E3'],
        'Soft Pastel': ['#7CBAB4', '#92C7E2', '#75B5D6', '#B78C9B', '#F2CA84', '#A7CA74']
    };
    core.findPalette = function(paletteName) {
        return core.palettes[paletteName]
    };
    core.registerPalette = function(paletteName, palette) {
        return core.palettes[paletteName] = palette
    };
    function RingBuf(buf) {
        var ind = 0;
        this.next = function() {
            var res = buf[ind++];
            if (ind == buf.length)
                this.reset();
            return res
        };
        this.reset = function() {
            ind = 0
        }
    }
    core.Palette = Class.inherit({
        ctor: function(palette, stepHighlight) {
            var self = this;
            self.currentColor = 0;
            self.stepHighlight = stepHighlight || 0;
            if ($.isArray(palette))
                self.originalPalette = palette;
            else {
                self.originalPalette = core.findPalette(palette);
                if (!self.originalPalette)
                    self.originalPalette = core.palettes['default']
            }
            self.palette = [];
            self.palette = self.originalPalette.slice(0);
            self.paletteActions = new RingBuf(['highlight', 'highlight', 'darken', 'darken'])
        },
        getNextColor: function() {
            var self = this,
                palette = self.palette,
                color = palette[self.currentColor],
                action;
            self.currentColor++;
            if (self.currentColor >= palette.length) {
                self.currentColor = 0;
                if (self.stepHighlight) {
                    action = self.paletteActions.next();
                    for (var i = 0; i < palette.length; i++)
                        palette[i] = new DevExpress.viz.charts.Color(palette[i])[action](self.stepHighlight)
                }
            }
            return color
        },
        reset: function() {
            this.currentColor = 0;
            this.palette = this.originalPalette.slice(0);
            this.paletteActions.reset()
        }
    })
})(jQuery, DevExpress);

// Module viz, file baseThemeManager.js

(function($, DX, undefined) {
    var viz = DX.viz,
        core = viz.core,
        Class = DX.Class;
    var findThemeOrDefault = function(themeName) {
            var theme = core.findTheme(themeName);
            if (!theme)
                theme = viz.themes[0];
            return theme
        };
    core.BaseThemeManager = Class.inherit({
        ctor: function(userTheme, themeGroupName) {
            var self = this,
                themeName,
                theme,
                themePath;
            userTheme = userTheme || {};
            themeName = typeof userTheme === 'string' ? userTheme : userTheme.name;
            theme = findThemeOrDefault(themeName);
            self.font = $.extend(true, {}, theme.font, userTheme.font || {});
            if (themeGroupName && theme) {
                themePath = themeGroupName.split('.');
                $.each(themePath, function() {
                    theme = theme[this]
                })
            }
            theme = theme || {};
            self.theme = $.extend(true, {}, theme, typeof userTheme === 'string' ? {} : userTheme)
        },
        initializeFont: function(fontOptions) {
            var self = this,
                extendFontOptions = $.extend({}, fontOptions);
            $.extend(fontOptions, self.font, extendFontOptions)
        },
        applyTheme: function(theme, userOptions) {
            userOptions = userOptions || {};
            return $.extend(true, {}, theme, userOptions)
        },
        getTheme: function() {
            return this.theme
        }
    })
})(jQuery, DevExpress);

// Module viz, file textCloud.js

(function(DX, undefined) {
    var min = Math.min;
    DX.viz.core.TextCloud = DX.Class.inherit(function() {
        var DEFAULT_OPTIONS = {
                horMargin: 8,
                verMargin: 4,
                tailLength: 10
            };
        var COEFFICIENTS_MAP = {};
        COEFFICIENTS_MAP['right-bottom'] = COEFFICIENTS_MAP['rb'] = [0, -1, -1, 0, 0, 1, 1, 0];
        COEFFICIENTS_MAP['bottom-right'] = COEFFICIENTS_MAP['br'] = [-1, 0, 0, -1, 1, 0, 0, 1];
        COEFFICIENTS_MAP['left-bottom'] = COEFFICIENTS_MAP['lb'] = [0, -1, 1, 0, 0, 1, -1, 0];
        COEFFICIENTS_MAP['bottom-left'] = COEFFICIENTS_MAP['bl'] = [1, 0, 0, -1, -1, 0, 0, 1];
        COEFFICIENTS_MAP['left-top'] = COEFFICIENTS_MAP['lt'] = [0, 1, 1, 0, 0, -1, -1, 0];
        COEFFICIENTS_MAP['top-left'] = COEFFICIENTS_MAP['tl'] = [1, 0, 0, 1, -1, 0, 0, -1];
        COEFFICIENTS_MAP['right-top'] = COEFFICIENTS_MAP['rt'] = [0, 1, -1, 0, 0, -1, 1, 0];
        COEFFICIENTS_MAP['top-right'] = COEFFICIENTS_MAP['tr'] = [-1, 0, 0, 1, 1, 0, 0, -1];
        return {
                setup: function(options) {
                    var self = this,
                        ops = $.extend({}, DEFAULT_OPTIONS, options),
                        x = ops.x,
                        y = ops.y,
                        type = COEFFICIENTS_MAP[ops.type],
                        cloudWidth = ops.textWidth + 2 * ops.horMargin,
                        cloudHeight = ops.textHeight + 2 * ops.verMargin,
                        tailWidth = ops.tailLength,
                        tailHeight = tailWidth,
                        cx = x,
                        cy = y;
                    if (type[0] & 1)
                        tailHeight = min(tailHeight, cloudHeight / 3);
                    else
                        tailWidth = min(tailWidth, cloudWidth / 3);
                    self._points = [x, y, x += type[0] * (cloudWidth + tailWidth), y += type[1] * (cloudHeight + tailHeight), x += type[2] * cloudWidth, y += type[3] * cloudHeight, x += type[4] * cloudWidth, y += type[5] * cloudHeight, x += type[6] * (cloudWidth - tailWidth), y += type[7] * (cloudHeight - tailHeight)];
                    self._cx = cx + type[0] * tailWidth + (type[0] + type[2]) * cloudWidth / 2;
                    self._cy = cy + type[1] * tailHeight + (type[1] + type[3]) * cloudHeight / 2;
                    self._cloudWidth = cloudWidth;
                    self._cloudHeight = cloudHeight;
                    self._tailLength = ops.tailLength;
                    return self
                },
                points: function() {
                    return this._points.slice(0)
                },
                cx: function() {
                    return this._cx
                },
                cy: function() {
                    return this._cy
                },
                width: function() {
                    return this._cloudWidth
                },
                height: function() {
                    return this._cloudHeight
                },
                tailLength: function() {
                    return this._tailLength
                }
            }
    }())
})(DevExpress);

// Module viz, file parseUtils.js

(function($, DX) {
    var viz = DX.viz,
        core = viz.core,
        Class = DX.Class,
        isDefined = DX.utils.isDefined;
    var parseUtils = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this._incidentOccured = $.isFunction(options.incidentOccured) ? options.incidentOccured : $.noop
            },
            correctValueType: function(type) {
                return type === 'numeric' || type === 'datetime' || type === 'string' ? type : ''
            },
            _parsers: {
                string: function(val) {
                    return isDefined(val) ? '' + val : val
                },
                numeric: function(val) {
                    if (!isDefined(val))
                        return val;
                    var parsedVal = Number(val);
                    if (isNaN(parsedVal))
                        parsedVal = undefined;
                    return parsedVal
                },
                datetime: function(val) {
                    if (!isDefined(val))
                        return val;
                    var parsedVal,
                        numVal = Number(val);
                    if (!isNaN(numVal))
                        parsedVal = new Date(numVal);
                    else
                        parsedVal = new Date(val);
                    if (isNaN(Number(parsedVal)))
                        parsedVal = undefined;
                    return parsedVal
                }
            },
            getParser: function(valueType, entity) {
                var self = this,
                    parser,
                    message = 'valueType is unknown.';
                if (entity)
                    message = 'The type specified as the valueType property of the ' + entity + ' configuration object is unknown.';
                valueType = self.correctValueType(valueType);
                parser = self._parsers[valueType];
                if (!parser)
                    this._incidentOccured.call(null, message);
                return parser || $.noop
            }
        });
    core.ParseUtils = parseUtils
})(jQuery, DevExpress);

// Module viz, file default.js

(function($, DX, undefined) {
    DX.viz.themes = DX.viz.themes || [];
    DX.viz.themes.push({
        name: 'default',
        font: {
            color: '#808080',
            opacity: 0.75,
            family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
            weight: 400,
            size: 12,
            cursor: 'default'
        },
        chart: {
            containerBackgroundColor: '#FFFFFF',
            defaultPalette: 'default',
            commonSeriesSettings: {
                border: {
                    visible: false,
                    width: 2
                },
                hoverMode: 'excludePoints',
                selectionMode: 'includePoints',
                hoverStyle: {
                    hatching: 'none',
                    border: {
                        visible: false,
                        width: 3
                    }
                },
                selectionStyle: {
                    hatching: 'right',
                    border: {
                        visible: false,
                        width: 3
                    }
                },
                point: {
                    visible: true,
                    symbol: 'circle',
                    size: 6,
                    border: {
                        visible: false,
                        width: 1
                    },
                    hoverMode: 'onlyPoint',
                    selectionMode: 'onlyPoint',
                    hoverStyle: {
                        border: {
                            visible: true,
                            width: 4
                        },
                        size: 6
                    },
                    selectionStyle: {
                        border: {
                            visible: true,
                            width: 4
                        },
                        size: 6
                    }
                },
                label: {
                    font: {color: '#FFFFFF'},
                    border: {
                        visible: false,
                        width: 1,
                        color: '#808080',
                        dashStyle: 'solid'
                    },
                    connector: {
                        visible: false,
                        width: 1
                    }
                },
                scatter: {},
                line: {
                    width: 2,
                    dashStyle: 'solid',
                    hoverStyle: {width: 3},
                    selectionStyle: {width: 3}
                },
                stackedline: {
                    width: 2,
                    dashStyle: 'solid',
                    hoverStyle: {width: 3},
                    selectionStyle: {width: 3}
                },
                fullstackedline: {
                    width: 2,
                    dashStyle: 'solid',
                    hoverStyle: {width: 3},
                    selectionStyle: {width: 3}
                },
                stepline: {
                    width: 2,
                    dashStyle: 'solid',
                    hoverStyle: {width: 3},
                    selectionStyle: {width: 3}
                },
                area: {point: {visible: false}},
                stackedarea: {point: {visible: false}},
                fullstackedarea: {point: {visible: false}},
                steparea: {
                    border: {
                        visible: true,
                        width: 2
                    },
                    point: {visible: false},
                    hoverStyle: {border: {
                            visible: true,
                            width: 3
                        }},
                    selectionStyle: {border: {
                            visible: true,
                            width: 3
                        }}
                },
                spline: {
                    width: 2,
                    hoverStyle: {width: 3},
                    selectionStyle: {width: 3}
                },
                splinearea: {point: {visible: false}},
                bar: {cornerRadius: 0},
                stackedbar: {cornerRadius: 0},
                fullstackedbar: {cornerRadius: 0},
                rangebar: {cornerRadius: 0},
                rangearea: {point: {visible: false}},
                rangesplinearea: {point: {visible: false}},
                pie: {
                    border: {
                        visible: false,
                        width: 2,
                        color: '#FFFFFF'
                    },
                    hoverStyle: {border: {
                            visible: true,
                            width: 3,
                            color: '#FFFFFF'
                        }},
                    selectionStyle: {border: {
                            visible: true,
                            width: 3,
                            color: '#FFFFFF'
                        }}
                },
                doughnut: {innerRadius: 0.5},
                candlestick: {
                    width: 2,
                    innerColor: '#ffffff',
                    reduction: {color: '#000000'},
                    hoverStyle: {width: 3},
                    selectionStyle: {width: 3}
                },
                stock: {
                    width: 2,
                    reduction: {color: '#000000'},
                    hoverStyle: {width: 3},
                    selectionStyle: {width: 3}
                }
            },
            legend: {
                verticalAlignment: 'top',
                horizontalAlignment: 'right',
                position: 'outside',
                font: {color: '#808080'},
                visible: true,
                customizeText: undefined,
                itemTextPosition: undefined,
                margin: 20,
                equalColumnWidth: false,
                markerSize: 12,
                backgroundColor: undefined,
                border: {
                    visible: false,
                    width: 1,
                    color: '#808080',
                    cornerRadius: 0,
                    opacity: 0.35,
                    dashStyle: 'solid'
                },
                paddingLeftRight: 20,
                paddingTopBottom: 15,
                columnCount: 0,
                rowCount: 0,
                columnItemSpacing: 20,
                rowItemSpacing: 8
            },
            tooltip: {
                enabled: false,
                font: {
                    family: "'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                    weight: 200,
                    size: 26,
                    color: '#ffffff'
                },
                arrowLength: 10,
                paddingLeftRight: 22,
                paddingTopBottom: 6,
                format: '',
                argumentFormat: '',
                precision: 0,
                argumentPrecision: 0,
                percentPrecision: 0,
                customizeText: undefined
            },
            title: {font: {
                    family: "'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                    weight: 200,
                    color: '#232323',
                    size: 28,
                    opacity: 1
                }},
            commonAxisSettings: {
                discreteAxisDivisionMode: 'betweenLabels',
                visible: false,
                color: '#808080',
                opacity: 0.35,
                width: 1,
                multipleAxesSpacing: 5,
                label: {
                    visible: true,
                    staggered: false,
                    staggeringSpacing: 5,
                    overlappingBehavior: {
                        mode: 'enlargeTickInterval',
                        rotationAngle: 90,
                        staggeringSpacing: 5
                    },
                    precision: 0,
                    format: '',
                    customizeText: undefined,
                    indentFromAxis: 10
                },
                grid: {
                    visible: false,
                    color: '#808080',
                    opacity: 0.35,
                    width: 1
                },
                tick: {
                    visible: false,
                    color: '#808080',
                    opacity: 0.35
                },
                title: {
                    font: {size: 16},
                    margin: 10
                },
                stripStyle: {
                    paddingLeftRight: 10,
                    paddingTopBottom: 5
                }
            },
            horizontalAxis: {
                isHorizontal: true,
                position: 'bottom',
                axisDivisionFactor: 50,
                label: {alignment: "center"},
                stripStyle: {label: {
                        horizontalAlignment: 'center',
                        verticalAlignment: 'top'
                    }}
            },
            verticalAxis: {
                isHorizontal: false,
                position: 'left',
                axisDivisionFactor: 30,
                label: {alignment: "right"},
                stripStyle: {label: {
                        horizontalAlignment: 'left',
                        verticalAlignment: 'center'
                    }}
            },
            argumentAxisStyle: {},
            valueAxisStyle: {grid: {visible: true}},
            commonPaneSettings: {border: {
                    color: '#808080',
                    opacity: 0.35,
                    width: 1
                }}
        },
        gauge: {
            area: {
                radius: 120,
                fromAngle: 225,
                toAngle: 315,
                formatText: undefined
            },
            range: {
                type: 'multicolor',
                sizes: {length: 5},
                colors: ['#00FF00', '#FFFF00', '#FF0000']
            },
            scale: {
                type: 'TODO',
                tick: {
                    sizes: {
                        length: 5,
                        width: 2
                    },
                    color: '#BFBFBF'
                },
                text: {
                    indent: 10,
                    color: '#7F7F7F',
                    font: {
                        family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                        weight: 400,
                        size: 12
                    }
                }
            },
            needle: {
                type: 'line',
                sizes: {width: 3},
                color: '#BFBFBF'
            },
            marker: {
                type: 'triangle',
                sizes: {
                    length: 12,
                    width: 10
                },
                color: '#679EC5'
            }
        },
        rangeSelector: {
            containerBackgroundColor: 'white',
            scale: {
                label: {
                    topIndent: 7,
                    font: {size: 11}
                },
                tick: {
                    width: 1,
                    color: 'black',
                    opacity: 0.1
                },
                marker: {
                    separatorHeight: 33,
                    topIndent: 10,
                    textLeftIndent: 7,
                    textTopIndent: 11
                }
            },
            sliderMarker: {
                padding: 7,
                pointerSize: 6,
                color: '#9B9B9B',
                invalidRangeColor: 'red',
                font: {
                    color: 'white',
                    size: 11
                }
            },
            sliderHandles: {
                width: 1,
                color: 'black',
                opacity: 0.1
            },
            shutter: {
                color: undefined,
                opacity: 0.75
            },
            background: {color: "#C0BAE1"},
            chart: {
                containerBackgroundColor: undefined,
                defaultPalette: 'default',
                commonSeriesSettings: {
                    border: {
                        visible: false,
                        width: 1
                    },
                    hoverStyle: {border: {}},
                    selectionStyle: {border: {}},
                    point: {
                        visible: false,
                        symbol: 'circle',
                        border: {
                            visible: false,
                            width: 1
                        },
                        size: 6,
                        hoverStyle: {border: {}},
                        selectionStyle: {border: {}}
                    },
                    line: {width: 2},
                    stackedline: {width: 2},
                    fullstackedline: {width: 2},
                    area: {},
                    stackedarea: {},
                    fullstackedarea: {},
                    spline: {width: 2},
                    splinearea: {},
                    bar: {cornerRadius: 0},
                    stackedbar: {cornerRadius: 0},
                    fullstackedbar: {cornerRadius: 0},
                    rangebar: {cornerRadius: 0},
                    rangearea: {},
                    rangesplinearea: {},
                    pie: {},
                    candlestick: {
                        width: 2,
                        innerColor: '#ffffff',
                        reduction: {color: '#000000'}
                    },
                    stock: {
                        width: 2,
                        reduction: {color: '#000000'}
                    }
                }
            }
        }
    })
})(jQuery, DevExpress);

// Module viz, file namespaces.js

(function(DevExpress) {
    DevExpress.viz.renderers = {}
})(DevExpress);

// Module viz, file svgRenderer.js

(function($, DX) {
    var renderers = DX.viz.renderers,
        utils = DX.utils,
        Class = DX.Class,
        doc = document,
        easingFunctions,
        setGlobalAnimationOptions,
        globalAnimOptions = {
            enabled: true,
            duration: 1000,
            easing: 'easeOutCubic'
        },
        MAX_PIXEL_COUNT = 10000000000;
    (function() {
        var jStep = $.fx.step,
            fxProto = $.fx.prototype,
            baseCur = fxProto['cur'],
            baseD = jStep['d'],
            baseRotate = jStep['rotate'],
            baseTranslate = jStep['translate'],
            getNextAnimStep;
        getNextAnimStep = function(pos, start, end, unit) {
            var easing = globalAnimOptions.easing;
            return easingFunctions[easing || 'easeOutCubic'](pos, start, end) + (unit == '%' ? '%' : '')
        };
        fxProto['cur'] = function() {
            var fx = this,
                prop = fx.prop;
            if (fx.elem instanceof BaseSvgElement) {
                if (prop === 'svgheight' || prop === 'svgwidth')
                    prop = prop.substr(3);
                return $(fx.elem.element).attr(prop)
            }
            return baseCur.apply(fx, arguments)
        };
        $.each(['x', 'y', 'cx', 'cy', 'r', 'rx', 'ry', 'strokeWidth'], function(i, prop) {
            var propName = DX.inflector.camelize(prop),
                elem,
                baseFn = jStep[propName];
            jStep[propName] = function(fx) {
                var elem = fx.elem,
                    animProp;
                if (!(elem instanceof BaseSvgElement)) {
                    baseFn ? baseFn.apply(this, arguments) : 0;
                    return
                }
                animProp = {sharpEdges: false};
                animProp[fx.prop] = getNextAnimStep(fx.pos, fx.start, fx.end, fx.unit);
                elem.applySettings(animProp)
            }
        });
        $.each(['width', 'height'], function(i, prop) {
            var propName = 'svg' + prop,
                elem;
            jStep[propName] = function(fx) {
                var elem = fx.elem,
                    animProp = fx.prop.substr(3),
                    animParams;
                animParams = {sharpEdges: false};
                animParams[animProp] = getNextAnimStep(fx.pos, fx.start || 0, fx.end || 0, fx.unit);
                elem.applySettings(animParams)
            }
        });
        jStep['d'] = function(fx) {
            var elem = fx.elem,
                fromSegments,
                toSegments,
                diff,
                slice,
                end;
            if (!(elem instanceof BaseSvgElement)) {
                baseD ? baseD.apply(this, arguments) : 0;
                return
            }
            if (!fx.initialized) {
                fromSegments = elem.fromSegments || [];
                toSegments = elem.segments || [];
                if (fromSegments.length == 0)
                    fromSegments = [].concat(toSegments);
                diff = toSegments.length - fromSegments.length;
                if (diff > 0) {
                    slice = [].concat(fromSegments).splice(fromSegments.length - diff, diff);
                    fromSegments = fromSegments.concat(slice)
                }
                else if (diff < 0) {
                    slice = [].concat(toSegments).splice(toSegments.length + diff, -diff);
                    toSegments = toSegments.concat(slice)
                }
                fx.start = fromSegments;
                fx.end = toSegments;
                fx.initialized = true
            }
            end = fx.pos === 1 ? fx.end : $.map(fx.start, function(fromSeg, i) {
                var toSeg = fx.end[i],
                    seg;
                seg = $.map(fromSeg, function(fromEl, j) {
                    var toEl;
                    if (!$.isNumeric(fromEl))
                        return fromEl;
                    toEl = toSeg[j];
                    return getNextAnimStep(fx.pos, fromEl, toEl)
                });
                return [seg]
            });
            elem.applySettings({d: $.map(end, function(seg, i) {
                    return seg.join(' ')
                }).join(' ')})
        };
        jStep['rotate'] = function(fx) {
            var elem = fx.elem,
                params,
                curTransform,
                angle;
            if (!(elem instanceof BaseSvgElement)) {
                baseRotate ? baseRotate.apply(this, arguments) : 0;
                return
            }
            if (!fx.initialized) {
                params = fx.end;
                curTransform = elem.transformation || {};
                fx.start = curTransform.rotateAngle || 0,
                fx.end = params.angle || 0,
                fx.x = params.x || 0,
                fx.y = params.y || 0;
                fx.initialized = true
            }
            angle = getNextAnimStep(fx.pos, fx.start, fx.end);
            elem.applySettings({rotate: [angle, fx.x, fx.y]})
        };
        jStep['translate'] = function(fx) {
            var elem = fx.elem,
                params,
                curTransform,
                newX,
                newY;
            if (!(elem instanceof BaseSvgElement)) {
                baseTranslate ? baseTranslate.apply(this, arguments) : 0;
                return
            }
            if (!fx.initialized) {
                params = fx.end;
                curTransform = elem.transformation || {};
                fx.startX = curTransform.translateX || 0,
                fx.startY = curTransform.translateY || 0,
                fx.endX = params.x || 0,
                fx.endY = params.y || 0;
                fx.initialized = true
            }
            newX = getNextAnimStep(fx.pos, fx.startX, fx.endX);
            newY = getNextAnimStep(fx.pos, fx.startY, fx.endY);
            elem.applySettings({
                translateX: newX,
                translateY: newY
            })
        }
    })();
    easingFunctions = {
        easeOutCubic: function(pos, start, end) {
            return pos === 1 ? end : (1 - Math.pow(1 - pos, 3)) * (end - start) + +start
        },
        linear: function(pos, start, end) {
            return pos === 1 ? end : pos * (end - start) + +start
        }
    };
    setGlobalAnimationOptions = function(options) {
        if ('enabled' in options)
            globalAnimOptions.enabled = options.enabled;
        if ('duration' in options)
            globalAnimOptions.duration = options.duration;
        if ('easing' in options && easingFunctions[options.easing])
            globalAnimOptions.easing = options.easing
    };
    var BaseSvgElement = Class.inherit({
            ctor: function baseSvgElementCtor(renderer, name, params) {
                var settings;
                this.renderer = renderer;
                this.element = this.createElement(name);
                this.$element = $(this.element);
                settings = $.extend({}, this.defaultSettings ? this.defaultSettings() : {}, params);
                this.applySettings(settings);
                this.__passedParams = params
            },
            createElement: function(nodeName) {
                this._nodeName = nodeName;
                return doc.createElementNS('http://www.w3.org/2000/svg', nodeName)
            },
            append: function(svgElement) {
                var toElement = svgElement || this.renderer.getRoot();
                toElement.element.appendChild(this.element);
                return this
            },
            toForeground: function() {
                this.element.parentNode && this.element.parentNode.appendChild(this.element);
                return this
            },
            applySettings: function(settings) {
                var normalized;
                this.settings = $.extend(this.settings || {}, settings || {});
                this.adjustSettings();
                normalized = this._normalizeSettings(this.settings);
                this.applyStyle(this._style);
                this._applyAttributes(normalized);
                return this
            },
            _applyAttributes: function(settings) {
                this.$element.attr(settings);
                this.__appliedSettings = settings
            },
            adjustSettings: function(){},
            applyStyle: function(style) {
                this.$element.css(style || {});
                this.__appliedStyle = style || {};
                return this
            },
            on: function(events, handler) {
                this.$element.on(events, handler);
                return this
            },
            off: function(events) {
                this.$element.off(events);
                return this
            },
            getBBox: function() {
                var self = this,
                    bBox,
                    element = this.element,
                    transformation = self.transformation,
                    rotateAngle = transformation.rotateAngle || 0,
                    rotateX = transformation.rotateX || 0,
                    rotateY = transformation.rotateY || 0,
                    mabs = Math.abs,
                    mmin = Math.min;
                function bBox(el) {
                    var ret = {};
                    try {
                        if (!$.isFunction(el.getBBox))
                            throw{};
                        else
                            ret = el.getBBox()
                    }
                    catch(e) {
                        ret = {
                            x: 0,
                            y: 0,
                            width: el.offsetWidth || 0,
                            height: el.offsetHeight || 0
                        }
                    }
                    return ret
                }
                bBox = $.extend({}, bBox(element));
                if (rotateAngle) {
                    var cossin = utils.getCosAndSin(rotateAngle),
                        sin = cossin.sin.toFixed(3),
                        cos = cossin.cos.toFixed(3),
                        ltx = bBox.x - rotateX,
                        lty = bBox.y - rotateY,
                        rtx = bBox.x + bBox.width - rotateX,
                        rty = bBox.y - rotateY,
                        lbx = bBox.x - rotateX,
                        lby = bBox.y + bBox.height - rotateY,
                        rbx = bBox.x + bBox.width - rotateX,
                        rby = bBox.y + bBox.height - rotateY,
                        w,
                        h;
                    w = mabs(bBox.height * sin) + mabs(bBox.width * cos);
                    h = mabs(bBox.height * cos) + mabs(bBox.width * sin);
                    bBox.x = mmin(ltx * cos - lty * sin + rotateX, rtx * cos - rty * sin + rotateX, lbx * cos - lby * sin + rotateX, rbx * cos - rby * sin + rotateX);
                    bBox.y = mmin(ltx * sin + lty * cos + rotateY, rtx * sin + rty * cos + rotateY, lbx * sin + lby * cos + rotateY, rbx * sin + rby * cos + rotateY);
                    bBox.width = w;
                    bBox.height = h
                }
                return self._normalizeBBox(bBox)
            },
            _normalizeBBox: function(bBox) {
                var ceil = Math.ceil,
                    floor = Math.floor,
                    $isNumeric = $.isNumeric,
                    rxl = floor(bBox.x),
                    ryt = floor(bBox.y),
                    rxr = ceil(bBox.width + bBox.x),
                    ryb = ceil(bBox.height + bBox.y),
                    width,
                    height;
                bBox.x = $isNumeric(rxl) && rxl < MAX_PIXEL_COUNT && rxl > -MAX_PIXEL_COUNT ? rxl : 0;
                bBox.y = $isNumeric(ryt) && ryt < MAX_PIXEL_COUNT && ryt > -MAX_PIXEL_COUNT ? ryt : 0;
                width = rxr - rxl;
                height = ryb - ryt;
                bBox.width = $isNumeric(width) && width < MAX_PIXEL_COUNT && width > -MAX_PIXEL_COUNT ? width : 0;
                bBox.height = $isNumeric(height) && height < MAX_PIXEL_COUNT && height > -MAX_PIXEL_COUNT ? height : 0;
                bBox.isEmpty = !bBox.x && !bBox.y && !bBox.width && !bBox.height;
                return bBox
            },
            clear: function() {
                this.$element.empty()
            },
            detach: function() {
                this.$element.detach()
            },
            animate: function(params, options, complete) {
                if (globalAnimOptions.enabled) {
                    $.each(['height', 'width'], function(_, propName) {
                        if (propName in params) {
                            params['svg' + propName] = params[propName];
                            delete params[propName]
                        }
                    });
                    $(this).stop();
                    if (complete)
                        $.extend(options, {complete: complete});
                    $(this).animate(params, $.extend({duration: globalAnimOptions.duration}, options))
                }
                else {
                    if (params.translate) {
                        if ('x' in params.translate)
                            params.translateX = params.translate.x;
                        if ('y' in params.translate)
                            params.translateY = params.translate.y;
                        delete params.translate
                    }
                    if (options && options.step) {
                        options.step.call(this, undefined, {pos: 1});
                        options.complete && options.complete.call(this)
                    }
                    else
                        this.applySettings(params)
                }
            },
            show: function(animate) {
                if (animate && globalAnimOptions.enabled)
                    this.$element.show(globalAnimOptions.duration);
                else
                    this.$element.show()
            },
            hide: function(animate) {
                if (animate && globalAnimOptions.enabled)
                    this.$element.hide(globalAnimOptions.duration);
                else
                    this.$element.hide()
            },
            move: function(x, y, animate, animOptions) {
                x = x || 0,
                y = y || 0;
                if (!animate)
                    this.applySettings({
                        translateX: x,
                        translateY: y
                    });
                else
                    this.animate({translate: {
                            x: x,
                            y: y
                        }}, animOptions)
            },
            rotate: function(angle, x, y, animate, animOptions) {
                angle = angle || 0;
                x = x || 0;
                y = y || 0;
                if (!animate)
                    this.applySettings({rotate: [angle, x, y]});
                else
                    this.animate({rotate: {
                            angle: angle,
                            x: x,
                            y: y
                        }}, animOptions)
            },
            remove: function() {
                this.$element.remove()
            },
            _normalizeSettings: function(settings) {
                var key,
                    style,
                    firstChar,
                    styleName,
                    prop,
                    value,
                    normalized = {},
                    fontSetting;
                for (key in settings) {
                    prop = key,
                    value = settings[prop];
                    if (prop === 'align') {
                        prop = 'text-anchor';
                        value = {
                            left: 'start',
                            center: 'middle',
                            right: 'end'
                        }[value]
                    }
                    else if (prop === 'font') {
                        style = this['_style'] = this['_style'] || {};
                        if (!$.isPlainObject(value))
                            continue;
                        $.each(value, function(fontSetting) {
                            switch (fontSetting) {
                                case'color':
                                    styleName = 'fill';
                                    break;
                                case'opacity':
                                    styleName = 'fillOpacity';
                                    break;
                                case'cursor':
                                    styleName = fontSetting;
                                    break;
                                default:
                                    firstChar = fontSetting.charAt(0);
                                    styleName = 'font' + fontSetting.replace(firstChar, firstChar.toUpperCase())
                            }
                            style[styleName] = value[fontSetting]
                        });
                        continue
                    }
                    else if (prop === 'dashStyle') {
                        prop = 'stroke-dasharray';
                        value = value.toLowerCase();
                        value = value === 'solid' ? 'none' : value.replace(/longdash/g, '8,3,').replace(/dash/g, '4,3,').replace(/dot/g, '1,3,').replace(/,$/, '').split(',');
                        if (value !== 'none')
                            value = $.map(value, function(p) {
                                return +p * (settings.strokeWidth || 1)
                            }).join(',')
                    }
                    else if (/^(linecap|linejoin)$/i.test(prop))
                        prop = 'stroke-' + prop;
                    else if (/^(translateX|translateY|rotate)$/i.test(prop)) {
                        this['_' + prop] = value;
                        continue
                    }
                    else if (prop === 'clipId') {
                        prop = 'clip-path';
                        value = 'url(#' + value + ')'
                    }
                    else if (prop === 'style') {
                        this['_style'] = this['_style'] || {};
                        $.extend(true, this['_style'], value);
                        continue
                    }
                    else if (prop === 'text')
                        continue;
                    else if (prop === 'segments')
                        continue;
                    else
                        prop = DX.inflector.dasherize(prop);
                    normalized[prop] = value
                }
                return this._applyTransformation(normalized)
            },
            _applyTransformation: function(settings) {
                this.transformation = {
                    translateX: this._translateX,
                    translateY: this._translateY,
                    rotateAngle: 0,
                    rotateX: 0,
                    rotateY: 0
                };
                var tr = this.transformation;
                var rotate = this._rotate;
                var transformations = [];
                if (utils.isDefined(tr.translateX) || utils.isDefined(tr.translateY))
                    transformations.push('translate(' + (tr.translateX || 0) + ',' + (tr.translateY || 0) + ')');
                if (utils.isDefined(rotate)) {
                    if (utils.isNumber(rotate)) {
                        tr.rotateAngle = rotate;
                        tr.rotateX = settings.x || 0;
                        tr.rotateY = settings.y || 0
                    }
                    else if ($.isArray(rotate)) {
                        tr.rotateAngle = rotate[0] || 0;
                        tr.rotateX = rotate[1] || 0;
                        tr.rotateY = rotate[2] || 0
                    }
                    else if (utils.isObject(rotate)) {
                        tr.rotateAngle = rotate.angle || 0;
                        tr.rotateX = rotate.x || 0;
                        tr.rotateY = rotate.y || 0
                    }
                    transformations.push('rotate(' + tr.rotateAngle + ',' + tr.rotateX + ',' + tr.rotateY + ')')
                }
                if (transformations.length)
                    settings.transform = transformations.join(' ');
                return settings
            }
        });
    var RootSvgElement = BaseSvgElement.inherit({
            defaultSettings: function() {
                return {
                        width: 0,
                        height: 0,
                        style: {'-webkit-tap-highlight-color': 'rgba(0, 0, 0, 0)'},
                        xmlns: 'http://www.w3.org/2000/svg',
                        'xmlns:xlink': 'http://www.w3.org/1999/xlink',
                        version: "1.1"
                    }
            },
            ctor: function(renderer, params) {
                this.callBase(renderer, 'svg', params)
            }
        });
    var RectSvgBaseElement = {
            defaultSettings: function() {
                return {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
            },
            adjustSettings: function() {
                if (!utils.isDefined(this.settings.sharpEdges) || this.settings.sharpEdges) {
                    this.sharpEdges();
                    delete this.settings.sharpEdges
                }
            },
            prepareSettings: function(settings) {
                var maxStrokeWidth,
                    strokeWidthChanged = false,
                    newStrokeWidth,
                    prevStorkeWidth = this.settings && this.settings.strokeWidth;
                if (utils.isDefined(settings.width))
                    this._realWidth = Number(settings.width);
                if (utils.isDefined(settings.height))
                    this._realHeight = Number(settings.height);
                if (utils.isDefined(settings.x))
                    this._realX = Number(settings.x);
                if (utils.isDefined(settings.y))
                    this._realY = Number(settings.y);
                if (utils.isDefined(settings.strokeWidth))
                    this._realStrokeWidth = Number(settings.strokeWidth);
                this._realStrokeWidth = this._realStrokeWidth || this.defaultSettings().strokeWidth || 0;
                maxStrokeWidth = this._realWidth < this._realHeight ? ~~(this._realWidth / 2) : ~~(this._realHeight / 2);
                settings.strokeWidth = Math.min(this._realStrokeWidth, maxStrokeWidth);
                if (settings.strokeWidth !== prevStorkeWidth) {
                    strokeWidthChanged = true;
                    settings.sharpEdges = true
                }
                (utils.isDefined(settings.x) || strokeWidthChanged) && (settings.x = this._realX + settings.strokeWidth / 2);
                (utils.isDefined(settings.y) || strokeWidthChanged) && (settings.y = this._realY + settings.strokeWidth / 2);
                (utils.isDefined(settings.width) || strokeWidthChanged) && (settings.width = this._realWidth - settings.strokeWidth);
                (utils.isDefined(settings.height) || strokeWidthChanged) && (settings.height = this._realHeight - settings.strokeWidth)
            },
            applySettings: function(settings) {
                var settings = $.extend(true, {}, settings);
                this.prepareSettings(settings);
                this.callBase(settings)
            },
            sharpEdges: function() {
                var strokeWidth = Math.round(this.settings.strokeWidth || 0),
                    correction = strokeWidth % 2 / 2;
                this.settings.x = Math.floor(this.settings.x - correction || 0) + correction;
                this.settings.y = Math.floor(this.settings.y - correction || 0) + correction;
                this.settings.width = Math.floor(this.settings.width || 0);
                this.settings.height = Math.floor(this.settings.height || 0);
                this.settings.strokeWidth = strokeWidth
            }
        };
    var ImageSvgElement = BaseSvgElement.inherit(RectSvgBaseElement).inherit({
            ctor: function(renderer, params, href, location) {
                var locationToPreserveAspectRatioMap = {
                        full: 'none',
                        lefttop: 'xMinYMin',
                        leftcenter: 'xMinYMid',
                        leftbottom: 'xMinYMax',
                        centertop: 'xMidYMin',
                        center: 'xMidYMid',
                        centerbottom: 'xMidYMax',
                        righttop: 'xMaxYMin',
                        rightcenter: 'xMaxYMid',
                        rightbottom: 'xMaxYMax'
                    };
                this.href = utils.isDefined(href) ? href : '';
                this.preserveAspectRatio = locationToPreserveAspectRatioMap[(location || '').toLowerCase()];
                this.preserveAspectRatio = this.preserveAspectRatio || 'none';
                this.callBase(renderer, 'image', params)
            },
            adjustSettings: function() {
                this.callBase();
                this.element.setAttributeNS('http://www.w3.org/1999/xlink', 'href', this.href);
                if (this.preserveAspectRatio)
                    this.element.setAttribute('preserveAspectRatio', this.preserveAspectRatio)
            }
        });
    var RectSvgElement = BaseSvgElement.inherit(RectSvgBaseElement).inherit({
            defaultSettings: function() {
                return {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0,
                        rx: 0,
                        ry: 0
                    }
            },
            ctor: function(renderer, params) {
                this.callBase(renderer, 'rect', params)
            }
        });
    var PathSvgElement = BaseSvgElement.inherit({
            defaultSettings: function() {
                return {
                        points: {
                            x: 0,
                            y: 0
                        },
                        fill: 'none',
                        stroke: 'black'
                    }
            },
            getNodeName: function() {
                return 'path'
            },
            getPathAttributeName: function() {
                return 'd'
            },
            ctor: function(renderer, params) {
                this.callBase(renderer, this.getNodeName(), params)
            },
            adjustSettings: function() {
                this.prepareSegments(this.settings)
            },
            applySettings: function(settings) {
                var settings = settings || {};
                if (this.settings && settings.strokeWidth && this.settings.strokeWidth != settings.strokeWidth)
                    settings.sharpEdges = true;
                this.callBase(settings)
            },
            prepareSegments: function(params) {
                if ('points' in params) {
                    var points = params.points,
                        firstElem = points[0],
                        close = this.closePath || params.closePath,
                        segments = [],
                        i;
                    if (utils.isObject(firstElem))
                        segments = $.map(points, function(pt, i) {
                            if (!i)
                                return [['M', pt.x, pt.y]];
                            return [['L', pt.x, pt.y]]
                        });
                    else if (utils.isNumber(firstElem))
                        for (i = 0; i < points.length; i += 2) {
                            if (!i) {
                                segments = [['M', points[i] || 0, points[i + 1] || 0]];
                                continue
                            }
                            segments.push(['L', points[i] || 0, points[i + 1] || 0])
                        }
                    else
                        segments = [['M', 0, 0]];
                    if (close)
                        segments.push(['Z']);
                    this.segments = segments;
                    delete params.points;
                    delete params.closePath;
                    params.sharpEdges = true
                }
                if (params.sharpEdges) {
                    this.sharpEdges();
                    this.combinePathParams(params);
                    delete params.sharpEdges
                }
            },
            customizeSegments: function(segments) {
                return segments
            },
            combinePathParams: function(params) {
                var path;
                this.segments = this.customizeSegments(this.segments);
                if (this.segments) {
                    path = $.map(this.segments, function(seg, i) {
                        return seg.join(' ')
                    });
                    path = path.join(' ');
                    params[this.getPathAttributeName()] = path
                }
            },
            animate: function(params, options) {
                var callBase = this.callBase;
                if (!('points' in params))
                    return this.callBase(params, options);
                this.fromSegments = this.segments;
                this.prepareSegments(params);
                if (globalAnimOptions.enabled)
                    $.extend(params, {d: 1});
                this.callBase = callBase;
                this.callBase(params, options)
            },
            sharpEdges: function() {
                var self = this,
                    segLength = self.segments.length,
                    i = 0,
                    curSeg,
                    nextSeg,
                    curX,
                    curY,
                    nextX,
                    nextY,
                    curXIdx,
                    curYIdx,
                    nextXIdx,
                    nextYIdx,
                    strokeWidth = Math.round(self.settings.strokeWidth || 0),
                    correction = strokeWidth % 2 / 2;
                for (i; i < segLength - 1; i++) {
                    curSeg = self.segments[i];
                    nextSeg = self.segments[i + 1];
                    if (nextSeg[0] === 'Z' && i)
                        nextSeg = self.segments[0];
                    switch (curSeg[0]) {
                        case'M':
                        case'L':
                            curXIdx = 1;
                            curYIdx = 2;
                            break;
                        case'C':
                            curXIdx = 5;
                            curYIdx = 6;
                            break;
                        case'A':
                            curXIdx = 6;
                            curYIdx = 7;
                            break;
                        case'Z':
                            continue
                    }
                    switch (nextSeg[0]) {
                        case'M':
                        case'L':
                            nextXIdx = 1;
                            nextYIdx = 2;
                            break;
                        case'C':
                            nextXIdx = 5;
                            nextYIdx = 6;
                            break;
                        case'A':
                            nextXIdx = 6;
                            nextYIdx = 7;
                            break;
                        case'Z':
                            continue
                    }
                    curX = Math.floor(curSeg[curXIdx]);
                    curY = Math.floor(curSeg[curYIdx]);
                    nextX = nextSeg[nextXIdx] = Math.floor(nextSeg[nextXIdx]);
                    nextY = nextSeg[nextYIdx] = Math.floor(nextSeg[nextYIdx]);
                    curSeg[curXIdx] = i == 0 ? curX : curSeg[curXIdx];
                    curSeg[curYIdx] = i == 0 ? curY : curSeg[curYIdx];
                    if (curX == nextX) {
                        curSeg[curXIdx] = curX + correction;
                        nextSeg[nextXIdx] = nextX + correction
                    }
                    if (curY == nextY) {
                        curSeg[curYIdx] = curY + correction;
                        nextSeg[nextYIdx] = nextY + correction
                    }
                }
            }
        });
    var SegmentRectSvgElement = PathSvgElement.inherit(RectSvgBaseElement).inherit({
            defaultSettings: function() {
                return $.extend(true, {}, this.callBase(), {segments: {
                            top: true,
                            bottom: true,
                            left: true,
                            right: true
                        }})
            },
            prepareSegments: function() {
                var self = this,
                    settings = self.settings,
                    left = settings.x,
                    right = left + settings.width,
                    top = settings.y,
                    bottom = top + settings.height,
                    segments = [],
                    segmentSequence,
                    visiblyOpt = 0,
                    prevSegmentVisibility = 0;
                var allSegment = {
                        top: [['M', left, top], ['L', right, top]],
                        right: [['M', right, top], ['L', right, bottom]],
                        bottom: [['M', right, bottom], ['L', left, bottom]],
                        left: [['M', left, bottom], ['L', left, top]]
                    };
                $.each(allSegment, function(seg, _) {
                    var visibility = !!self.settings.segments[seg];
                    visiblyOpt = visiblyOpt * 2 + ~~visibility
                });
                switch (visiblyOpt) {
                    case(13):
                    case(9):
                        segmentSequence = ['left', 'top', 'right', 'bottom'];
                        break;
                    case(11):
                        segmentSequence = ['bottom', 'left', 'top', 'right'];
                        break;
                    default:
                        segmentSequence = ['top', 'right', 'bottom', 'left']
                }
                $.each(segmentSequence, function(_, seg) {
                    var segmentVisibility = !!self.settings.segments[seg];
                    if (segmentVisibility)
                        $.each(allSegment[seg].slice(prevSegmentVisibility), function(_, segment) {
                            segments.push(segment)
                        });
                    prevSegmentVisibility = ~~segmentVisibility
                });
                visiblyOpt == 15 && segments.push(['Z']);
                this.segments = segments.length ? segments : [['M', 0, 0], ['Z']];
                this.combinePathParams(settings)
            },
            adjustSettings: function() {
                this.callBase();
                this.prepareSegments()
            },
            applySettings: function(settings) {
                var segments = this.settings && this.settings.segments || this.defaultSettings().segments;
                settings.segments = $.extend(true, {}, segments || {}, settings.segments);
                this.callBase(settings)
            }
        });
    var AreaSvgElement = PathSvgElement.inherit({
            defaultSettings: function() {
                return {
                        points: {
                            x: 0,
                            y: 0
                        },
                        fill: 'black',
                        stroke: 'none'
                    }
            },
            ctor: function(renderer, params) {
                this.closePath = true;
                this.callBase(renderer, params)
            }
        });
    var BezierSvgElement = PathSvgElement.inherit({
            defaultSettings: function() {
                return {
                        points: {
                            x: 0,
                            y: 0
                        },
                        fill: 'none',
                        stroke: 'black'
                    }
            },
            prepareSegments: function(params) {
                if (!('points' in params))
                    return;
                var points = params.points,
                    firstElem = points[0],
                    close = this.closePath || params.closePath,
                    segments = [],
                    seg = [],
                    i,
                    x,
                    y;
                var cnt = 0;
                if (utils.isObject(firstElem)) {
                    for (i = 0; i < points.length; i++) {
                        x = points[i].x;
                        y = points[i].y;
                        if (!i) {
                            segments = [['M', x, y]];
                            continue
                        }
                        if ((i - 1) % 3 == 0) {
                            if (seg.length > 0)
                                segments.push(seg);
                            seg = ['C', x, y];
                            continue
                        }
                        seg.push(x);
                        seg.push(y)
                    }
                    if (seg.length > 0)
                        segments.push(seg)
                }
                else if (utils.isNumber(firstElem)) {
                    for (i = 0; i < points.length; i += 2) {
                        x = points[i];
                        y = points[i + 1];
                        if (!i) {
                            segments = [['M', x, y || 0]];
                            continue
                        }
                        if ((i - 2) % 6 == 0) {
                            if (seg.length > 0)
                                segments.push(seg);
                            seg = ['C', x, y || 0];
                            continue
                        }
                        seg.push(x);
                        seg.push(y || 0)
                    }
                    if (seg.length > 0)
                        segments.push(seg)
                }
                else
                    segments = [['M', 0, 0]];
                if (close)
                    segments.push(['Z']);
                this.segments = segments;
                delete params.points;
                delete params.closePath;
                this.combinePathParams(params)
            }
        });
    var BezierAreaSvgElement = BezierSvgElement.inherit({
            defaultSettings: function() {
                return {
                        points: {
                            x: 0,
                            y: 0
                        },
                        fill: 'black',
                        stroke: 'none'
                    }
            },
            ctor: function(renderer, params) {
                this.closePath = true;
                this.callBase(renderer, params)
            }
        });
    var ArcSvgElement = PathSvgElement.inherit({
            defaultSettings: function() {
                return {
                        x: 0,
                        y: 0,
                        fill: 'none',
                        stroke: 'black',
                        linejoin: 'round'
                    }
            },
            createArcSegments: function(x, y, innerR, outerR, startAngle, endAngle) {
                var longFlag = Math.abs(endAngle - startAngle) > Math.PI ? '1' : '0',
                    xOuterStart = x + outerR * Math.cos(startAngle),
                    yOuterStart = y - outerR * Math.sin(startAngle),
                    xOuterEnd = x + outerR * Math.cos(endAngle),
                    yOuterEnd = y - outerR * Math.sin(endAngle),
                    xInnerStart = x + innerR * Math.cos(endAngle),
                    yInnerStart = y - innerR * Math.sin(endAngle),
                    xInnerEnd = x + innerR * Math.cos(startAngle),
                    yInnerEnd = y - innerR * Math.sin(startAngle);
                return [['M', xOuterStart, yOuterStart], ['A', outerR, outerR, 0, longFlag, 0, xOuterEnd, yOuterEnd], ['L', xInnerStart, yInnerStart], ['A', innerR, innerR, 0, longFlag, 1, xInnerEnd, yInnerEnd], ['Z']]
            },
            prepareSegments: function(params) {
                if (!('x' in params) && !('y' in params) && !('outerRadius' in params) && !('innerRadius' in params) && !('startAngle' in params) && !('endAngle' in params))
                    return;
                var x = utils.isNumber(params.x) ? Number(params.x) : 0,
                    y = utils.isNumber(params.y) ? Number(params.y) : 0,
                    outerR = utils.isNumber(params.outerRadius) ? Number(params.outerRadius) : 0,
                    innerR = utils.isNumber(params.innerRadius) ? Number(params.innerRadius) : 0,
                    startAngle = utils.isNumber(params.startAngle) ? Number(params.startAngle) : 0,
                    endAngle = utils.isNumber(params.endAngle) ? Number(params.endAngle) : 360;
                this.segments = [['M', 0, 0], ['Z']];
                if (outerR || innerR) {
                    var tmp = Math.min(outerR, innerR);
                    outerR = Math.max(outerR, innerR);
                    innerR = tmp;
                    if (Math.round(startAngle) != Math.round(endAngle)) {
                        if (Math.abs(endAngle - startAngle) % 360 == 0)
                            endAngle -= 0.0001;
                        if (startAngle > 360)
                            startAngle = startAngle % 360;
                        if (endAngle > 360)
                            endAngle = endAngle % 360;
                        if (startAngle > endAngle)
                            startAngle -= 360;
                        startAngle = startAngle * Math.PI / 180;
                        endAngle = endAngle * Math.PI / 180;
                        this.segments = this.createArcSegments(x, y, innerR, outerR, startAngle, endAngle)
                    }
                }
                delete params.x;
                delete params.y;
                delete params.outerRadius;
                delete params.innerRadius;
                delete params.startAngle;
                delete params.endAngle;
                this.combinePathParams(params)
            }
        });
    var CircleSvgElement = BaseSvgElement.inherit({
            defaultSettings: function() {
                return {
                        cx: 0,
                        cy: 0,
                        r: 0
                    }
            },
            ctor: function(renderer, params) {
                this.callBase(renderer, 'circle', params)
            }
        });
    var TextSvgElement = BaseSvgElement.inherit({
            defaultSettings: function() {
                return {
                        x: 0,
                        y: 0
                    }
            },
            ctor: function(renderer, params) {
                this.tspans = [];
                this.callBase(renderer, 'text', params)
            },
            updateText: function(text) {
                if (!utils.isDefined(text))
                    text = '';
                this.applySettings({text: text})
            },
            adjustSettings: function() {
                if (!('text' in this.settings)) {
                    this.changeX();
                    return
                }
                this._createElementWithText(this.settings.text)
            },
            changeX: function() {
                for (var i = 0; i < this.tspans.length; i++)
                    if (this.tspans[i].settings.x != undefined)
                        this.tspans[i].applySettings({x: this.settings.x})
            },
            _createElementWithText: function(text) {
                var div,
                    i;
                this.clear();
                text = text.toString().replace(/\r/g, "");
                text = text.replace(/\n/g, "<br/>");
                div = doc.createElement("div");
                div.innerHTML = text;
                div.params = {style: {}};
                this._orderText(div)
            },
            clear: function() {
                this.callBase();
                this.tspans = []
            },
            _orderText: function(node) {
                var textArray = [],
                    defaultFontSize = (this.settings.font ? this.settings.font.size : 12) || 12;
                var order = function(strCount, node, textArray) {
                        var params = {style: {}},
                            textArray = textArray || [];
                        node.params = node.params || {};
                        if (node.parentNode && node.nodeName != "#text")
                            if (node.parentNode.params)
                                for (var i in node.parentNode.params)
                                    node.params[i] = node.parentNode.params[i];
                        switch (node.tagName) {
                            case"B" || "STRONG":
                                node.params.fontWeight = "bold";
                                break;
                            case"I" || "EM":
                                node.params.fontStyle = "italic";
                                break;
                            case"U":
                                node.params.textDecoration = "underline";
                                break;
                            case"BR":
                                strCount++;
                                break
                        }
                        if (node.style) {
                            if (node.style.fontSize)
                                node.params.fontSize = node.style.fontSize.split('p')[0] || node.params.fontSize;
                            node.params.fill = node.style.color || node.params.fill;
                            node.params.fontStyle = node.style.fontStyle || node.params.fontStyle;
                            node.params.fontWeight = node.style.fontWeight || node.params.fontWeight;
                            node.params.textDecoration = node.style.textDecoration || node.params.textDecoration
                        }
                        var childnum = node.childNodes.length;
                        var count = 0;
                        while (count != childnum)
                            strCount = order(strCount, node.childNodes[count++], textArray);
                        if (node.wholeText != undefined) {
                            params.fill = node.parentNode.params.fill;
                            params.text = node.wholeText,
                            node.parentNode.params.fontSize && (params.style.fontSize = node.parentNode.params.fontSize);
                            node.parentNode.params.fontStyle && (params.style.fontStyle = node.parentNode.params.fontStyle);
                            node.parentNode.params.fontWeight && (params.style.fontWeight = node.parentNode.params.fontWeight);
                            node.parentNode.params.textDecoration && (params.style.textDecoration = node.parentNode.params.textDecoration);
                            textArray.push({
                                params: params,
                                line: strCount
                            })
                        }
                        return strCount
                    };
                order(0, node, textArray);
                for (var txt = 0; txt < textArray.length; txt++) {
                    if (txt != 0)
                        if (textArray[txt].line != textArray[txt - 1].line) {
                            textArray[txt].params.dy = textArray[txt].params.fontSize || defaultFontSize;
                            textArray[txt].params.x = this.settings.x
                        }
                        else {
                            textArray[txt].params.dy = 0;
                            textArray[txt].params.dx = 0
                        }
                    else {
                        textArray[txt].params.x = this.settings.x;
                        textArray[txt].params.dy = 0
                    }
                    var tspan = new TspanSvgElement(this.renderer, textArray[txt].params);
                    tspan.append(this);
                    this.tspans.push(tspan)
                }
            }
        });
    var TspanSvgElement = BaseSvgElement.inherit({ctor: function(renderer, params) {
                var text = params.text || '';
                delete params.text;
                this.callBase(renderer, 'tspan', params);
                this.element.appendChild(doc.createTextNode(text))
            }});
    var GroupSvgElement = BaseSvgElement.inherit({ctor: function(renderer, params) {
                this.callBase(renderer, 'g', params)
            }});
    var SvgRenderer = Class.inherit({
            ctor: function(options) {
                options = options || {};
                var width = options.width,
                    height = options.height;
                setGlobalAnimationOptions(options.animation || {});
                this.recreateCanvas(width, height)
            },
            killContainer: function() {
                var self = this,
                    element = self.container && self.getRoot() && self.getRoot().element;
                if (element) {
                    $(element).remove();
                    delete self.svgRoot
                }
                if (self.defsSvg)
                    delete self.defsSvg
            },
            recreateCanvas: function(width, height) {
                var self = this;
                self.killContainer();
                if (width > 0 && height > 0) {
                    var svgRoot = new RootSvgElement(self, {
                            width: width,
                            height: height
                        });
                    self.svgRoot = svgRoot
                }
            },
            resize: function(width, height) {
                var root = this.getRoot();
                root && width > 0 && height > 0 && root.applySettings({
                    width: width,
                    height: height
                })
            },
            getRoot: function() {
                return this.svgRoot
            },
            isInitialized: function() {
                return !!this.svgRoot
            },
            draw: function(container) {
                if (!container)
                    return;
                var renderer = this;
                renderer.container = container;
                container.appendChild(renderer.getRoot().element)
            },
            createRect: function(x, y, w, h, r, options) {
                var params = $.extend({}, options || {}, {
                        x: x,
                        y: y,
                        width: w,
                        height: h,
                        rx: r,
                        ry: r
                    });
                var svgRect = new RectSvgElement(this, params);
                return svgRect
            },
            createSegmentRect: function(x, y, w, h, r, segments, options) {
                var params = $.extend({}, options || {}, {
                        x: x,
                        y: y,
                        width: w,
                        height: h,
                        rx: r,
                        ry: r,
                        segments: segments
                    });
                var svgRect = new SegmentRectSvgElement(this, params);
                return svgRect
            },
            drawRect: function(x, y, w, h, r, options) {
                return this.createRect(x, y, w, h, r, options).append()
            },
            createClipRect: function(x, y, w, h) {
                var attr = {
                        fill: 'none',
                        stroke: 'none',
                        strokeWidth: 0
                    },
                    clipPathSvg,
                    rect,
                    id;
                if (!this.defsSvg) {
                    this.defsSvg = new BaseSvgElement(this, 'defs');
                    this.defsSvg.append()
                }
                id = utils.getNextClipId();
                clipPathSvg = new BaseSvgElement(this, 'clipPath', {id: id});
                clipPathSvg.append(this.defsSvg);
                rect = this.createRect(x, y, w, h, 0, attr);
                rect.id = id;
                rect.append(clipPathSvg);
                return rect
            },
            createPattern: function(color, hatching) {
                var patternSvg,
                    line,
                    id;
                if (hatching === 'none')
                    return color;
                if (!this.defsSvg) {
                    this.defsSvg = new BaseSvgElement(this, 'defs');
                    this.defsSvg.append()
                }
                id = utils.getNextPatternId();
                patternSvg = new BaseSvgElement(this, 'pattern', {
                    id: id,
                    width: 6,
                    height: 6
                });
                patternSvg.element.setAttribute('patternUnits', 'userSpaceOnUse');
                patternSvg.lines = [];
                patternSvg.append(this.defsSvg);
                if (hatching === 'right') {
                    line = this.createLine(0, 0, 1, 1, {
                        strokeWidth: 1,
                        stroke: color,
                        opacity: 0.8
                    });
                    line.append(patternSvg);
                    patternSvg.lines.push(line);
                    line = this.createLine(5, 5, 6, 6, {
                        strokeWidth: 1,
                        stroke: color,
                        opacity: 0.8
                    });
                    line.append(patternSvg);
                    patternSvg.lines.push(line);
                    line = this.createLine(0, 6, 6, 0, {
                        strokeWidth: 2,
                        stroke: color
                    });
                    line.append(patternSvg);
                    patternSvg.lines.push(line)
                }
                else if (hatching === 'left') {
                    line = this.createLine(5, 1, 6, 0, {
                        strokeWidth: 1,
                        stroke: color,
                        opacity: 0.8
                    });
                    line.append(patternSvg);
                    patternSvg.lines.push(line);
                    line = this.createLine(0, 6, 1, 5, {
                        strokeWidth: 1,
                        stroke: color,
                        opacity: 0.8
                    });
                    line.append(patternSvg);
                    patternSvg.lines.push(line);
                    line = this.createLine(0, 0, 6, 6, {
                        strokeWidth: 2,
                        stroke: color
                    });
                    line.append(patternSvg);
                    patternSvg.lines.push(line)
                }
                else
                    return color;
                patternSvg.id = 'url(#' + id + ')';
                return patternSvg
            },
            createImage: function(x, y, w, h, href, options) {
                var params = $.extend({}, options || {}, {
                        x: x,
                        y: y,
                        width: w,
                        height: h
                    });
                var svgImage = new ImageSvgElement(this, params, href, options.location);
                return svgImage
            },
            drawImage: function(x, y, w, h, href, options) {
                return this.createImage(x, y, w, h, href, options).append()
            },
            createLine: function(x1, y1, x2, y2, options) {
                var params = $.extend({}, options || {}, {points: [x1, y1, x2, y2]});
                var svgLine = new PathSvgElement(this, params);
                return svgLine
            },
            drawLine: function(x1, y1, x2, y2, options) {
                return this.createLine(x1, y1, x2, y2, options).append()
            },
            createPath: function(points, options) {
                var params = $.extend({}, options || {}, {points: points});
                var svgPath = new PathSvgElement(this, params);
                return svgPath
            },
            drawPath: function(points, options) {
                return this.createPath(points, options).append()
            },
            createBezierPath: function(points, options) {
                var params = $.extend({}, options || {}, {points: points});
                var svgPath = new BezierSvgElement(this, params);
                return svgPath
            },
            drawBezierPath: function(points, options) {
                return this.createBezierPath(points, options).append()
            },
            createArea: function(points, options) {
                var params = $.extend({}, options || {}, {points: points});
                var svgArea = new AreaSvgElement(this, params);
                return svgArea
            },
            drawArea: function(points, options) {
                return this.createArea(points, options).append()
            },
            createBezierArea: function(points, options) {
                var params = $.extend({}, options || {}, {points: points});
                var svgArea = new BezierAreaSvgElement(this, params);
                return svgArea
            },
            drawBezierArea: function(points, options) {
                return this.createBezierArea(points, options).append()
            },
            createCircle: function(x, y, r, options) {
                var params = $.extend({}, options || {}, {
                        cx: x,
                        cy: y,
                        r: r
                    });
                var svgCircle = new CircleSvgElement(this, params);
                return svgCircle
            },
            drawCircle: function(x, y, r, options) {
                return this.createCircle(x, y, r, options).append()
            },
            createArc: function(x, y, outerRadius, innerRadius, startAngle, endAngle, options) {
                var params = $.extend({}, options || {}, {
                        x: x,
                        y: y,
                        outerRadius: outerRadius,
                        innerRadius: innerRadius,
                        startAngle: startAngle,
                        endAngle: endAngle
                    });
                var svgArc = new ArcSvgElement(this, params);
                return svgArc
            },
            drawArc: function(x, y, outerRadius, innerRadius, startAngle, endAngle, options) {
                return this.createArc(x, y, outerRadius, innerRadius, startAngle, endAngle, options).append()
            },
            createText: function(text, x, y, options) {
                var params = $.extend({}, options || {}, {
                        x: x,
                        y: y,
                        text: text
                    });
                var svgText = new TextSvgElement(this, params);
                return svgText
            },
            drawText: function(text, x, y, options) {
                return this.createText(text, x, y, options).append()
            },
            createGroup: function(options) {
                var svgGroup = new GroupSvgElement(this, options);
                return svgGroup
            },
            drawGroup: function(options) {
                return this.createGroup(options).append()
            }
        });
    renderers.SvgRenderer = SvgRenderer;
    renderers._svgRendererInternals = {
        BaseSvgElement: BaseSvgElement,
        RootSvgElement: RootSvgElement,
        RectSvgElement: RectSvgElement,
        ImageSvgElement: ImageSvgElement,
        PathSvgElement: PathSvgElement,
        AreaSvgElement: AreaSvgElement,
        BezierSvgElement: BezierSvgElement,
        BezierAreaSvgElement: BezierAreaSvgElement,
        CircleSvgElement: CircleSvgElement,
        TextSvgElement: TextSvgElement,
        TspanSvgElement: TspanSvgElement,
        GroupSvgElement: GroupSvgElement,
        ArcSvgElement: ArcSvgElement,
        RectSvgBaseElement: RectSvgBaseElement,
        SegmentRectSvgElement: SegmentRectSvgElement
    }
})(jQuery, DevExpress);

// Module viz, file vmlRenderer.js

(function($, DX) {
    var renderers = DX.viz.renderers,
        utils = DX.utils,
        Class = DX.Class,
        doc = document,
        svgRendererInternals = renderers._svgRendererInternals;
    var defaultVmlSettings = {
            x: 0,
            y: 0,
            width: 1,
            height: 1,
            position: 'absolute'
        };
    var extendDefaultVmlOptions = function(customOptions, baseOptions) {
            return $.extend(true, baseOptions || {}, defaultVmlSettings, customOptions)
        };
    var parseRotateParameter = function(rotate, defaultX, defaultY) {
            var rotateObject;
            if (utils.isDefined(rotate))
                if (utils.isNumber(rotate))
                    rotateObject = {
                        angle: rotate,
                        x: defaultX || 0,
                        y: defaultY || 0
                    };
                else if ($.isArray(rotate))
                    rotateObject = {
                        angle: rotate[0] || 0,
                        x: rotate[1] || 0,
                        y: rotate[2] || 0
                    };
                else if (utils.isObject(rotate))
                    rotateObject = {
                        angle: rotate.angle || 0,
                        x: rotate.x || 0,
                        y: rotate.y || 0
                    };
            return rotateObject
        };
    var applySubElementAttribute = function(vmlElement, params, name) {
            var element = vmlElement.element,
                subElement,
                value = params[name];
            if (name === 'opacity' || name === 'fillOpacity')
                if (element.fill)
                    element.fill.opacity = value;
                else {
                    subElement = doc.createElement('vml:fill');
                    element.appendChild(subElement);
                    subElement.opacity = value;
                    subElement.className = 'vml';
                    if (params.fillcolor)
                        subElement.color = params.fillcolor
                }
            if (name === 'joinStyle')
                if (element.stroke)
                    element.stroke.joinStyle = value;
                else {
                    subElement = doc.createElement('vml:stroke');
                    vmlElement.element.appendChild(subElement);
                    subElement.className = 'vml';
                    subElement.joinStyle = value
                }
            if (name === 'opacity' || name === 'strokeOpacity')
                if (element.stroke)
                    element.stroke.opacity = value;
                else {
                    subElement = doc.createElement('vml:stroke');
                    vmlElement.element.appendChild(subElement);
                    subElement.className = 'vml';
                    subElement.opacity = value;
                    if (params.strokecolor)
                        subElement.color = params.strokecolor
                }
            if (name === 'dashstyle')
                if (element.stroke)
                    element.stroke.dashstyle = value;
                else {
                    subElement = doc.createElement('vml:stroke');
                    vmlElement.element.appendChild(subElement);
                    subElement.className = 'vml';
                    subElement.dashstyle = value
                }
        };
    var getBoundingClientRect = function(element) {
            var i,
                resultRect,
                rect,
                tagName = element.tagName.toLowerCase(),
                points,
                value,
                halfStrokeWidth;
            if (tagName === 'div') {
                if (element.childNodes.length > 0) {
                    resultRect = {};
                    for (i = 0; i < element.childNodes.length; i++) {
                        rect = getBoundingClientRect(element.childNodes[i]);
                        if (!rect)
                            continue;
                        resultRect.left = resultRect.left === undefined || rect.left < resultRect.left ? rect.left : resultRect.left;
                        resultRect.top = resultRect.top === undefined || rect.top < resultRect.top ? rect.top : resultRect.top;
                        resultRect.right = resultRect.right === undefined || rect.right > resultRect.right ? rect.right : resultRect.right;
                        resultRect.bottom = resultRect.bottom === undefined || rect.bottom > resultRect.bottom ? rect.bottom : resultRect.bottom
                    }
                }
            }
            else if (tagName === 'shape' || tagName === 'vml:shape') {
                points = (element.path.value || element.path).match(/[-0-9]+/g);
                resultRect = {};
                rect = element.getBoundingClientRect();
                for (i = 0; i < points.length; i++) {
                    value = parseInt(points[i]);
                    if (i % 2) {
                        resultRect.top = resultRect.top === undefined || value < resultRect.top ? value : resultRect.top;
                        resultRect.bottom = resultRect.bottom === undefined || value > resultRect.bottom ? value : resultRect.bottom
                    }
                    else {
                        resultRect.left = resultRect.left === undefined || value < resultRect.left ? value : resultRect.left;
                        resultRect.right = resultRect.right === undefined || value > resultRect.right ? value : resultRect.right
                    }
                }
                resultRect.left = resultRect.left || 0;
                resultRect.top = resultRect.top || 0;
                resultRect.right = resultRect.right || 0;
                resultRect.bottom = resultRect.bottom || 0;
                if (rect.right - rect.left <= 1 && rect.top - rect.bottom <= 1) {
                    resultRect.right = resultRect.right + rect.left;
                    resultRect.bottom = resultRect.bottom + rect.top;
                    resultRect.left = resultRect.left + rect.left;
                    resultRect.top = resultRect.top + rect.top
                }
                else {
                    resultRect.right = resultRect.right - resultRect.left + rect.left;
                    resultRect.bottom = resultRect.bottom - resultRect.top + rect.top;
                    resultRect.left = rect.left;
                    resultRect.top = rect.top
                }
                halfStrokeWidth = Math.ceil(parseFloat(element.strokeweight) / 2);
                if (halfStrokeWidth && halfStrokeWidth > 1) {
                    resultRect.left -= halfStrokeWidth;
                    resultRect.top -= halfStrokeWidth;
                    resultRect.right += halfStrokeWidth;
                    resultRect.bottom += halfStrokeWidth
                }
            }
            else
                resultRect = element.getBoundingClientRect();
            return resultRect
        };
    var BaseVmlElement = {
            isVml: function() {
                return true
            },
            defaultSettings: function(customOptions) {
                var baseOptions = this.callBase ? this.callBase() : {};
                return extendDefaultVmlOptions(customOptions, baseOptions)
            },
            createElement: function(nodeName) {
                this._nodeName = nodeName;
                this.childElements = [];
                if (this.isVml()) {
                    var result = doc.createElement('vml:' + nodeName);
                    result.className = 'vml';
                    return result
                }
                else
                    return doc.createElement(nodeName)
            },
            clear: function() {
                this.callBase();
                this.childElements = []
            },
            _applyAttributes: function(params) {
                var name,
                    value;
                if (params && params.arcsize !== undefined) {
                    try {
                        this.element.setAttribute('arcsize', params.arcsize)
                    }
                    catch(e) {}
                    this.__appliedSettings = {arcsize: params.arcsize};
                    delete params.arcsize
                }
                if (!this._isAppended)
                    this._delayedAttributes = params;
                else {
                    params = params || this._delayedAttributes;
                    if (params) {
                        for (name in params) {
                            value = params[name];
                            if (name === 'opacity' || name === 'fillOpacity' || name === 'strokeOpacity' || name === 'dashstyle' || name === 'joinStyle')
                                applySubElementAttribute(this, params, name);
                            else
                                this.element[name] = value
                        }
                        this.__appliedSettings = params;
                        delete this._delayedAttributes
                    }
                }
            },
            appendComplete: function() {
                var self = this;
                self._isAppended = true;
                self._applyAttributes();
                $.each(self.childElements, function() {
                    this.appendComplete()
                })
            },
            append: function(element) {
                var self = this,
                    root = self.renderer.getRoot(),
                    toElement = element || root;
                if (toElement) {
                    toElement.element.appendChild(self.element);
                    toElement.childElements.push(self)
                }
                if (toElement === root || toElement._isAppended)
                    this.appendComplete();
                return self
            },
            _normalizeSettings: function(settings) {
                var key,
                    style = {},
                    normalized = {},
                    clipRect,
                    fontSettingName,
                    pos,
                    prop,
                    value,
                    styleName,
                    firstChar,
                    cssProperties = ['position', 'display', 'visibility', 'filter', 'margin', 'marginTop', 'marginLeft', 'marginRight', 'marginBottom', 'whiteSpace', 'clip'];
                for (key in settings) {
                    prop = key;
                    value = settings[prop];
                    if (prop === 'x' || prop === 'translateX') {
                        pos = settings.x || 0;
                        if (settings.translateX)
                            pos += settings.translateX;
                        style.left = pos + 'px'
                    }
                    else if (prop === 'y' || prop === 'translateY') {
                        pos = settings.y || 0;
                        if (settings.translateY)
                            pos += settings.translateY;
                        style.top = pos + 'px'
                    }
                    else if (prop === 'width')
                        style.width = value + 'px';
                    else if (prop === 'height')
                        style.height = value + 'px';
                    else if (prop === 'align')
                        style.textAlign = value;
                    else if ($.inArray(prop, cssProperties) != -1)
                        style[prop] = value;
                    else if (prop === 'fill')
                        if (this.isVml()) {
                            normalized.filled = value === 'none' ? 'f' : 't';
                            normalized.fillcolor = value
                        }
                        else
                            style['color'] = value;
                    else if (prop === 'opacity')
                        normalized.opacity = value < 0.01 ? '99f' : value;
                    else if (prop === 'stroke') {
                        normalized.stroked = value === 'none' ? 'f' : 't';
                        normalized.strokecolor = value
                    }
                    else if (prop === 'strokeWidth')
                        normalized.strokeweight = value + 'px';
                    else if (prop == 'lineJoin')
                        normalized.joinStyle = value;
                    else if (prop === 'font') {
                        if (!$.isPlainObject(value))
                            continue;
                        $.each(value, function(fontSettingName) {
                            switch (fontSettingName) {
                                case'color':
                                case'cursor':
                                    styleName = fontSettingName;
                                    break;
                                case'opacity':
                                    styleName = 'opacity';
                                    break;
                                default:
                                    firstChar = fontSettingName.charAt(0);
                                    styleName = 'font' + fontSettingName.replace(firstChar, firstChar.toUpperCase())
                            }
                            style[styleName] = value[fontSettingName]
                        })
                    }
                    else if (prop === 'style')
                        $.extend(true, style, value);
                    else if (prop === 'rotate')
                        this['_rotate'] = value;
                    else if (prop === 'dashStyle') {
                        value = value.toLowerCase();
                        if (value !== 'solid')
                            normalized.dashstyle = value
                    }
                    else if (prop === 'clipId') {
                        clipRect = this.renderer.getClipRect(value, this);
                        if (clipRect)
                            style.clip = 'rect(' + [clipRect.y, clipRect.x + clipRect.width, clipRect.y + clipRect.height, clipRect.x].join('px, ') + 'px)'
                    }
                    else if (prop == 'segments')
                        continue;
                    else
                        normalized[prop] = value
                }
                this['_style'] = style;
                return normalized
            },
            _getBBox: function() {
                var width,
                    height,
                    rect,
                    rootRect,
                    x = 0,
                    y = 0,
                    element = this.element;
                try {
                    rect = getBoundingClientRect(element);
                    width = rect.right - rect.left;
                    height = rect.bottom - rect.top;
                    rootRect = this.renderer.getRoot().element.getBoundingClientRect();
                    x = rect.left - rootRect.left;
                    y = rect.top - rootRect.top
                }
                catch(e) {
                    width = element.offsetWidth || 0;
                    height = element.offsetHeight || 0
                }
                return {
                        x: x,
                        y: y,
                        width: width,
                        height: height
                    }
            },
            getBBox: function() {
                return this._getBBox()
            },
            sharpEdges: function(){}
        };
    var convertSvgPathCommandToVml = function(command) {
            switch (command) {
                case'M':
                    return 'm';
                case'L':
                    return 'l';
                case'Z':
                    return 'x e'
            }
            return command
        };
    var BasePathVmlElement = {
            defaultSettings: function() {
                var settings = this.callBase();
                settings.coordsize = '1,1';
                return settings
            },
            getNodeName: function() {
                return 'shape'
            },
            getPathAttributeName: function() {
                return 'path'
            },
            customizeSegments: function(segments) {
                var result = segments;
                if (segments)
                    result = $.map(segments, function(s, i) {
                        var pos,
                            segmentArray = [],
                            command = convertSvgPathCommandToVml(s[0]);
                        segmentArray.push(command);
                        for (pos = 1; pos < s.length; pos++)
                            segmentArray.push(Math.floor(s[pos]));
                        return [segmentArray]
                    });
                return result
            }
        };
    var RootVmlElement = svgRendererInternals.BaseSvgElement.inherit(BaseVmlElement).inherit({
            isVml: function() {
                return false
            },
            defaultSettings: function() {
                return {
                        width: 0,
                        height: 0,
                        position: 'relative',
                        display: 'inline-block'
                    }
            },
            ctor: function(renderer, params) {
                this.callBase(renderer, 'div', params)
            }
        });
    var ImageVmlElement = svgRendererInternals.BaseSvgElement.inherit(svgRendererInternals.RectSvgBaseElement).inherit(BaseVmlElement).inherit({
            ctor: function(renderer, params) {
                this.callBase(renderer, 'image', params)
            },
            adjustSettings: function() {
                this.callBase();
                if (this.settings.href) {
                    this.settings.src = this.settings.href;
                    delete this.settings.href
                }
            }
        });
    var RectVmlElement = svgRendererInternals.BaseSvgElement.inherit(svgRendererInternals.RectSvgBaseElement).inherit(BaseVmlElement).inherit({
            defaultSettings: function() {
                return extendDefaultVmlOptions({
                        stroked: 'f',
                        rx: 0,
                        ry: 0
                    })
            },
            recreateElement: function(name) {
                this._nodeName = name;
                var parent = $(this.$element.parent());
                if (parent) {
                    this.$element.remove();
                    this.element = this.createElement(name);
                    this.$element = $(this.element);
                    parent.append(this.$element)
                }
                else {
                    this.element = this.createElement(name);
                    this.$element = $(this.element)
                }
                this.applySettings()
            },
            _adjustArcSize: function() {
                var settings = this.settings;
                var rx = settings.rx || 0,
                    ry = settings.ry || 0,
                    width = settings.width,
                    height = settings.height,
                    r,
                    halfsize,
                    arcsize;
                if (settings.rx !== undefined || settings.ry !== undefined) {
                    r = Math.max(rx, ry);
                    halfsize = Math.max(width, height) / 2;
                    arcsize = r / halfsize;
                    settings.arcsize = arcsize;
                    if ($.isNumeric(arcsize) && arcsize != 0)
                        this._nodeName !== 'roundrect' && this.recreateElement('roundrect');
                    else
                        this._nodeName === 'roundrect' && this.recreateElement('rect');
                    delete settings.rx;
                    delete settings.ry
                }
            },
            _adjustRotation: function() {
                var settings = this.settings;
                var rotate = this.settings.rotate,
                    rotateAngle,
                    radianAngle,
                    cos,
                    sin,
                    rotateX,
                    rotateY,
                    marginTop,
                    marginLeft,
                    cx,
                    cy,
                    rotateObject;
                rotateObject = parseRotateParameter(rotate, settings.x, settings.y);
                if (rotateObject) {
                    rotateAngle = rotateObject.angle;
                    rotateX = rotateObject.x;
                    rotateY = rotateObject.y;
                    radianAngle = rotateAngle * Math.PI / 180.0;
                    cos = Math.cos(radianAngle);
                    sin = Math.sin(radianAngle);
                    cx = settings.x + (settings.translateX || 0) + settings.width / 2;
                    cy = settings.y + (settings.translateY || 0) + settings.height / 2;
                    marginLeft = (cx - rotateX) * cos - (cy - rotateY) * sin + rotateX - cx;
                    marginTop = (cx - rotateX) * sin + (cy - rotateY) * cos + rotateY - cy;
                    this.settings.marginLeft = Math.round(marginLeft) + 'px';
                    this.settings.marginTop = Math.round(marginTop) + 'px';
                    this.settings.rotation = rotateAngle
                }
            },
            adjustSettings: function() {
                this.callBase();
                this._adjustArcSize();
                this._adjustRotation()
            },
            getBBox: function() {
                return this.callBase()
            },
            ctor: function(renderer, params) {
                this.callBase(renderer, 'rect', params)
            }
        });
    var PathVmlElement = svgRendererInternals.PathSvgElement.inherit(BaseVmlElement).inherit(BasePathVmlElement).inherit({prepareSegments: function(settings) {
                var self = this,
                    rotate = settings.rotate,
                    rotateAngle,
                    rotateX,
                    rotateY,
                    oldSegments,
                    radianAngle,
                    cos,
                    sin,
                    x,
                    y,
                    rotatedX,
                    rotatedY,
                    rotateObject;
                this.callBase(settings);
                oldSegments = self.segments;
                rotateObject = parseRotateParameter(rotate, settings.x, settings.y);
                if (rotateObject) {
                    rotateAngle = rotateObject.angle;
                    rotateX = rotateObject.x;
                    rotateY = rotateObject.y;
                    if (self.segments) {
                        radianAngle = rotateAngle * Math.PI / 180.0;
                        cos = Math.cos(radianAngle);
                        sin = Math.sin(radianAngle);
                        self.segments = $.map(self.segments, function(s, i) {
                            if (s.length == 3) {
                                x = s[1],
                                y = s[2];
                                rotatedX = (x - rotateX) * cos - (y - rotateY) * sin + rotateX;
                                rotatedY = (x - rotateX) * sin + (y - rotateY) * cos + rotateY;
                                return [[s[0], Math.floor(rotatedX), Math.floor(rotatedY)]]
                            }
                            else
                                return [s]
                        });
                        self.combinePathParams(settings);
                        self.segments = oldSegments
                    }
                }
            }});
    var AreaVmlElement = PathVmlElement.inherit({
            defaultSettings: function() {
                var baseOptions = this.callBase();
                return extendDefaultVmlOptions({
                        points: {
                            x: 0,
                            y: 0
                        },
                        fill: 'black',
                        stroke: 'none'
                    }, baseOptions)
            },
            ctor: function(renderer, params) {
                this.closePath = true;
                this.callBase(renderer, params)
            }
        });
    var SegmentRectVmlElement = svgRendererInternals.SegmentRectSvgElement.inherit(BaseVmlElement).inherit(BasePathVmlElement).inherit({
            defaultSettings: function() {
                var settings = this.callBase();
                settings.lineJoin = 'miter';
                return settings
            },
            prepareSegments: function() {
                this.callBase();
                this.segments = this.customizeSegments(this.segments);
                this.settings.x = 0;
                this.settings.y = 0;
                this.settings.width = 1;
                this.settings.height = 1
            },
            applySettings: function(settings) {
                var x = settings.x,
                    y = settings.y,
                    w = settings.width,
                    h = settings.height;
                this.callBase(settings);
                this.settings.x = x;
                this.settings.y = y;
                this.settings.width = w;
                this.settings.height = h
            }
        });
    var BezierVmlElement = svgRendererInternals.BezierSvgElement.inherit(BaseVmlElement).inherit(BasePathVmlElement);
    var BezierAreaVmlElement = BezierVmlElement.inherit({
            defaultSettings: function() {
                var baseOptions = this.callBase();
                return extendDefaultVmlOptions({
                        points: {
                            x: 0,
                            y: 0
                        },
                        fill: 'black',
                        stroke: 'none'
                    }, baseOptions)
            },
            ctor: function(renderer, params) {
                this.closePath = true;
                this.callBase(renderer, params)
            }
        });
    var ArcVmlElement = svgRendererInternals.ArcSvgElement.inherit(BaseVmlElement).inherit(BasePathVmlElement).inherit({createArcSegments: function(x, y, innerR, outerR, startAngle, endAngle) {
                var xOuterStart = x + outerR * Math.cos(startAngle),
                    yOuterStart = y - outerR * Math.sin(startAngle),
                    xOuterEnd = x + outerR * Math.cos(endAngle),
                    yOuterEnd = y - outerR * Math.sin(endAngle),
                    xInnerStart = x + innerR * Math.cos(endAngle),
                    yInnerStart = y - innerR * Math.sin(endAngle),
                    xInnerEnd = x + innerR * Math.cos(startAngle),
                    yInnerEnd = y - innerR * Math.sin(startAngle);
                return [['wr', x - innerR, y - innerR, x + innerR, y + innerR, xInnerStart, yInnerStart, xInnerEnd, yInnerEnd], ['at', x - outerR, y - outerR, x + outerR, y + outerR, xOuterStart, yOuterStart, xOuterEnd, yOuterEnd], ['x e']]
            }});
    var CircleVmlElement = svgRendererInternals.BaseSvgElement.inherit(BaseVmlElement).inherit({
            defaultSettings: function() {
                return extendDefaultVmlOptions({
                        cx: 0,
                        cy: 0,
                        r: 0
                    })
            },
            applySettings: function(settings) {
                settings.cx = settings.cx || settings.x;
                settings.cy = settings.cy || settings.y;
                return this.callBase(settings)
            },
            adjustSettings: function() {
                var r,
                    cx,
                    cy;
                if (this.settings.cx !== undefined || this.settings.cy !== undefined || this.settings.r !== undefined) {
                    r = 'r' in this.settings ? this.settings.r : this.settings.width / 2;
                    cx = 'cx' in this.settings ? this.settings.cx : this.settings.x + this.settings.width / 2;
                    cy = 'cy' in this.settings ? this.settings.cy : this.settings.y + this.settings.width / 2;
                    this.settings.x = cx - r;
                    this.settings.y = cy - r;
                    this.settings.width = this.settings.height = r * 2;
                    delete this.settings.cx;
                    delete this.settings.cy;
                    delete this.settings.r
                }
            },
            ctor: function(renderer, params) {
                this.callBase(renderer, 'oval', params)
            }
        });
    var TextVmlElement = svgRendererInternals.BaseSvgElement.inherit(BaseVmlElement).inherit({
            isVml: function() {
                return false
            },
            defaultSettings: function() {
                return {
                        x: 0,
                        y: 0,
                        position: 'absolute',
                        whiteSpace: 'nowrap'
                    }
            },
            ctor: function(renderer, params) {
                this.callBase(renderer, 'span', params)
            },
            adjustSettings: function() {
                var text;
                if ('text' in this.settings) {
                    text = utils.isDefined(this.settings.text) ? this.settings.text : '';
                    text = text.toString().replace(/\r/g, "");
                    text = text.replace(/\n/g, "<br/>");
                    $(this.element).html(text);
                    delete this.settings.text
                }
            },
            updateText: function(text) {
                text = utils.isDefined(text) ? text : '';
                this.applySettings({text: text})
            },
            _applyAttributes: function(settings) {
                this.callBase(settings);
                var settings = this.settings,
                    rotate = this.settings.rotate,
                    rotateAngle = 0,
                    rotateX,
                    rotateY,
                    cos = 1,
                    sin = 0,
                    rad,
                    y = this.settings.y + (this.settings.translateY || 0),
                    x = this.settings.x + (this.settings.translateX || 0),
                    align = this.settings.align,
                    bBox = this.getBBox(),
                    elementStyle = this.element.style,
                    style = this._style || {},
                    marginLeft = 0,
                    marginTop = 0,
                    fontHeightOffset,
                    alignMultiplier,
                    rotateObject;
                var textWidth = bBox.width,
                    textHeight = bBox.height;
                rotateObject = parseRotateParameter(rotate, x, y);
                if (rotateObject) {
                    rotateAngle = rotateObject.angle;
                    rotateX = rotateObject.x;
                    rotateY = rotateObject.y;
                    if (Math.abs(rotateAngle) > 360)
                        rotateAngle = rotateAngle % 360;
                    if (rotateAngle < 0)
                        rotateAngle = rotateAngle + 360;
                    if (rotateAngle) {
                        rad = rotateAngle * Math.PI / 180.0;
                        cos = Math.cos(rad);
                        sin = Math.sin(rad);
                        style.filter = 'progid:DXImageTransform.Microsoft.Matrix(sizingMethod="auto expand", M11 = ' + cos.toFixed(5) + ', M12 = ' + (-sin).toFixed(5) + ', M21 = ' + sin.toFixed(5) + ', M22 = ' + cos.toFixed(5) + ')'
                    }
                    else
                        style.filter = '';
                    marginLeft = (x - rotateX) * (cos - 1) - (y - rotateY) * sin;
                    marginTop = (x - rotateX) * sin + (y - rotateY) * (cos - 1)
                }
                if (textHeight || textWidth) {
                    fontHeightOffset = textHeight * (0.55 + 0.45 / 2);
                    if (rotateAngle < 90) {
                        marginTop -= fontHeightOffset * cos;
                        marginLeft -= (textHeight - fontHeightOffset) * sin
                    }
                    else if (rotateAngle < 180) {
                        marginTop += (textHeight - fontHeightOffset) * cos;
                        marginLeft += textWidth * cos - (textHeight - fontHeightOffset) * sin
                    }
                    else if (rotateAngle < 270) {
                        marginTop += (textHeight - fontHeightOffset) * cos + textWidth * sin;
                        marginLeft += textWidth * cos + fontHeightOffset * sin
                    }
                    else {
                        marginTop += textWidth * sin - fontHeightOffset * cos;
                        marginLeft += fontHeightOffset * sin
                    }
                    alignMultiplier = {
                        center: 0.5,
                        right: 1
                    }[align];
                    if (alignMultiplier) {
                        marginLeft -= textWidth * alignMultiplier * cos;
                        marginTop -= textWidth * alignMultiplier * sin
                    }
                    style.marginLeft = Math.round(marginLeft) + 'px';
                    style.marginTop = Math.round(marginTop) + 'px'
                }
                this.applyStyle(style)
            }
        });
    var GroupVmlElement = svgRendererInternals.BaseSvgElement.inherit(BaseVmlElement).inherit({
            isVml: function() {
                return false
            },
            defaultSettings: extendDefaultVmlOptions,
            ctor: function(renderer, params) {
                this.callBase(renderer, 'div', params)
            },
            applySettings: function(settings) {
                var self = this,
                    callBase = this.callBase,
                    rotate;
                settings = settings || {};
                rotate = settings.rotate;
                if (rotate) {
                    if (utils.isNumber(rotate))
                        rotate = [rotate, settings.x || 0, settings.y || 0];
                    $.each(self.childElements, function() {
                        this.applySettings({rotate: rotate})
                    })
                }
                delete settings.rotate;
                settings.x = 0;
                settings.y = 0;
                self.callBase = callBase;
                return self.callBase(settings)
            },
            getBBox: function() {
                return this._getBBox()
            }
        });
    var VmlRenderer = renderers.SvgRenderer.inherit({
            ctor: function(options) {
                options = options || {};
                options.animation = {enabled: false};
                if (document.namespaces && !document.namespaces.vml) {
                    document.namespaces.add('vml', 'urn:schemas-microsoft-com:vml');
                    document.createStyleSheet().addRule('.vml', 'behavior: url(#default#VML); display: inline-block;')
                }
                this._clipRects = {};
                this.callBase(options)
            },
            recreateCanvas: function(width, height) {
                var self = this,
                    root;
                self.killContainer();
                if (width > 0 && height > 0) {
                    root = new RootVmlElement(self, {
                        width: width,
                        height: height
                    });
                    self.svgRoot = root
                }
            },
            createRect: function(x, y, w, h, r, options) {
                var params = $.extend(true, {}, options || {}, {
                        x: x,
                        y: y,
                        width: w,
                        height: h,
                        rx: r,
                        ry: r
                    });
                var svgRect = new RectVmlElement(this, params);
                return svgRect
            },
            createSegmentRect: function(x, y, w, h, r, segments, options) {
                var params = $.extend({}, options || {}, {
                        x: x,
                        y: y,
                        width: w,
                        height: h,
                        rx: r,
                        ry: r,
                        segments: segments
                    });
                var rect = new SegmentRectVmlElement(this, params);
                return rect
            },
            createClipRect: function(x, y, width, height) {
                var clipId = utils.getNextClipId(),
                    elements = [],
                    clipRect = {
                        id: clipId,
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        addElement: function(element) {
                            var hasElement = false;
                            $.each(elements, function() {
                                if (this === element) {
                                    hasElement = true;
                                    return false
                                }
                            });
                            if (!hasElement)
                                elements.push(element)
                        },
                        applySettings: function(settings) {
                            if ('x' in settings)
                                this.x = settings.x;
                            if ('y' in settings)
                                this.y = settings.y;
                            if ('width' in settings)
                                this.width = settings.width;
                            if ('height' in settings)
                                this.height = settings.height;
                            $.each(elements, function() {
                                this.applySettings({clipId: clipId})
                            });
                            return this
                        }
                    };
                this._clipRects[clipId] = clipRect;
                return clipRect
            },
            getClipRect: function(clipId, element) {
                var clipRect = this._clipRects[clipId],
                    hasElement = false;
                if (clipRect && element)
                    clipRect.addElement(element);
                return this._clipRects[clipId]
            },
            createImage: function(x, y, w, h, href, options) {
                var params = $.extend(true, {}, options || {}, {
                        x: x,
                        y: y,
                        width: w,
                        height: h,
                        href: href
                    });
                var svgImage = new ImageVmlElement(this, params);
                return svgImage
            },
            createLine: function(x1, y1, x2, y2, options) {
                var params = $.extend(true, {}, options || {}, {points: [x1, y1, x2, y2]});
                var svgLine = new PathVmlElement(this, params);
                return svgLine
            },
            createPath: function(points, options) {
                var params = $.extend(true, {}, options || {}, {points: points});
                var svgPath = new PathVmlElement(this, params);
                return svgPath
            },
            createBezierPath: function(points, options) {
                var params = $.extend(true, {}, options || {}, {points: points});
                var svgPath = new BezierVmlElement(this, params);
                return svgPath
            },
            createArea: function(points, options) {
                var params = $.extend(true, {}, options || {}, {points: points});
                var svgArea = new AreaVmlElement(this, params);
                return svgArea
            },
            createBezierArea: function(points, options) {
                var params = $.extend(true, {}, options || {}, {points: points});
                var svgArea = new BezierAreaVmlElement(this, params);
                return svgArea
            },
            createCircle: function(x, y, r, options) {
                var params = $.extend(true, {}, options || {}, {
                        cx: x,
                        cy: y,
                        r: r
                    });
                var svgCircle = new CircleVmlElement(this, params);
                return svgCircle
            },
            createArc: function(x, y, outerRadius, innerRadius, startAngle, endAngle, options) {
                var params = $.extend(true, {}, options || {}, {
                        x: x,
                        y: y,
                        outerRadius: outerRadius,
                        innerRadius: innerRadius,
                        startAngle: startAngle,
                        endAngle: endAngle
                    });
                var svgArc = new ArcVmlElement(this, params);
                return svgArc
            },
            createText: function(text, x, y, options) {
                var params = $.extend(true, {}, options || {}, {
                        x: x,
                        y: y,
                        text: text
                    });
                var svgText = new TextVmlElement(this, params);
                return svgText
            },
            createGroup: function(options) {
                var svgGroup = new GroupVmlElement(this, options);
                return svgGroup
            },
            createPattern: function(color) {
                return {id: color}
            }
        });
    renderers.VmlRenderer = VmlRenderer;
    renderers.__vmlRendererInternals = {
        RootVmlElement: RootVmlElement,
        RectVmlElement: RectVmlElement,
        ImageVmlElement: ImageVmlElement,
        PathVmlElement: PathVmlElement,
        AreaVmlElement: AreaVmlElement,
        BezierVmlElement: BezierVmlElement,
        BezierAreaVmlElement: BezierAreaVmlElement,
        CircleVmlElement: CircleVmlElement,
        TextVmlElement: TextVmlElement,
        GroupVmlElement: GroupVmlElement,
        ArcVmlElement: ArcVmlElement,
        SegmentRectVmlElement: SegmentRectVmlElement
    }
})(jQuery, DevExpress);

// Module viz, file renderer.js

(function($, DX) {
    function supportSVG() {
        return !!document.createElementNS && !!document.createElementNS('http://www.w3.org/2000/svg', "svg").createSVGRect
    }
    function supportVML() {
        var div = document.createElement('div');
        div.innerHTML = '<v:shape adj="1" />';
        var vmlE = div.firstChild;
        if (vmlE) {
            vmlE.style.behavior = "url(#default#VML)";
            return typeof vmlE.adj == "object"
        }
        else
            return false;
        return false
    }
    var renderers = DX.viz.renderers;
    if (supportVML() && !supportSVG())
        renderers.Renderer = renderers.VmlRenderer;
    else
        renderers.Renderer = renderers.SvgRenderer
})(jQuery, DevExpress);

// Module viz, file namespaces.js

(function(DevExpress) {
    DevExpress.viz.charts = {series: {}}
})(DevExpress);

// Module viz, file color.js

(function($, DX, undefined) {
    var Class = DX.Class,
        charts = DX.viz.charts;
    charts.Color = Class.inherit(function() {
        var ctor = function(baseColor) {
                this.baseColor = baseColor;
                this.decode()
            };
        var standardColorNames = {
                aliceblue: 'f0f8ff',
                antiquewhite: 'faebd7',
                aqua: '00ffff',
                aquamarine: '7fffd4',
                azure: 'f0ffff',
                beige: 'f5f5dc',
                bisque: 'ffe4c4',
                black: '000000',
                blanchedalmond: 'ffebcd',
                blue: '0000ff',
                blueviolet: '8a2be2',
                brown: 'a52a2a',
                burlywood: 'deb887',
                cadetblue: '5f9ea0',
                chartreuse: '7fff00',
                chocolate: 'd2691e',
                coral: 'ff7f50',
                cornflowerblue: '6495ed',
                cornsilk: 'fff8dc',
                crimson: 'dc143c',
                cyan: '00ffff',
                darkblue: '00008b',
                darkcyan: '008b8b',
                darkgoldenrod: 'b8860b',
                darkgray: 'a9a9a9',
                darkgreen: '006400',
                darkkhaki: 'bdb76b',
                darkmagenta: '8b008b',
                darkolivegreen: '556b2f',
                darkorange: 'ff8c00',
                darkorchid: '9932cc',
                darkred: '8b0000',
                darksalmon: 'e9967a',
                darkseagreen: '8fbc8f',
                darkslateblue: '483d8b',
                darkslategray: '2f4f4f',
                darkturquoise: '00ced1',
                darkviolet: '9400d3',
                deeppink: 'ff1493',
                deepskyblue: '00bfff',
                dimgray: '696969',
                dodgerblue: '1e90ff',
                feldspar: 'd19275',
                firebrick: 'b22222',
                floralwhite: 'fffaf0',
                forestgreen: '228b22',
                fuchsia: 'ff00ff',
                gainsboro: 'dcdcdc',
                ghostwhite: 'f8f8ff',
                gold: 'ffd700',
                goldenrod: 'daa520',
                gray: '808080',
                green: '008000',
                greenyellow: 'adff2f',
                honeydew: 'f0fff0',
                hotpink: 'ff69b4',
                indianred: 'cd5c5c',
                indigo: '4b0082',
                ivory: 'fffff0',
                khaki: 'f0e68c',
                lavender: 'e6e6fa',
                lavenderblush: 'fff0f5',
                lawngreen: '7cfc00',
                lemonchiffon: 'fffacd',
                lightblue: 'add8e6',
                lightcoral: 'f08080',
                lightcyan: 'e0ffff',
                lightgoldenrodyellow: 'fafad2',
                lightgrey: 'd3d3d3',
                lightgreen: '90ee90',
                lightpink: 'ffb6c1',
                lightsalmon: 'ffa07a',
                lightseagreen: '20b2aa',
                lightskyblue: '87cefa',
                lightslateblue: '8470ff',
                lightslategray: '778899',
                lightsteelblue: 'b0c4de',
                lightyellow: 'ffffe0',
                lime: '00ff00',
                limegreen: '32cd32',
                linen: 'faf0e6',
                magenta: 'ff00ff',
                maroon: '800000',
                mediumaquamarine: '66cdaa',
                mediumblue: '0000cd',
                mediumorchid: 'ba55d3',
                mediumpurple: '9370d8',
                mediumseagreen: '3cb371',
                mediumslateblue: '7b68ee',
                mediumspringgreen: '00fa9a',
                mediumturquoise: '48d1cc',
                mediumvioletred: 'c71585',
                midnightblue: '191970',
                mintcream: 'f5fffa',
                mistyrose: 'ffe4e1',
                moccasin: 'ffe4b5',
                navajowhite: 'ffdead',
                navy: '000080',
                oldlace: 'fdf5e6',
                olive: '808000',
                olivedrab: '6b8e23',
                orange: 'ffa500',
                orangered: 'ff4500',
                orchid: 'da70d6',
                palegoldenrod: 'eee8aa',
                palegreen: '98fb98',
                paleturquoise: 'afeeee',
                palevioletred: 'd87093',
                papayawhip: 'ffefd5',
                peachpuff: 'ffdab9',
                peru: 'cd853f',
                pink: 'ffc0cb',
                plum: 'dda0dd',
                powderblue: 'b0e0e6',
                purple: '800080',
                red: 'ff0000',
                rosybrown: 'bc8f8f',
                royalblue: '4169e1',
                saddlebrown: '8b4513',
                salmon: 'fa8072',
                sandybrown: 'f4a460',
                seagreen: '2e8b57',
                seashell: 'fff5ee',
                sienna: 'a0522d',
                silver: 'c0c0c0',
                skyblue: '87ceeb',
                slateblue: '6a5acd',
                slategray: '708090',
                snow: 'fffafa',
                springgreen: '00ff7f',
                steelblue: '4682b4',
                tan: 'd2b48c',
                teal: '008080',
                thistle: 'd8bfd8',
                tomato: 'ff6347',
                turquoise: '40e0d0',
                violet: 'ee82ee',
                violetred: 'd02090',
                wheat: 'f5deb3',
                white: 'ffffff',
                whitesmoke: 'f5f5f5',
                yellow: 'ffff00',
                yellowgreen: '9acd32'
            };
        var standardColorTypes = [{
                    re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                    process: function(colorString) {
                        return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10)]
                    }
                }, {
                    re: /^(\w{2})(\w{2})(\w{2})$/,
                    process: function(colorString) {
                        return [parseInt(colorString[1], 16), parseInt(colorString[2], 16), parseInt(colorString[3], 16)]
                    }
                }, {
                    re: /^(\w{1})(\w{1})(\w{1})$/,
                    process: function(colorString) {
                        return [parseInt(colorString[1] + colorString[1], 16), parseInt(colorString[2] + colorString[2], 16), parseInt(colorString[3] + colorString[3], 16)]
                    }
                }];
        var decode = function() {
                var baseColor = this.baseColor;
                if (baseColor.charAt(0) === '#')
                    baseColor = baseColor.substr(1, 6);
                baseColor = baseColor.toLowerCase();
                baseColor = baseColor.replace(/ /g, '');
                for (var standardColor in standardColorNames)
                    if (standardColorNames.hasOwnProperty(standardColor))
                        if (baseColor === standardColor)
                            baseColor = standardColorNames[standardColor];
                for (var i = 0; i < standardColorTypes.length; i++) {
                    var re = standardColorTypes[i].re;
                    var colorString = re.exec(baseColor);
                    if (colorString) {
                        var colorRgb = standardColorTypes[i].process(colorString);
                        this.r = colorRgb[0];
                        this.g = colorRgb[1];
                        this.b = colorRgb[2];
                        this.ok = true;
                        break
                    }
                }
                this.r = normalize(this.r);
                this.g = normalize(this.g);
                this.b = normalize(this.b)
            };
        var normalize = function(colorComponent) {
                return colorComponent < 0 || isNaN(colorComponent) ? 0 : colorComponent > 255 ? 255 : colorComponent
            };
        var digitToHex = function(n) {
                var st = n.toString(16);
                if (st.length === 1)
                    return '0' + st;
                return st
            };
        var toHexFromRgb = function(r, g, b) {
                return '#' + digitToHex(r) + digitToHex(g) + digitToHex(b)
            };
        var toHex = function() {
                return toHexFromRgb(this.r, this.g, this.b)
            };
        var highlight = function(step) {
                step = step || 10;
                return toHexFromRgb(normalize(this.r + step), normalize(this.g + step), normalize(this.b + step))
            };
        var darken = function(step) {
                step = step || 10;
                return toHexFromRgb(normalize(this.r - step), normalize(this.g - step), normalize(this.b - step))
            };
        return {
                ctor: ctor,
                highlight: highlight,
                darken: darken,
                decode: decode,
                toHex: toHex
            }
    }())
})(jQuery, DevExpress);

// Module viz, file range.js

(function($, DX, undefined) {
    var charts = DX.viz.charts,
        Class = DX.Class,
        utils = DX.utils;
    var NUMBER_EQUALITY_CORRECTION = 1,
        DATETIME_EQUALITY_CORRECTION = 60000;
    charts.Range = Class.inherit(function() {
        var ctor = function(range) {
                if (range)
                    $.extend(this, range)
            };
        var otherLessThan = function(thisValue, otherValue) {
                return otherValue < thisValue
            };
        var otherGreaterThan = function(thisValue, otherValue) {
                return otherValue > thisValue
            };
        var compareAndReplace = function(thisValue, otherValue, setValue, compare) {
                var thisValueDefined = thisValue !== undefined;
                var otherValueDefined = otherValue !== undefined;
                if (thisValueDefined) {
                    if (otherValueDefined && compare(thisValue, otherValue))
                        setValue(otherValue)
                }
                else if (otherValueDefined)
                    setValue(otherValue)
            };
        var getBoundRange = function(otherRange) {
                var self = this;
                getBoundRangeX.call(self, otherRange);
                getBoundRangeY.call(self, otherRange);
                return self
            };
        var getBoundRangeY = function(otherRange) {
                var self = this,
                    categoriesY = self.categoriesY,
                    otherCategoriesY = otherRange.categoriesY,
                    i;
                var setIndentByPriority = function(prefix) {
                        var priorityRelation = (self[prefix + 'Priority'] || 0) - (otherRange[prefix + 'Priority'] || 0);
                        if ((self[prefix] || 0) < otherRange[prefix] && priorityRelation === 0 || priorityRelation < 0) {
                            self[prefix] = otherRange[prefix];
                            self[prefix + 'Priority'] = otherRange[prefix + 'Priority']
                        }
                    };
                self.invertY = self.invertY || otherRange.invertY;
                self.stickY = self.stickY || otherRange.stickY;
                self.keepValueMarginsY = self.keepValueMarginsY || otherRange.keepValueMarginsY;
                compareAndReplace(self.minY, otherRange.minY, function(value) {
                    self.minY = value
                }, otherLessThan);
                compareAndReplace(self.intervalY, otherRange.intervalY, function(value) {
                    self.intervalY = value
                }, otherLessThan);
                compareAndReplace(self.maxY, otherRange.maxY, function(value) {
                    self.maxY = value
                }, otherGreaterThan);
                compareAndReplace(self.minVisibleY, otherRange.minVisibleY, function(value) {
                    self.minVisibleY = value
                }, otherLessThan);
                compareAndReplace(self.maxVisibleY, otherRange.maxVisibleY, function(value) {
                    self.maxVisibleY = value
                }, otherGreaterThan);
                setIndentByPriority('minValueMarginY');
                setIndentByPriority('maxValueMarginY');
                if (categoriesY === undefined)
                    self.categoriesY = otherCategoriesY;
                else if (otherCategoriesY && otherCategoriesY.length)
                    for (i = 0; i < otherCategoriesY.length; i++)
                        if ($.inArray(otherCategoriesY[i], categoriesY) === -1)
                            categoriesY.push(otherCategoriesY[i]);
                return this
            };
        var getBoundRangeX = function(otherRange) {
                var self = this,
                    categoriesX = self.categoriesX,
                    otherCategoriesX = otherRange.categoriesX,
                    i;
                var setIndentByPriority = function(prefix) {
                        var priorityRelation = (self[prefix + 'Priority'] || 0) - (otherRange[prefix + 'Priority'] || 0);
                        if ((self[prefix] || 0) < otherRange[prefix] && priorityRelation === 0 || priorityRelation < 0) {
                            self[prefix] = otherRange[prefix];
                            self[prefix + 'Priority'] = otherRange[prefix + 'Priority']
                        }
                    };
                self.invertX = self.invertX || otherRange.invertX;
                self.stickX = self.stickX || otherRange.stickX;
                self.keepValueMarginsX = self.keepValueMarginsX || otherRange.keepValueMarginsX;
                compareAndReplace(self.minX, otherRange.minX, function(value) {
                    self.minX = value
                }, otherLessThan);
                compareAndReplace(self.intervalX, otherRange.intervalX, function(value) {
                    self.intervalX = value
                }, otherLessThan);
                compareAndReplace(self.maxX, otherRange.maxX, function(value) {
                    self.maxX = value
                }, otherGreaterThan);
                compareAndReplace(self.minVisibleX, otherRange.minVisibleX, function(value) {
                    self.minVisibleX = value
                }, otherLessThan);
                compareAndReplace(self.maxVisibleX, otherRange.maxVisibleX, function(value) {
                    self.maxVisibleX = value
                }, otherGreaterThan);
                setIndentByPriority('minValueMarginX');
                setIndentByPriority('maxValueMarginX');
                if (categoriesX === undefined)
                    self.categoriesX = otherCategoriesX;
                else if (otherCategoriesX && otherCategoriesX.length)
                    for (i = 0; i < otherCategoriesX.length; i++)
                        if ($.inArray(otherCategoriesX[i], categoriesX) === -1)
                            categoriesX.push(otherCategoriesX[i]);
                return this
            };
        var isDefined = function() {
                return isDefinedX.call(this) || isDefinedY.call(this)
            };
        var isDefinedX = function() {
                return utils.isDefined(this.minX) && utils.isDefined(this.maxX) || utils.isDefined(this.categoriesX)
            };
        var isDefinedY = function() {
                return utils.isDefined(this.minY) && utils.isDefined(this.maxY) || utils.isDefined(this.categoriesY)
            };
        var setStubData = function(dataType) {
                setStubDataX.call(this, dataType);
                setStubDataY.call(this, dataType)
            };
        var setStubDataX = function(dataType) {
                var year = (new Date).getYear() - 1;
                var STUB_RANGE_MIN = dataType === 'datetime' ? new Date(year, 0, 1) : 0,
                    STUB_RANGE_MAX = dataType === 'datetime' ? new Date(year, 11, 31) : 10;
                $.extend(this, {
                    minX: STUB_RANGE_MIN,
                    maxX: STUB_RANGE_MAX,
                    stubDataX: true
                })
            };
        var setStubDataY = function(dataType) {
                var year = (new Date).getYear() - 1;
                var STUB_RANGE_MIN = dataType === 'datetime' ? new Date(year, 0, 1) : 0,
                    STUB_RANGE_MAX = dataType === 'datetime' ? new Date(year, 11, 31) : 10;
                $.extend(this, {
                    minY: STUB_RANGE_MIN,
                    maxY: STUB_RANGE_MAX,
                    stubDataY: true
                })
            };
        var correctValueMarginsToZeroIfNeeded = function(self) {
                var lengthX,
                    lengthY,
                    xDateTime = utils.isDate(self.maxX) || utils.isDate(self.minX),
                    yDateTime = utils.isDate(self.maxY) || utils.isDate(self.minY);
                if (utils.isDefined(self.maxX) && utils.isDefined(self.minX))
                    lengthX = self.maxX - self.minX;
                if (utils.isDefined(self.maxY) && utils.isDefined(self.minY))
                    lengthY = self.maxY - self.minY;
                if (lengthY && !yDateTime && !self.keepValueMarginsY) {
                    if (self.minY <= 0 && self.maxY <= 0 && self.maxValueMarginY && self.maxValueMarginY > self.maxY / (self.minY - self.maxY)) {
                        self.maxValueMarginY = 0;
                        self.maxY = 0
                    }
                    if (self.minY >= 0 && self.maxY >= 0 && self.minValueMarginY && self.minValueMarginY > self.minY / (self.maxY - self.minY)) {
                        self.minValueMarginY = 0;
                        self.minY = 0
                    }
                }
                if (lengthX && !xDateTime && !self.keepValueMarginsX) {
                    if (self.minX <= 0 && self.maxX <= 0 && self.maxValueMarginX && self.maxValueMarginX > self.maxX / (self.minX - self.maxX)) {
                        self.maxValueMarginX = 0;
                        self.maxX = 0
                    }
                    if (self.minX >= 0 && self.maxX >= 0 && self.minValueMarginX && self.minValueMarginX > self.minX / (self.maxX - self.minX)) {
                        self.minValueMarginX = 0;
                        self.minX = 0
                    }
                }
            };
        var applyValueMargins = function() {
                var self = this,
                    lengthX,
                    lengthY,
                    lengthVisibleX,
                    lengthVisibleY,
                    xDateTime = utils.isDate(self.maxX) || utils.isDate(self.minX),
                    yDateTime = utils.isDate(self.maxY) || utils.isDate(self.minY);
                correctValueMarginsToZeroIfNeeded(self);
                if (utils.isDefined(self.maxX) && utils.isDefined(self.minX))
                    lengthX = self.maxX - self.minX;
                if (utils.isDefined(self.maxY) && utils.isDefined(self.minY))
                    lengthY = self.maxY - self.minY;
                if (!utils.isDefined(self.minVisibleX))
                    self.minVisibleX = self.minX;
                if (!utils.isDefined(self.maxVisibleX))
                    self.maxVisibleX = self.maxX;
                if (!utils.isDefined(self.minVisibleY))
                    self.minVisibleY = self.minY;
                if (!utils.isDefined(self.maxVisibleY))
                    self.maxVisibleY = self.maxY;
                lengthVisibleX = self.maxVisibleX - self.minVisibleX;
                lengthVisibleY = self.maxVisibleY - self.minVisibleY;
                if (utils.isDefined(self.minX) && self.minValueMarginX)
                    if (xDateTime)
                        self.minX = new Date(self.minX.valueOf() - lengthX * self.minValueMarginX);
                    else
                        self.minX -= lengthX * self.minValueMarginX;
                if (utils.isDefined(self.minVisibleX) && self.minValueMarginX)
                    if (xDateTime)
                        self.minVisibleX = new Date(self.minVisibleX.valueOf() - lengthVisibleX * self.minValueMarginX);
                    else
                        self.minVisibleX -= lengthVisibleX * self.minValueMarginX;
                if (utils.isDefined(self.maxX) && self.maxValueMarginX)
                    if (xDateTime)
                        self.maxX = new Date(self.maxX.valueOf() + lengthX * self.maxValueMarginX);
                    else
                        self.maxX += lengthX * self.maxValueMarginX;
                if (utils.isDefined(self.maxVisibleX) && self.maxValueMarginX)
                    if (xDateTime)
                        self.maxVisibleX = new Date(self.maxVisibleX.valueOf() + lengthVisibleX * self.maxValueMarginX);
                    else
                        self.maxVisibleX += lengthVisibleX * self.maxValueMarginX;
                if (utils.isDefined(self.minY) && self.minValueMarginY)
                    if (yDateTime)
                        self.minY = new Date(self.minY.valueOf() - lengthY * self.minValueMarginY);
                    else
                        self.minY -= lengthY * self.minValueMarginY;
                if (utils.isDefined(self.minVisibleY) && self.minValueMarginY)
                    if (yDateTime)
                        self.minVisibleY = new Date(self.minVisibleY.valueOf() - lengthVisibleY * self.minValueMarginY);
                    else
                        self.minVisibleY -= lengthVisibleY * self.minValueMarginY;
                if (utils.isDefined(self.maxY) && self.maxValueMarginY)
                    if (yDateTime)
                        self.maxY = new Date(self.maxY.valueOf() + lengthY * self.maxValueMarginY);
                    else
                        self.maxY += lengthY * self.maxValueMarginY;
                if (utils.isDefined(self.maxVisibleY) && self.maxValueMarginY)
                    if (yDateTime)
                        self.maxVisibleY = new Date(self.maxVisibleY.valueOf() + lengthVisibleY * self.maxValueMarginY);
                    else
                        self.maxVisibleY += lengthVisibleY * self.maxValueMarginY;
                self.applyEqualLimitsMargins()
            };
        var applyEqualLimitsMargins = function() {
                var self = this,
                    xDateTime = utils.isDate(self.maxX) || utils.isDate(self.minX),
                    yDateTime = utils.isDate(self.maxY) || utils.isDate(self.minY);
                if (utils.isDefined(self.minX) && utils.isDefined(self.maxX) && self.minX.valueOf() === self.maxX.valueOf())
                    if (xDateTime) {
                        self.minX = new Date(self.minX.valueOf() - DATETIME_EQUALITY_CORRECTION);
                        self.maxX = new Date(self.maxX.valueOf() + DATETIME_EQUALITY_CORRECTION)
                    }
                    else {
                        self.minX = self.minX - NUMBER_EQUALITY_CORRECTION;
                        self.maxX = self.maxX + NUMBER_EQUALITY_CORRECTION
                    }
                if (utils.isDefined(self.minVisibleX) && utils.isDefined(self.maxVisibleX) && self.minVisibleX.valueOf() === self.maxVisibleX.valueOf())
                    if (xDateTime) {
                        self.minVisibleX = new Date(self.minVisibleX.valueOf() - DATETIME_EQUALITY_CORRECTION);
                        self.maxVisibleX = new Date(self.maxVisibleX.valueOf() + DATETIME_EQUALITY_CORRECTION)
                    }
                    else {
                        self.minVisibleX = self.minVisibleX - 1;
                        self.maxVisibleX = self.maxVisibleX + 1
                    }
                if (utils.isDefined(self.minY) && utils.isDefined(self.maxY) && self.minY.valueOf() === self.maxY.valueOf())
                    if (yDateTime) {
                        self.minY = new Date(self.minY.valueOf() - DATETIME_EQUALITY_CORRECTION);
                        self.maxY = new Date(self.maxY.valueOf() + DATETIME_EQUALITY_CORRECTION)
                    }
                    else {
                        self.minY = self.minY - NUMBER_EQUALITY_CORRECTION;
                        self.maxY = self.maxY + NUMBER_EQUALITY_CORRECTION
                    }
                if (utils.isDefined(self.minVisibleY) && utils.isDefined(self.maxVisibleY) && self.minVisibleY.valueOf() === self.maxVisibleY.valueOf())
                    if (yDateTime) {
                        self.minVisibleY = new Date(self.minVisibleY.valueOf() - DATETIME_EQUALITY_CORRECTION);
                        self.maxVisibleY = new Date(self.maxVisibleY.valueOf() + DATETIME_EQUALITY_CORRECTION)
                    }
                    else {
                        self.minVisibleY = self.minVisibleY - NUMBER_EQUALITY_CORRECTION;
                        self.maxVisibleY = self.maxVisibleY + NUMBER_EQUALITY_CORRECTION
                    }
            };
        return {
                ctor: ctor,
                getBoundRange: getBoundRange,
                getBoundRangeX: getBoundRangeX,
                getBoundRangeY: getBoundRangeY,
                isDefined: isDefined,
                isDefinedX: isDefinedX,
                isDefinedY: isDefinedY,
                setStubData: setStubData,
                setStubDataX: setStubDataX,
                setStubDataY: setStubDataY,
                applyValueMargins: applyValueMargins,
                applyEqualLimitsMargins: applyEqualLimitsMargins
            }
    }())
})(jQuery, DevExpress);

// Module viz, file legend.js

(function($, DX, undefined) {
    var charts = DX.viz.charts,
        Class = DX.Class;
    charts.Legend = Class.inherit(function() {
        var ctor = function(userOptions) {
                var debug = DX.utils.debug;
                debug.assertParam(userOptions.visible, 'Visibility was not passed');
                debug.assertParam(userOptions.renderer, 'renderer was not passed');
                debug.assertParam(userOptions.margin, 'margin was not passed');
                debug.assertParam(userOptions.markerSize, 'markerSize was not passed');
                debug.assertParam(userOptions.font.color, 'fontColor was not passed');
                debug.assertParam(userOptions.font.family, 'fontFamily was not passed');
                debug.assertParam(userOptions.font.size, 'fontSize was not passed');
                debug.assertParam(userOptions.paddingLeftRight, 'paddingLeftRight was not passed');
                debug.assertParam(userOptions.paddingTopBottom, 'paddingTopBottom was not passed');
                debug.assertParam(userOptions.columnItemSpacing, 'columnItemSpacing was not passed');
                debug.assertParam(userOptions.rowItemSpacing, 'rowItemSpacing was not passed');
                debug.assertParam(userOptions.equalColumnWidth, 'equalColumnWidth was not passed');
                var options = userOptions,
                    i,
                    series = [];
                this.renderer = options.renderer;
                if (options.horizontalAlignment !== 'center' && options.horizontalAlignment !== 'right' && options.horizontalAlignment !== 'left')
                    options.horizontalAlignment = 'right';
                if (!options.verticalAlignment) {
                    if (options.horizontalAlignment === 'center')
                        options.verticalAlignment = 'bottom';
                    if (options.horizontalAlignment === 'right' || options.horizontalAlignment === 'left')
                        options.verticalAlignment = 'top'
                }
                if (options.verticalAlignment !== 'top' && options.verticalAlignment !== 'bottom')
                    options.verticalAlignment = 'top';
                if (!options.layout) {
                    if (options.horizontalAlignment === 'center')
                        options.layout = 'horizontal';
                    if (options.horizontalAlignment === 'right' || options.horizontalAlignment === 'left')
                        options.layout = 'vertical'
                }
                if (options.position !== 'outside' && options.position !== 'inside')
                    options.position = 'outside';
                options.hoverMode = (options.hoverMode || '').toLowerCase();
                options.customizeText = $.isFunction(options.customizeText) ? options.customizeText : undefined;
                if (options.series) {
                    for (i = 0; i < options.series.length; i++)
                        if (options.series[i].options.showInLegend)
                            series.push(options.series[i]);
                    this.series = series
                }
                this.options = options
            };
        var formatLabel = function(options) {
                return options.customizeText ? options.customizeText.call(this, this) : this.seriesName
            };
        var draw = function() {
                var self = this,
                    renderer = self.renderer,
                    options = self.options,
                    series = self.series || {},
                    x = 0,
                    y = 0,
                    seriesGroups = [],
                    i,
                    j,
                    label,
                    marker,
                    singleSeriesGroup,
                    markerSize = options.markerSize,
                    isHorizontal = options.layout === 'horizontal',
                    box,
                    labelBox,
                    cols = options.columnCount,
                    rows = options.rowCount,
                    horisontalTextPosition,
                    legendGroup = self.legendGroup,
                    legendGroupOptions = {'class': 'dxLegend'},
                    insideLegendGroup,
                    background,
                    equalColumnWidth = options.equalColumnWidth,
                    trackers = [],
                    labelText,
                    data,
                    legendBox,
                    autoEdit = false,
                    canvas = self.canvas,
                    borderVisible = options.border.visible && options.border.width && options.border.color && options.border.color !== 'none';
                if (!(options.visible && series && series.length))
                    return;
                if (legendGroup)
                    legendGroup.clear();
                else {
                    if (self.clipRectID)
                        legendGroupOptions.clipId = self.clipRectID;
                    legendGroup = self.legendGroup = renderer.createGroup(legendGroupOptions)
                }
                legendGroup.append();
                insideLegendGroup = renderer.createGroup().append(legendGroup);
                if (options.position === 'inside' || options.backgroundColor || borderVisible)
                    background = renderer.createRect(0, 0, 0, 0, 0, {fill: options.backgroundColor || (options.position === 'inside' ? options.containerBackgroundColor : 'none')}).append(insideLegendGroup);
                for (i = 0; i < series.length; i++) {
                    singleSeriesGroup = renderer.createGroup({'class': 'dxLegendSeries'});
                    singleSeriesGroup.append(insideLegendGroup);
                    trackers.push(renderer.createRect(0, 0, 0, 0, 0, {
                        stroke: 'none',
                        fill: 'grey',
                        opacity: 0.0001
                    }));
                    marker = renderer.createRect(x, y, markerSize, markerSize, 0, {fill: series[i].styles.themeColor}).append(singleSeriesGroup);
                    box = marker.getBBox();
                    if (!options.itemTextPosition)
                        horisontalTextPosition = !isHorizontal;
                    else
                        horisontalTextPosition = options.itemTextPosition === 'right';
                    self.labelFormatObject = {
                        seriesName: series[i].name,
                        seriesNumber: series[i].index,
                        seriesColor: series[i].styles.themeColor
                    };
                    labelText = self.formatLabel.call(self.labelFormatObject, options);
                    label = renderer.createText(labelText, horisontalTextPosition ? x + box.width + 7 : x, horisontalTextPosition ? y : y + box.height + 2, {
                        font: options.font,
                        align: !horisontalTextPosition ? 'center' : 'left'
                    }).append(singleSeriesGroup);
                    labelBox = label.getBBox();
                    if (horisontalTextPosition)
                        label.move(0, ~~(box.y + box.height / 2 - (labelBox.y + labelBox.height / 2)));
                    else
                        label.move(~~(box.x + box.width / 2 - (labelBox.x + labelBox.width / 2)), box.y + box.height + 2 - labelBox.y);
                    series[i].initEventTriggering(trackers[i], options.hoverMode);
                    trackers[i].append(singleSeriesGroup);
                    seriesGroups.push(singleSeriesGroup)
                }
                if (cols && !rows)
                    rows = Math.ceil(series.length / cols);
                else if (!cols && rows)
                    cols = Math.ceil(series.length / rows);
                else if (cols && rows) {
                    if (isHorizontal && cols < Math.ceil(series.length / rows))
                        cols = Math.ceil(series.length / rows);
                    else if (!isHorizontal && rows < Math.ceil(series.length / cols))
                        rows = Math.ceil(series.length / cols)
                }
                else {
                    autoEdit = true;
                    if (isHorizontal) {
                        rows = 1;
                        cols = series.length
                    }
                    else {
                        cols = 1;
                        rows = series.length
                    }
                }
                data = self.getDataRowsColumns(seriesGroups, cols, rows);
                self.moveItems(data, seriesGroups, insideLegendGroup, horisontalTextPosition, trackers);
                if (autoEdit && rows === 1) {
                    legendBox = insideLegendGroup.getBBox();
                    while (legendBox.width > canvas.width - canvas.right - canvas.left && cols > 1) {
                        cols = Math.ceil(cols / 2);
                        rows = Math.ceil(series.length / cols);
                        data = self.getDataRowsColumns(seriesGroups, cols, rows);
                        self.moveItems(data, seriesGroups, insideLegendGroup, horisontalTextPosition, trackers);
                        legendBox = insideLegendGroup.getBBox()
                    }
                }
                else if (autoEdit && cols === 1) {
                    legendBox = insideLegendGroup.getBBox();
                    while (legendBox.height > canvas.height - canvas.top - canvas.bottom && rows > 1) {
                        rows = Math.ceil(rows / 2);
                        cols = Math.ceil(series.length / rows);
                        data = self.getDataRowsColumns(seriesGroups, cols, rows);
                        self.moveItems(data, seriesGroups, insideLegendGroup, horisontalTextPosition, trackers);
                        legendBox = insideLegendGroup.getBBox()
                    }
                }
                if (background) {
                    legendBox = insideLegendGroup.getBBox();
                    background.applySettings({
                        x: Math.round(legendBox.x) - options.paddingLeftRight,
                        y: Math.round(legendBox.y) - options.paddingTopBottom,
                        width: Math.round(legendBox.width) + 2 * options.paddingLeftRight,
                        height: Math.round(legendBox.height) + 2 * options.paddingTopBottom
                    });
                    if (borderVisible)
                        background.applySettings({
                            strokeWidth: options.border.width,
                            stroke: options.border.color,
                            strokeOpacity: options.border.opacity,
                            dashStyle: options.border.dashStyle,
                            rx: options.border.cornerRadius || 0,
                            ry: options.border.cornerRadius || 0
                        })
                }
                self.seriesGroups = seriesGroups;
                self.insideLegendGroup = insideLegendGroup;
                self.trackers = trackers
            };
        var getDataRowsColumns = function(seriesGroups, cols, rows) {
                var self = this,
                    i,
                    j,
                    options = self.options,
                    equalColumnWidth = options.equalColumnWidth,
                    series = self.series || {},
                    maxWidthPerColumn = [],
                    maxWidthColumn = 0,
                    maxHeightRow = 0,
                    group,
                    box;
                for (i = 0; i < cols; i++)
                    maxWidthPerColumn[i] = 0;
                for (i = 0; i < rows; i++)
                    for (j = 0; j < cols; j++) {
                        if (rows < cols)
                            group = seriesGroups[i * cols + j];
                        else
                            group = seriesGroups[i + j * rows];
                        if (!group)
                            break;
                        box = group.getBBox();
                        if (maxHeightRow < box.height)
                            maxHeightRow = box.height;
                        if (!equalColumnWidth) {
                            if (maxWidthPerColumn[j] < box.width)
                                maxWidthPerColumn[j] = box.width
                        }
                        else if (maxWidthColumn < box.width)
                            maxWidthColumn = box.width
                    }
                return {
                        rows: rows,
                        cols: cols,
                        maxWidthPerColumn: maxWidthPerColumn,
                        maxWidthColumn: maxWidthColumn,
                        maxHeightRow: maxHeightRow
                    }
            };
        var moveItems = function(data, seriesGroups, insideLegendGroup, horisontalTextPosition, trackers) {
                var self = this,
                    i,
                    j,
                    rows,
                    cols,
                    number,
                    group,
                    box,
                    xShift = 0,
                    yShift = 0,
                    widthColumn,
                    options = self.options,
                    xPadding = options.columnItemSpacing,
                    yPadding = options.rowItemSpacing,
                    equalColumnWidth = options.equalColumnWidth,
                    renderer = self.renderer,
                    maxWidthPerColumn = [],
                    maxWidthColumn = 0,
                    maxHeightRow = 0;
                rows = data.rows;
                cols = data.cols;
                maxHeightRow = data.maxHeightRow;
                maxWidthColumn = data.maxWidthColumn;
                maxWidthPerColumn = data.maxWidthPerColumn;
                for (i = 0; i < rows; i++) {
                    for (j = 0; j < cols; j++) {
                        if (rows < cols)
                            number = i * cols + j;
                        else
                            number = i + j * rows;
                        group = seriesGroups[number];
                        if (!group)
                            break;
                        box = group.getBBox();
                        widthColumn = !equalColumnWidth ? maxWidthPerColumn[j] : maxWidthColumn;
                        if (horisontalTextPosition) {
                            group.move(xShift - box.x, yShift);
                            trackers[number].applySettings({
                                x: box.x - xPadding / 2,
                                y: box.y - yPadding / 2,
                                height: maxHeightRow + yPadding,
                                width: widthColumn + xPadding
                            })
                        }
                        else {
                            group.move(xShift - box.x - box.width / 2 + widthColumn / 2, yShift);
                            trackers[number].applySettings({
                                x: box.x + box.width / 2 - widthColumn / 2 - xPadding / 2,
                                y: box.y - yPadding / 2,
                                height: maxHeightRow + yPadding,
                                width: widthColumn + xPadding
                            })
                        }
                        xShift = xShift + widthColumn + xPadding
                    }
                    yShift = yShift + maxHeightRow + yPadding;
                    xShift = 0
                }
            };
        var getBoundingRect = function() {
                if (this.insideLegendGroup)
                    return this.insideLegendGroup.getBBox();
                return {}
            };
        var toForeground = function() {
                this.legendGroup && this.legendGroup.toForeground()
            };
        var shift = function(x, y) {
                var self = this,
                    settings = {};
                if (x)
                    settings.translateX = x;
                if (y)
                    settings.translateY = y;
                self.insideLegendGroup.applySettings(settings)
            };
        return {
                ctor: ctor,
                draw: draw,
                getBoundingRect: getBoundingRect,
                shift: shift,
                toForeground: toForeground,
                formatLabel: formatLabel,
                getDataRowsColumns: getDataRowsColumns,
                moveItems: moveItems
            }
    }())
})(jQuery, DevExpress);

// Module viz, file tooltip.js

(function($, DX, undefined) {
    var charts = DX.viz.charts,
        utils = DX.utils,
        Class = DX.Class,
        core = DX.viz.core,
        formatHelper = DX.formatHelper;
    var Tooltip = Class.inherit({
            ctor: function(data) {
                this.renderer = data.renderer;
                this.options = data;
                this.style = {visibility: 'hidden'};
                this.customColor = data.color;
                this.textStyle = {
                    font: data.font,
                    align: 'center',
                    visibility: 'hidden'
                };
                this.canvasWidth = data.canvasWidth
            },
            formatValueTooltip: function(options) {
                return formatHelper.format(this.value, options.format, options.precision)
            },
            formatTooltip: function(options) {
                this.argumentText = formatHelper.format(this.argument, options.argumentFormat, options.argumentPrecision);
                if (this.percent !== undefined)
                    this.percentText = formatHelper.format(this.percent, 'percent', options.percentPrecision);
                return options.customizeText ? options.customizeText.call(this, this) : this.valueText
            },
            _getData: function(x, y, bbox) {
                var SHADOW_OFFSET = 4,
                    xt = x,
                    yt = y,
                    i,
                    align = 'center',
                    pointsOfShadow = [],
                    points = [],
                    arrowLength = this.options.arrowLength,
                    cloudWidth = bbox.width + this.options.paddingLeftRight * 2,
                    cloudHeight = bbox.height + this.options.paddingTopBottom * 2;
                if (cloudWidth / 2 > x) {
                    points = this._setArrowLeft(cloudWidth, cloudHeight, bbox, arrowLength, x, y);
                    align = 'left';
                    xt += this.options.paddingLeftRight
                }
                else if (x + cloudWidth / 2 > this.canvasWidth) {
                    points = this._setArrowRight(cloudWidth, cloudHeight, bbox, arrowLength, x, y);
                    align = 'right';
                    xt -= this.options.paddingLeftRight
                }
                else
                    points = this._setArrowCenter(cloudWidth, cloudHeight, bbox, arrowLength, x, y);
                if (cloudHeight + arrowLength < y)
                    yt -= arrowLength + cloudHeight / 2 - bbox.height / 2 + this.tooltipOffset;
                else
                    yt += arrowLength + cloudHeight / 2 + bbox.height / 2 + this.tooltipOffset;
                $.extend(pointsOfShadow, points);
                for (i = 1; i < pointsOfShadow.length; i += 2)
                    if (cloudHeight + arrowLength < y)
                        pointsOfShadow[i] += SHADOW_OFFSET;
                    else
                        pointsOfShadow[i] -= SHADOW_OFFSET;
                if (cloudHeight + arrowLength < y)
                    pointsOfShadow[1] += 2;
                else
                    pointsOfShadow[1] -= 2;
                if (cloudWidth / 2 > x)
                    pointsOfShadow[2] += 2;
                else if (x + cloudWidth / 2 > this.canvasWidth)
                    pointsOfShadow[pointsOfShadow.length - 2] -= 2;
                else {
                    pointsOfShadow[2] += 2;
                    pointsOfShadow[pointsOfShadow.length - 2] -= 2
                }
                return {
                        points: points,
                        text: {
                            x: xt,
                            y: yt,
                            align: align
                        },
                        pointsOfShadow: pointsOfShadow
                    }
            },
            _update: function() {
                var box,
                    data;
                this.text.updateText(this.tooltipText);
                box = this.text.getBBox();
                data = this._getData(this.x, this.y, box);
                this.shadow.applySettings({points: data.pointsOfShadow});
                this.cloud.applySettings({
                    points: data.points,
                    fill: this.style.fill
                });
                this.text.applySettings({y: data.text.y});
                box = this.text.getBBox();
                this.text.applySettings({
                    x: data.text.x,
                    y: data.text.y - (box.y + box.height - data.text.y),
                    align: data.text.align
                })
            },
            draw: function() {
                var shadow,
                    cloud,
                    text;
                this.tooltipGroup = this.renderer.createGroup({'class': 'dxTooltip'});
                shadow = this.renderer.createPath({}, {
                    fill: '#000000',
                    stroke: 'none',
                    visibility: 'hidden',
                    opacity: 0.1
                });
                shadow.append(this.tooltipGroup);
                this.shadow = shadow;
                cloud = this.renderer.createArea({}, this.style);
                cloud.append(this.tooltipGroup);
                this.cloud = cloud;
                text = this.renderer.createText('0', 0, 0, this.textStyle);
                text.append(this.tooltipGroup);
                this.text = text;
                this.tooltipGroup.append()
            },
            show: function() {
                this.cloud.applySettings({visibility: "visible"});
                this.text.applySettings({visibility: "visible"});
                this.shadow.applySettings({visibility: "visible"})
            },
            hide: function() {
                this.cloud.applySettings({visibility: 'hidden'});
                this.text.applySettings({visibility: 'hidden'});
                this.shadow.applySettings({visibility: "hidden"})
            },
            move: function(x, y, offset, text, color) {
                this.x = x;
                this.y = y;
                this.tooltipOffset = offset;
                this.tooltipText = text;
                this.style.fill = this.customColor || color;
                this._update()
            },
            _setArrowCenter: function(cloudWidth, cloudHeight, bbox, arrowLength, x, y) {
                var verticalInvert = false,
                    points = [],
                    xc = x,
                    yc = y,
                    arrowWidth = 20;
                if (cloudHeight + arrowLength < y)
                    yc -= this.tooltipOffset;
                else {
                    yc += this.tooltipOffset;
                    verticalInvert = true
                }
                points = [xc, yc];
                if (!verticalInvert)
                    yc -= arrowLength;
                else
                    yc += arrowLength;
                xc += arrowWidth / 2;
                points.push(xc, yc);
                xc += cloudWidth / 2 - arrowWidth / 2;
                points.push(xc, yc);
                if (verticalInvert)
                    yc += cloudHeight;
                else
                    yc -= cloudHeight;
                points.push(xc, yc);
                xc -= cloudWidth;
                points.push(xc, yc);
                if (verticalInvert)
                    yc -= cloudHeight;
                else
                    yc += cloudHeight;
                points.push(xc, yc);
                xc += cloudWidth / 2 - arrowWidth / 2;
                points.push(xc, yc);
                return points
            },
            _setArrowLeft: function(cloudWidth, cloudHeight, bbox, arrowLength, x, y) {
                var verticalInvert = false,
                    points = [],
                    xc = x,
                    yc = y,
                    arrowWidth = 20;
                if (cloudHeight + arrowLength < y)
                    yc -= this.tooltipOffset;
                else {
                    yc += this.tooltipOffset;
                    verticalInvert = true
                }
                points = [xc, yc];
                if (!verticalInvert)
                    yc -= arrowLength;
                else
                    yc += arrowLength;
                xc += arrowWidth;
                points.push(xc, yc);
                xc += cloudWidth - arrowWidth;
                points.push(xc, yc);
                if (verticalInvert)
                    yc += cloudHeight;
                else
                    yc -= cloudHeight;
                points.push(xc, yc);
                xc -= cloudWidth;
                points.push(xc, yc);
                if (verticalInvert)
                    yc -= cloudHeight + arrowLength;
                else
                    yc += cloudHeight + arrowLength;
                points.push(xc, yc);
                return points
            },
            _setArrowRight: function(cloudWidth, cloudHeight, bbox, arrowLength, x, y) {
                var verticalInvert = false,
                    points = [],
                    xc = x,
                    yc = y,
                    arrowWidth = 20;
                if (cloudHeight + arrowLength < y)
                    yc -= this.tooltipOffset;
                else {
                    yc += this.tooltipOffset;
                    verticalInvert = true
                }
                points = [xc, yc];
                if (!verticalInvert)
                    yc -= arrowLength + cloudHeight;
                else
                    yc += arrowLength + cloudHeight;
                points.push(xc, yc);
                xc -= cloudWidth;
                points.push(xc, yc);
                if (verticalInvert)
                    yc -= cloudHeight;
                else
                    yc += cloudHeight;
                points.push(xc, yc);
                xc += cloudWidth - arrowWidth;
                points.push(xc, yc);
                if (verticalInvert)
                    yc -= arrowLength;
                else
                    yc += arrowLength;
                xc += arrowWidth;
                points.push(xc, yc);
                return points
            }
        });
    charts.Tooltip = Tooltip
})(jQuery, DevExpress);

// Module viz, file chartTitle.js

(function($, DX, undefined) {
    var charts = DX.viz.charts,
        Class = DX.Class,
        isDefined = DX.utils.isDefined,
        endsWith = function(value, pattern) {
            return value.substr(value.length - pattern.length) === pattern
        },
        startsWith = function(value, pattern) {
            return value.indexOf(pattern) === 0
        };
    charts.ChartTitle = Class.inherit({
        ctor: function(renderer, canvas, options) {
            var self = this;
            self._parseAlignments(options);
            self.horizontalAlignment = options.horizontalAlignment;
            self.verticalAlignment = options.verticalAlignment;
            self.renderer = renderer;
            self.canvas = canvas;
            self.options = options;
            self.clipRect = self.createClipRect()
        },
        _parseAlignments: function(options) {
            if (isDefined(options.position) && !(isDefined(options.verticalAlignment) && isDefined(options.horizontalAlignment))) {
                options.position = options.position.toLowerCase();
                options.verticalAlignment = endsWith(options.position, 'top') ? 'top' : 'bottom';
                options.horizontalAlignment = startsWith(options.position, 'left') ? 'left' : startsWith(options.position, 'center') && 'center' || 'right';
                return
            }
            options.verticalAlignment = (options.verticalAlignment || '').toLowerCase();
            options.horizontalAlignment = (options.horizontalAlignment || '').toLowerCase();
            if (options.verticalAlignment !== 'top' && options.verticalAlignment !== 'bottom')
                options.verticalAlignment = 'top';
            if (options.horizontalAlignment !== 'left' && options.horizontalAlignment !== 'center' && options.horizontalAlignment !== 'right')
                options.horizontalAlignment = 'center'
        },
        render: function() {
            var self = this,
                titleOptions = self.options,
                renderer = self.renderer,
                horizontalAlignment = self.horizontalAlignment,
                attr,
                title,
                clipRectID = self.clipRect ? self.clipRect.id : undefined,
                titleGroup = renderer.createGroup({
                    'class': 'dxChartTitle',
                    clipId: clipRectID
                }).append(),
                innerTitleGroup = renderer.createGroup().append(titleGroup);
            if (!titleOptions.text)
                return;
            attr = {
                font: titleOptions.font,
                align: horizontalAlignment,
                style: titleOptions.fontStyle
            };
            title = renderer.createText(titleOptions.text, self.canvas.left, self.canvas.top, attr);
            title.append(innerTitleGroup);
            self.innerTitleGroup = innerTitleGroup
        },
        getBoundingRect: function() {
            var options = this.options,
                box;
            if (!this.innerTitleGroup)
                return {
                        width: 0,
                        height: 0,
                        x: 0,
                        y: 0
                    };
            box = this.innerTitleGroup.getBBox();
            if (isDefined(options.placeholderSize))
                box.height = options.placeholderSize;
            return box
        },
        shift: function(x, y) {
            this.innerTitleGroup.move(x, y)
        },
        createClipRect: function() {
            var self = this,
                renderer = self.renderer,
                rect;
            if (isDefined(self.options.placeholderSize)) {
                rect = renderer.createClipRect(0, 0, 0, 0);
                return rect
            }
        },
        setClipRectSettings: function() {
            var self = this,
                canvas = self.canvas,
                verticalAlignment = self.verticalAlignment,
                clipRect = self.clipRect;
            if (clipRect)
                if (verticalAlignment === 'top')
                    clipRect.applySettings({
                        x: 0,
                        y: 0,
                        height: canvas.top,
                        width: canvas.width
                    });
                else if (verticalAlignment === 'bottom')
                    clipRect.applySettings({
                        x: 0,
                        y: canvas.height - canvas.bottom,
                        height: canvas.bottom,
                        width: canvas.width
                    })
        }
    })
})(jQuery, DevExpress);

// Module viz, file axis.js

(function($, DX, undefined) {
    var charts = DX.viz.charts,
        core = DX.viz.core,
        Class = DX.Class,
        utils = DX.utils,
        math = Math,
        AXIS_VALUE_MARGIN_PRIORITY = 100,
        AXIS_LABEL_SPACING = 5,
        AXIS_STAGGER_OVERLAPPING_KOEF = 2,
        MAX_GRID_BORDER_ADHENSION = 4,
        CANVAS_POSITION_PREFIX = 'canvas_position_',
        CANVAS_POSITION_BOTTOM = 'canvas_position_bottom',
        CANVAS_POSITION_TOP = 'canvas_position_top',
        CANVAS_POSITION_LEFT = 'canvas_position_left',
        CANVAS_POSITION_RIGHT = 'canvas_position_right';
    charts.AXIS_STAGGER_OVERLAPPING_KOEF = AXIS_STAGGER_OVERLAPPING_KOEF;
    charts.Axis = Class.inherit(function() {
        var ctor = function(renderer, options) {
                var debug = DX.utils.debug;
                debug.assertParam(renderer, 'renderer was not passed');
                debug.assertParam(options.label, 'label was not passed');
                debug.assertParam(options.tick, 'tick was not passed');
                debug.assertParam(options.grid, 'grid was not passed');
                debug.assertParam(options.title, 'title was not passed');
                debug.assert(options.axisDivisionFactor, 'axisDivisionFactor was not passed');
                debug.assert(options.stripStyle, 'stripStyle was not passed');
                debug.assert(options.position, 'position was not passed');
                debug.assertParam(options.isHorizontal, 'isHorizontal was not passed');
                this.renderer = renderer;
                this.init(options)
            };
        var init = function(options) {
                var categories = options.categories,
                    labelOptions = options.label;
                options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : 'none';
                this.hasLabelFormat = labelOptions.format !== '' && utils.isDefined(labelOptions.format);
                this.options = options;
                this.staggered = labelOptions.staggered;
                this._testStaggeringSpacing = labelOptions.staggeringSpacing;
                processCustomOptions(options);
                if (categories) {
                    this.labelsNumber = categories.length;
                    this.ticksNumber = this.labelsNumber
                }
                options.range = {
                    min: options.min,
                    max: options.max,
                    categories: options.categories && options.categories.slice(0)
                };
                this.pane = options.pane;
                this.textOptions = {
                    align: labelOptions.alignment,
                    font: labelOptions.font,
                    opacity: labelOptions.opacity,
                    style: labelOptions.style
                }
            };
        var updateTranslatorInterval = function(self) {
                var i,
                    tickValues,
                    options = self.options,
                    businessRange = self.translator.getBusinessRange(),
                    interval;
                if (businessRange && businessRange.getBoundRange && !options.categories) {
                    tickValues = self.getTickValues();
                    for (i = 0; i < tickValues.length - 1; i++) {
                        interval = Math.abs(tickValues[i] - tickValues[i + 1]);
                        if (options.isHorizontal)
                            businessRange.getBoundRange({intervalX: interval});
                        else
                            businessRange.getBoundRange({intervalY: interval})
                    }
                }
            };
        var updateRotationAngle = function(self) {
                var options = self.options,
                    rotationAngle,
                    labelOptions = options.label;
                if (!options.isHorizontal || !labelOptions || !utils.isDefined(labelOptions.overlappingBehavior))
                    return;
                switch (labelOptions.overlappingBehavior.mode) {
                    case'enlargeTickInterval':
                    case'stagger':
                        rotationAngle = null;
                        break;
                    case'rotate':
                        rotationAngle = labelOptions.overlappingBehavior.rotationAngle;
                        break;
                    default:
                        rotationAngle = labelOptions.rotationAngle
                }
                if (!labelOptions.userAlignment)
                    self.textOptions.align = rotationAngle ? 'left' : 'center';
                self.textOptions.rotate = rotationAngle
            };
        var getStaggeringSpacing = function(self) {
                var self = this,
                    labelOptions = self.options.label;
                if (labelOptions) {
                    if (!self.staggered && self.isStaggerOverlapping)
                        return labelOptions.overlappingBehavior.staggeringSpacing;
                    return labelOptions.staggeringSpacing
                }
                return 0
            };
        var setTranslator = function(translator) {
                var debug = DX.utils.debug;
                debug.assertParam(translator, 'translator was not passed');
                this.translator = translator;
                this.needsLabelAdjustment = false;
                this.resetTicks();
                updateTranslatorInterval(this)
            };
        var resetTicks = function() {
                this._tickValues = this._tickPositions = null
            };
        var setRange = function(range) {
                var debug = DX.utils.debug;
                debug.assertParam(range, 'range was not passed');
                var self = this,
                    options = self.options;
                if (options.isHorizontal) {
                    options.min = range.minVisibleX;
                    options.max = range.maxVisibleX;
                    options.categories = range.categoriesX;
                    options.stubData = range.stubDataX
                }
                else {
                    options.min = range.minVisibleY;
                    options.max = range.maxVisibleY;
                    options.categories = range.categoriesY;
                    options.stubData = range.stubDataY
                }
                self.needsLabelAdjustment = false;
                this.resetTicks()
            };
        var processCustomOptions = function(options) {
                var label = options.label,
                    left = 'left',
                    right = 'right',
                    top = 'top',
                    bottom = 'bottom';
                if (options.isHorizontal) {
                    if (!(options.position === bottom || options.position === top))
                        options.position = bottom
                }
                else if (!(options.position === left || options.position === right))
                    options.position = left;
                if (options.position === right) {
                    label.indentFromAxis *= -1;
                    if (!label.userAlignment)
                        label.alignment = left
                }
                if (options.position === top)
                    label.indentFromAxis *= -1;
                if (label.rotationAngle && options.isHorizontal)
                    if (!label.userAlignment)
                        label.alignment = left
            };
        var getXAxisPosition = function(self) {
                var delta = 0;
                if (self.delta)
                    delta = self.delta[self.options.position] || 0;
                return self.translator.translateX(CANVAS_POSITION_PREFIX + self.options.position) + delta
            };
        var getYAxisPosition = function(self) {
                var delta = 0;
                if (self.delta)
                    delta = self.delta[self.options.position] || 0;
                return self.translator.translateY(CANVAS_POSITION_PREFIX + self.options.position) + delta
            };
        var drawAxis = function drawAxis(self, group) {
                var translator = self.translator,
                    options = self.options,
                    lineOptions = options,
                    axisAttr = {
                        strokeWidth: lineOptions.width,
                        stroke: lineOptions.color,
                        strokeOpacity: lineOptions.opacity
                    },
                    axis,
                    axisPosition = self.axisPosition,
                    start,
                    end;
                if (!lineOptions.visible)
                    return;
                if (self.options.isHorizontal) {
                    if (options.categories) {
                        start = translator.translateX(CANVAS_POSITION_LEFT);
                        end = translator.translateX(CANVAS_POSITION_RIGHT)
                    }
                    else {
                        start = translator.translateX(options.min);
                        end = translator.translateX(options.max)
                    }
                    axis = self.renderer.createLine(start, axisPosition, end, axisPosition, axisAttr)
                }
                else {
                    if (options.categories) {
                        start = translator.translateY(CANVAS_POSITION_TOP);
                        end = translator.translateY(CANVAS_POSITION_BOTTOM)
                    }
                    else {
                        start = translator.translateY(options.min);
                        end = translator.translateY(options.max)
                    }
                    axis = self.renderer.createLine(axisPosition, start, axisPosition, end, axisAttr)
                }
                axis.append(group)
            };
        var getTickValues = function() {
                var self = this,
                    options = self.options,
                    tickProvider = options.tickProvider,
                    translator = self.translator,
                    labelOptions = options.label,
                    categories = options.categories,
                    step,
                    ticksOptions,
                    overlappingBehavior = options.isHorizontal ? labelOptions.overlappingBehavior : null,
                    getPosition = options.isHorizontal ? self.translator.translateX : self.translator.translateY;
                ticksOptions = getTicksOptions(self, options, getPosition, categories);
                if (!self._tickValues) {
                    self.textOptions.rotate = labelOptions.rotationAngle;
                    self.textOptions.align = labelOptions.alignment;
                    self._tickValues = $.isArray(categories) ? categories : tickProvider.getTicks(ticksOptions);
                    this._needProcessOverlapping = true
                }
                if ((utils.isDate(options.min) || utils.isDate(categories && categories[0])) && !this.hasLabelFormat)
                    labelOptions.format = DX.formatHelper.getDateFormatByTicks(self._tickValues);
                if (this._needProcessOverlapping && overlappingBehavior && overlappingBehavior.mode !== 'ignore') {
                    if (overlappingBehavior.mode === 'stagger')
                        ticksOptions.screenDelta *= AXIS_STAGGER_OVERLAPPING_KOEF;
                    step = tickProvider.getAutoArrangementStep(self._tickValues, ticksOptions);
                    self._testTKScreenDelta = ticksOptions.screenDelta;
                    self._testIsAutoArrangement = Boolean(step - 1);
                    if (step > 1) {
                        self.staggered = false;
                        updateRotationAngle(self);
                        step = tickProvider.getAutoArrangementStep(self._tickValues, ticksOptions);
                        self._tickValues = step > 1 ? tickProvider.getAutoArrangementTicks(self._tickValues, ticksOptions, step) : self._tickValues
                    }
                    else {
                        self.staggered = labelOptions.staggered;
                        self.staggeringSpacing = labelOptions.staggeringSpacing
                    }
                    this._needProcessOverlapping = false;
                    tickProvider._removeInvalidDatesWithUnitBegining(self._tickValues, ticksOptions)
                }
                return self._tickValues
            };
        var setTickValues = function(tickValues) {
                this.resetTicks();
                this._tickValues = tickValues;
                if (tickValues)
                    this._needProcessOverlapping = true
            };
        var getTicksOptions = function(self, options, getPosition, categories) {
                var bpRange = options.isHorizontal ? [CANVAS_POSITION_LEFT, CANVAS_POSITION_RIGHT] : [CANVAS_POSITION_BOTTOM, CANVAS_POSITION_TOP],
                    screenDelta = Math.abs(getPosition.call(self.translator, bpRange[1]) - getPosition.call(self.translator, bpRange[0])),
                    digitPosition = utils.getSignificantDigitPosition(Math.abs(options.max - options.min) / screenDelta),
                    correctingValue,
                    min = options.min,
                    max = options.max;
                if (utils.isNumber(min)) {
                    min = utils.roundValue(options.min, digitPosition);
                    if (min < options.min) {
                        correctingValue = Math.pow(10, -digitPosition);
                        min = utils.applyPrecisionByMinDelta(min, correctingValue, min + correctingValue)
                    }
                    if (min > max)
                        min = options.min
                }
                if (categories && categories.length > 0) {
                    min = categories[0];
                    max = categories[categories.length - 1]
                }
                return {
                        min: min,
                        max: max,
                        textOptions: self.textOptions,
                        getText: function(value) {
                            return formatLabel(value, options.label)
                        },
                        renderer: self.renderer,
                        textSpacing: AXIS_LABEL_SPACING,
                        translator: self.translator,
                        tickInterval: self.options.stubData ? null : options.tickInterval,
                        screenDelta: screenDelta,
                        gridSpacingFactor: options.axisDivisionFactor,
                        isHorizontal: options.isHorizontal,
                        setTicksAtUnitBeginning: options.setTicksAtUnitBeginning,
                        incidentOccured: options.incidentOccured
                    }
            };
        var prepareLabelsToDraw = function prepareLabelsToDraw(self) {
                var options = self.options,
                    ticksValues,
                    ticks = [],
                    getPosition,
                    i;
                if (options.isHorizontal)
                    getPosition = self.translator.translateX;
                else
                    getPosition = self.translator.translateY;
                ticksValues = self.getTickValues();
                if (ticksValues.hideLabels || options.stubData)
                    ticks.hideLabels = true;
                for (i = 0; i < ticksValues.length; i++)
                    ticks.push({
                        text: ticksValues[i],
                        pos: getPosition.call(self.translator, ticksValues[i])
                    });
                return ticks
            };
        var prepareTicksToDraw = function prepareTicksToDraw(self) {
                var ticks,
                    options = self.options,
                    translator = self.translator,
                    tickDelta,
                    i;
                if (!self._tickPositions) {
                    ticks = prepareLabelsToDraw(self);
                    if (options.categories && (options.discreteAxisDivisionMode !== 'crossLabels' || !options.discreteAxisDivisionMode)) {
                        if (options.isHorizontal) {
                            tickDelta = translator.getIntervalX() / 2;
                            if (!options.valueMarginsEnabled)
                                ticks = ticks.slice(0, ticks.length - 1)
                        }
                        else {
                            tickDelta = -translator.getIntervalY() / 2;
                            if (!options.valueMarginsEnabled)
                                ticks = ticks.slice(1, ticks.length)
                        }
                        for (i = 0; i < ticks.length; i++)
                            ticks[i].pos = ticks[i].pos + tickDelta
                    }
                    self._tickPositions = ticks
                }
                return self._tickPositions
            };
        var drawTicks = function drawTicks(self, group) {
                var renderer = self.renderer,
                    options = self.options,
                    ticksOptions = options.tick,
                    categories = options.categories,
                    tickDelta = options.discreteAxisDivisionMode === 'crossLabels' ? 0 : 0.5,
                    i,
                    defaultTickLength = 8,
                    attr = {
                        strokeWidth: 1,
                        stroke: ticksOptions.color,
                        strokeOpacity: ticksOptions.opacity
                    },
                    currentTickConstant,
                    axisPosition = self.axisPosition,
                    tickPositionStart,
                    tickPositionEnd,
                    tick,
                    ticksToDraw;
                if (!ticksOptions.visible)
                    return;
                ticksToDraw = prepareTicksToDraw(self);
                if (self.options.isHorizontal)
                    for (i = 0; i < ticksToDraw.length; i++) {
                        tick = ticksToDraw[i];
                        renderer.createLine(tick.pos, axisPosition - defaultTickLength / 2, tick.pos, axisPosition + defaultTickLength / 2, attr).append(group)
                    }
                else
                    for (i = 0; i < ticksToDraw.length; i++) {
                        tick = ticksToDraw[i];
                        renderer.createLine(axisPosition - defaultTickLength / 2, tick.pos, axisPosition + defaultTickLength / 2, tick.pos, attr).append(group)
                    }
            };
        var formatLabel = function formatLabel(value, options) {
                var formatObject = {
                        value: value,
                        valueText: DX.formatHelper.format(value, options.format, options.precision) || ''
                    };
                return options.customizeText ? options.customizeText.call(formatObject, formatObject) : formatObject.valueText
            };
        var setPercentLabelFormat = function() {
                var labelOptions = this.options.label;
                if (!labelOptions.format)
                    labelOptions.format = 'percent'
            };
        var createTextForVerticalLabels = function(text, y, x, textOptions) {
                return this.createText(text, x, y, textOptions)
            };
        var drawLabels = function drawLabels(self, group) {
                var i,
                    options = self.options,
                    categories = options.categories,
                    renderer = self.renderer,
                    axisPosition = self.axisPosition,
                    labelOptions = options.label,
                    labelOffset = labelOptions.indentFromAxis,
                    labelsToDraw,
                    labelPoint,
                    label,
                    labels = [],
                    createText = options.isHorizontal ? renderer.createText : createTextForVerticalLabels,
                    currentLabelConst = options.isHorizontal ? axisPosition + labelOffset : axisPosition - labelOffset,
                    text;
                if (!labelOptions.visible)
                    return;
                labelsToDraw = prepareLabelsToDraw(self);
                if (labelsToDraw.length === 0 || labelsToDraw.hideLabels)
                    return true;
                for (i = 0; i < labelsToDraw.length; i++) {
                    labelPoint = labelsToDraw[i];
                    text = formatLabel(labelPoint.text, labelOptions);
                    if (utils.isDefined(text) && text !== '') {
                        label = createText.call(renderer, text, labelPoint.pos, currentLabelConst, self.textOptions);
                        labels.push(label);
                        label.append(group);
                        initLabelEvents(self, label, labelPoint.text)
                    }
                }
                self.labels = labels
            };
        var initLabelEvents = function(axis, labelElement, value) {
                var hoverMode = axis.options.hoverMode;
                labelElement.on({click: function(event) {
                        $(axis).trigger(event, [axis, value])
                    }});
                if (hoverMode && hoverMode !== 'none')
                    labelElement.on({
                        mouseover: function(event) {
                            $(axis).trigger(event, [axis, value, hoverMode])
                        },
                        mouseout: function(event) {
                            $(axis).trigger(event, [axis, value, hoverMode])
                        },
                        mousemove: function(event) {
                            $(axis).trigger(event, [axis, value, hoverMode])
                        }
                    })
            };
        var getMultipleAxesSpacing = function() {
                return this.options.multipleAxesSpacing || 0
            };
        var drawTitle = function drawTitle(self, group) {
                var i,
                    options = self.options,
                    renderer = self.renderer,
                    axisPosition = self.axisPosition,
                    titleOptions = options.title,
                    margin = titleOptions.margin,
                    title,
                    attr = {
                        font: titleOptions.font,
                        opacity: titleOptions.opacity,
                        align: 'center'
                    };
                if (!titleOptions.text)
                    return;
                if (self.options.isHorizontal)
                    if (self.options.position === 'bottom')
                        title = renderer.createText(titleOptions.text, self.translator.canvas.left + self.translator.width / 2, axisPosition, attr);
                    else
                        title = renderer.createText(titleOptions.text, self.translator.canvas.left + self.translator.width / 2, axisPosition, attr);
                else if (self.options.position === 'left') {
                    attr.rotate = 270;
                    title = renderer.createText(titleOptions.text, axisPosition, self.translator.canvas.top + self.translator.height / 2, attr)
                }
                else {
                    attr.rotate = 90;
                    title = renderer.createText(titleOptions.text, axisPosition, self.translator.canvas.top + self.translator.height / 2, attr)
                }
                title.append(group);
                self.title = title
            };
        var drawGrid = function drawGrid(self, group, borderOptions) {
                var renderer = self.renderer,
                    options = self.options,
                    gridOptions = options.grid,
                    categories = options.categories,
                    translator = self.translator,
                    tickDelta = options.discreteAxisDivisionMode === 'crossLabels' ? 0 : 0.5,
                    positionsToDraw,
                    i,
                    attr = {
                        strokeWidth: gridOptions.width,
                        stroke: gridOptions.color,
                        strokeOpacity: gridOptions.opacity
                    },
                    currentTickConstant,
                    axisPosition = self.axisPosition,
                    positionFrom,
                    positionTo,
                    tick,
                    firstBorderLinePosition,
                    lastBorderLinePosition,
                    borderOptions = borderOptions || {visible: false};
                if (!gridOptions.visible)
                    return;
                positionsToDraw = prepareTicksToDraw(self);
                if (self.options.isHorizontal) {
                    positionFrom = translator.translateY(CANVAS_POSITION_BOTTOM);
                    positionTo = translator.translateY(CANVAS_POSITION_TOP);
                    firstBorderLinePosition = borderOptions.visible && borderOptions.left ? translator.translateX(CANVAS_POSITION_LEFT) : undefined;
                    lastBorderLinePosition = borderOptions.visible && borderOptions.right ? translator.translateX(CANVAS_POSITION_RIGHT) : undefined;
                    for (i = 0; i < positionsToDraw.length; i++) {
                        tick = positionsToDraw[i];
                        if (math.abs(tick.pos - firstBorderLinePosition) < MAX_GRID_BORDER_ADHENSION || math.abs(tick.pos - lastBorderLinePosition) < MAX_GRID_BORDER_ADHENSION)
                            continue;
                        renderer.createLine(tick.pos, positionFrom, tick.pos, positionTo, attr).append(group)
                    }
                }
                else {
                    positionFrom = translator.translateX(CANVAS_POSITION_LEFT);
                    positionTo = translator.translateX(CANVAS_POSITION_RIGHT);
                    firstBorderLinePosition = borderOptions.visible && borderOptions.top ? translator.translateY(CANVAS_POSITION_TOP) : undefined;
                    lastBorderLinePosition = borderOptions.visible && borderOptions.bottom ? translator.translateY(CANVAS_POSITION_BOTTOM) : undefined;
                    for (i = 0; i < positionsToDraw.length; i++) {
                        tick = positionsToDraw[i];
                        if (math.abs(tick.pos - firstBorderLinePosition) < MAX_GRID_BORDER_ADHENSION || math.abs(tick.pos - lastBorderLinePosition) < MAX_GRID_BORDER_ADHENSION)
                            continue;
                        renderer.createLine(positionFrom, tick.pos, positionTo, tick.pos, attr).append(group)
                    }
                }
            };
        var drawStrip = function drawStrip(self, group) {
                var renderer = self.renderer,
                    options = self.options,
                    stripData = options.strips,
                    translator = self.translator,
                    i,
                    stripLabels = [],
                    stripRects = [],
                    rect,
                    stripOptions,
                    positionFrom,
                    positionTo,
                    stripPos;
                if (options.stubData)
                    return;
                var getPos = function(startV, endV, isHorizontal, range) {
                        var isContinous = isHorizontal ? !!(range.minVisibleX || range.maxVisibleX) : !!(range.minVisibleY || range.maxVisibleY),
                            cateories = (isHorizontal ? range.categoriesX : range.categoriesY) || [],
                            translate = isHorizontal ? function(val) {
                                return translator.translateX(val)
                            } : function(val) {
                                return translator.translateY(val)
                            },
                            invert = isHorizontal ? !!range.invertX : range.invertY,
                            defaultPos = isHorizontal ? [CANVAS_POSITION_LEFT, CANVAS_POSITION_RIGHT] : [CANVAS_POSITION_BOTTOM, CANVAS_POSITION_TOP],
                            pos,
                            start = translate(startV),
                            end = translate(endV),
                            min = isHorizontal ? range.minVisibleX : range.maxVisibleY,
                            max = isHorizontal ? range.maxVisibleX : range.maxVisibleY;
                        invert && defaultPos.reverse();
                        if (!isContinous && ($.inArray(startV, cateories) === -1 || $.inArray(endV, cateories) === -1))
                            return {
                                    stripFrom: 0,
                                    stripTo: 0
                                };
                        if (!utils.isDefined(start) && isContinous)
                            start = startV < min ? translate(defaultPos[0]) : translate(defaultPos[1]);
                        if (!utils.isDefined(end) && isContinous)
                            end = endV < min ? translate(defaultPos[0]) : translate(defaultPos[1]);
                        return start < end ? {
                                stripFrom: start,
                                stripTo: end
                            } : {
                                stripFrom: end,
                                stripTo: start
                            }
                    };
                if (self.options.isHorizontal) {
                    positionFrom = translator.translateY(CANVAS_POSITION_BOTTOM);
                    positionTo = translator.translateY(CANVAS_POSITION_TOP);
                    for (i = 0; i < stripData.length; i++) {
                        stripOptions = stripData[i];
                        if (stripOptions.startValue !== undefined && stripOptions.endValue !== undefined && stripOptions.color !== undefined) {
                            stripPos = getPos(stripOptions.startValue, stripOptions.endValue, true, translator.businessRange);
                            if (stripPos.stripTo - stripPos.stripFrom === 0)
                                continue;
                            rect = renderer.createRect(stripPos.stripFrom, positionTo, stripPos.stripTo - stripPos.stripFrom, positionFrom - positionTo, 0, {fill: stripOptions.color});
                            rect.append(group);
                            stripRects.push(rect);
                            if (stripOptions.label && stripOptions.label.text)
                                stripLabels.push(drawStripLabel(self, stripOptions.label, stripPos.stripFrom, stripPos.stripTo, group));
                            else
                                stripLabels.push(null)
                        }
                    }
                }
                else {
                    positionFrom = translator.translateX(CANVAS_POSITION_LEFT);
                    positionTo = translator.translateX(CANVAS_POSITION_RIGHT);
                    for (i = 0; i < stripData.length; i++) {
                        stripOptions = stripData[i];
                        if (stripOptions.startValue !== undefined && stripOptions.endValue !== undefined && stripOptions.color !== undefined) {
                            stripPos = getPos(stripOptions.startValue, stripOptions.endValue, false, translator.businessRange);
                            if (stripPos.stripTo - stripPos.stripFrom === 0)
                                continue;
                            rect = renderer.createRect(positionFrom, stripPos.stripFrom, positionTo - positionFrom, stripPos.stripTo - stripPos.stripFrom, 0, {fill: stripOptions.color});
                            rect.append(group);
                            stripRects.push(rect);
                            if (stripOptions.label && stripOptions.label.text)
                                stripLabels.push(drawStripLabel(self, stripOptions.label, stripPos.stripFrom, stripPos.stripTo, group));
                            else
                                stripLabels.push(null)
                        }
                    }
                }
                self.stripLabels = stripLabels;
                self.stripRects = stripRects
            };
        var drawStripLabel = function drawStripLabel(self, labelOptions, stripFrom, stripTo, group) {
                var renderer = self.renderer,
                    text = labelOptions.text,
                    canvas = self.translator.canvas,
                    attr = {
                        align: self.options.isHorizontal ? 'center' : 'left',
                        font: labelOptions.font || self.options.label.font
                    },
                    label,
                    x,
                    y;
                if (self.options.isHorizontal) {
                    if (labelOptions.horizontalAlignment === 'center') {
                        x = stripFrom + (stripTo - stripFrom) / 2;
                        attr.align = 'center'
                    }
                    else if (labelOptions.horizontalAlignment === 'left') {
                        x = stripFrom;
                        attr.align = 'left'
                    }
                    else if (labelOptions.horizontalAlignment === 'right') {
                        x = stripTo;
                        attr.align = 'right'
                    }
                    if (labelOptions.verticalAlignment === 'top')
                        y = canvas.top;
                    else if (labelOptions.verticalAlignment === 'center')
                        y = (canvas.height - canvas.top - canvas.bottom) / 2 + canvas.top;
                    else if (labelOptions.verticalAlignment === 'bottom')
                        y = canvas.height - canvas.bottom
                }
                else {
                    if (labelOptions.horizontalAlignment === 'center') {
                        x = (canvas.width - canvas.left - canvas.right) / 2 + canvas.left;
                        attr.align = 'center'
                    }
                    else if (labelOptions.horizontalAlignment === 'left') {
                        x = canvas.left;
                        attr.align = 'left'
                    }
                    else if (labelOptions.horizontalAlignment === 'right') {
                        x = canvas.width - canvas.right;
                        attr.align = 'right'
                    }
                    if (labelOptions.verticalAlignment === 'top')
                        y = stripFrom;
                    else if (labelOptions.verticalAlignment === 'center')
                        y = stripTo + (stripFrom - stripTo) / 2;
                    else if (labelOptions.verticalAlignment === 'bottom')
                        y = stripTo
                }
                label = renderer.createText(text, x, y, attr);
                label.append(group);
                return label
            };
        var initAxisPositions = function(self) {
                if (self.options.isHorizontal)
                    self.axisPosition = getYAxisPosition(self);
                else
                    self.axisPosition = getXAxisPosition(self)
            };
        var checkNeedsLabelAdjustment = function(self, labels) {
                var i,
                    labelOptions = self.options.label,
                    boxLeft,
                    boxRight,
                    labelLeft,
                    labelRight,
                    needsLabelAdjustment = !!self.staggered;
                labels = self.options.inverted ? labels.slice(0).reverse() : labels;
                if (!self.options.isHorizontal)
                    needsLabelAdjustment = false;
                else if (labelOptions.overlappingBehavior && labelOptions.overlappingBehavior.mode === 'stagger')
                    for (i = 1; i < labels.length; i++) {
                        labelLeft = labels[i - 1];
                        labelRight = labels[i];
                        boxLeft = labelLeft.getBBox();
                        boxRight = labelRight.getBBox();
                        if (boxRight.x < boxLeft.x + boxLeft.width + AXIS_LABEL_SPACING) {
                            self.isStaggerOverlapping = true;
                            needsLabelAdjustment = true
                        }
                    }
                self.needsLabelAdjustment = self.needsLabelAdjustment || needsLabelAdjustment;
                return self.needsLabelAdjustment
            };
        var adjustLabels = function(self) {
                var options = self.options,
                    labels = self.labels,
                    labelOptions = options.label,
                    label,
                    labelHeight,
                    isNeedLabelAdjustment,
                    staggeringSpacing,
                    i,
                    box;
                if (!options.label.visible || !labels || !labels.length)
                    return;
                for (i = 0; i < labels.length; i++) {
                    label = labels[i];
                    box = label.getBBox();
                    if (options.isHorizontal && options.position === 'bottom')
                        label.applySettings({y: 2 * label.settings.y - box.y});
                    else if (!options.isHorizontal && (options.position === 'left' || options.position === 'right'))
                        label.applySettings({y: label.settings.y + ~~(label.settings.y - box.y - box.height / 2)});
                    else if (options.isHorizontal && options.position === 'top')
                        label.applySettings({y: 2 * label.settings.y - box.y - box.height})
                }
                isNeedLabelAdjustment = checkNeedsLabelAdjustment(self, labels);
                self._testIsNeedLabelAdjustment = isNeedLabelAdjustment;
                if (isNeedLabelAdjustment) {
                    labelHeight = 0;
                    for (i = 0; i < labels.length; i = i + 2) {
                        label = labels[i];
                        box = label.getBBox();
                        if (box.height > labelHeight)
                            labelHeight = box.height
                    }
                    staggeringSpacing = self.getStaggeringSpacing(self);
                    self._testStaggeringSpacing = staggeringSpacing;
                    labelHeight = math.round(labelHeight) + staggeringSpacing;
                    for (i = 1; i < labels.length; i = i + 2) {
                        label = labels[i];
                        if (options.position === 'bottom')
                            label.move(0, labelHeight);
                        else if (options.position === 'top')
                            label.move(0, -labelHeight)
                    }
                    for (i = 0; i < labels.length; i++)
                        labels[i].rotate(0)
                }
            };
        var adjustStripLabels = function(self) {
                var options = self.options,
                    labelOptions,
                    labels = self.stripLabels,
                    rects = self.stripRects,
                    rect,
                    label,
                    i,
                    box,
                    rectBox,
                    stripOptions,
                    x,
                    y;
                if (labels === undefined && rects === undefined)
                    return;
                for (i = 0; i < labels.length; i++) {
                    x = y = 0;
                    stripOptions = options.strips[i];
                    labelOptions = stripOptions.label;
                    label = labels[i];
                    if (label !== null) {
                        rect = rects[i];
                        box = label.getBBox();
                        rectBox = rect.getBBox();
                        if (labelOptions.horizontalAlignment === 'left')
                            x += stripOptions.paddingLeftRight;
                        else if (labelOptions.horizontalAlignment === 'right')
                            x -= stripOptions.paddingLeftRight;
                        if (labelOptions.verticalAlignment === 'top')
                            y += rectBox.y - box.y + stripOptions.paddingTopBottom;
                        else if (labelOptions.verticalAlignment === 'center')
                            y += rectBox.y + rectBox.height / 2 - box.y - box.height / 2;
                        else if (labelOptions.verticalAlignment === 'bottom')
                            y -= stripOptions.paddingTopBottom;
                        label.move(x, y)
                    }
                }
            };
        var adjustTitle = function(self, group) {
                var options = self.options,
                    axisPosition = self.axisPosition,
                    boxGroup,
                    boxTitle,
                    title = self.title;
                if (!title)
                    return;
                boxTitle = title.getBBox();
                boxGroup = group.getBBox();
                if (self.options.isHorizontal)
                    if (self.options.position === 'bottom')
                        title.move(0, boxGroup.y + boxGroup.height - boxTitle.y + options.title.margin);
                    else
                        title.move(0, boxGroup.y - boxTitle.y - boxTitle.height - options.title.margin);
                else if (self.options.position === 'left')
                    title.move(boxGroup.x - boxTitle.x - boxTitle.width - options.title.margin, 0);
                else
                    title.move(boxGroup.x + boxGroup.width - boxTitle.x + options.title.margin, 0)
            };
        var draw = function(externalOptions) {
                var self = this,
                    cssClass = self.options.isHorizontal ? 'h-axis' : 'v-axis',
                    stripClass = self.options.isHorizontal ? 'h-strips' : 'v-strips',
                    axisClipRectID = self.clipRectID && self.options.placeholderSize ? self.clipRectID : undefined,
                    axisGroup = self.axisGroup = self.axisGroup || self.renderer.createGroup({
                        'class': cssClass,
                        clipId: axisClipRectID
                    }),
                    axisStripGroup = self.axisStripGroup = self.axisStripGroup || self.renderer.createGroup({'class': stripClass}),
                    axisGridGroup = self.renderer.createGroup({'class': 'axis-grid'}),
                    axisElementsGroup = self.renderer.createGroup({'class': 'axis-elements'}),
                    axisLineGroup = self.renderer.createGroup({'class': 'axis-line'});
                externalOptions = externalOptions || {};
                var debug = DX.utils.debug;
                debug.assertParam(self.translator, 'translator was not set before Draw call');
                axisGroup.clear();
                axisStripGroup.clear();
                axisGroup.detach();
                axisStripGroup.detach();
                initAxisPositions(self);
                if (!self._virtual) {
                    drawAxis(self, axisLineGroup);
                    drawTicks(self, axisLineGroup);
                    drawLabels(self, axisElementsGroup);
                    if (self.options.title.text)
                        drawTitle(self, axisElementsGroup)
                }
                if (self.options.strips)
                    drawStrip(self, axisStripGroup);
                drawGrid(self, axisGridGroup, externalOptions.borderOptions);
                axisElementsGroup.append(axisGroup);
                axisGridGroup.append(axisGroup);
                axisLineGroup.append(axisGroup);
                axisStripGroup.append(self.stripsGroup);
                axisGroup.append();
                adjustLabels(self);
                adjustStripLabels(self);
                adjustTitle(self, axisElementsGroup);
                self.axisElementsGroup = axisElementsGroup;
                self.axisGroup = axisGroup;
                self.axisLineGroup = axisLineGroup;
                self.axisStripGroup = axisStripGroup
            };
        var getBoundingRect = function() {
                var box = this.axisElementsGroup.getBBox(),
                    lineBox = this.axisLineGroup.getBBox(),
                    placeholderSize = this.options.placeholderSize,
                    start,
                    isHorizontal = this.options.isHorizontal,
                    coord = isHorizontal && 'y' || 'x',
                    side = isHorizontal && 'height' || 'width',
                    positionCondition = this.options.position === (isHorizontal && 'bottom' || 'right');
                if (!(box.x || box.y || box.width || box.height))
                    return box;
                start = lineBox[coord] || this.axisPosition;
                if (positionCondition) {
                    box[side] = placeholderSize || box[side] - (start - box[coord]);
                    box[coord] = start
                }
                else
                    box[side] = placeholderSize || lineBox[side] + start - box[coord];
                return box
            };
        var shift = function(x, y) {
                var self = this,
                    settings = {};
                if (x)
                    settings.translateX = x;
                if (y)
                    settings.translateY = y;
                self.axisGroup.applySettings(settings)
            };
        var getRangeData = function() {
                var self = this,
                    options = self.options,
                    range = {};
                var addValueMarginToRange = function(prefix, dim) {
                        if (options['valueMarginsEnabled']) {
                            if (utils.isDefined(options[prefix])) {
                                range[prefix + dim] = options[prefix];
                                range[prefix + dim + 'Priority'] = AXIS_VALUE_MARGIN_PRIORITY
                            }
                        }
                        else {
                            range[prefix + dim] = 0;
                            range[prefix + dim + 'Priority'] = AXIS_VALUE_MARGIN_PRIORITY
                        }
                    };
                if (options.isHorizontal) {
                    range.minX = options.range.min;
                    range.maxX = options.range.max;
                    range.minVisibleX = options.range.min;
                    range.maxVisibleX = options.range.max;
                    addValueMarginToRange('minValueMargin', 'X');
                    addValueMarginToRange('maxValueMargin', 'X');
                    range.invertX = options.inverted;
                    range.stickX = !options.valueMarginsEnabled;
                    range.categoriesX = options.range.categories
                }
                else {
                    range.minY = options.range.min;
                    range.maxY = options.range.max;
                    range.minVisibleY = options.range.min;
                    range.maxVisibleY = options.range.max;
                    range.invertY = options.inverted;
                    range.stickY = !options.valueMarginsEnabled;
                    addValueMarginToRange('minValueMargin', 'Y');
                    addValueMarginToRange('maxValueMargin', 'Y');
                    range.categoriesY = options.range.categories
                }
                return range
            };
        var on = function(events, data, handler) {
                $(this).on(events, data, handler);
                return this
            };
        var off = function(events) {
                $(this).off(events);
                return this
            };
        var prototypeObject = {
                ctor: ctor,
                init: init,
                resetTicks: resetTicks,
                getStaggeringSpacing: getStaggeringSpacing,
                setTranslator: setTranslator,
                getTickValues: getTickValues,
                setTickValues: setTickValues,
                getRangeData: getRangeData,
                getMultipleAxesSpacing: getMultipleAxesSpacing,
                setRange: setRange,
                setPercentLabelFormat: setPercentLabelFormat,
                draw: draw,
                getBoundingRect: getBoundingRect,
                shift: shift,
                on: on,
                off: off
            };
        prototypeObject.getTicksOptions = getTicksOptions;
        prototypeObject.drawAxis = drawAxis;
        prototypeObject.drawTicks = drawTicks;
        prototypeObject.drawGrid = drawGrid;
        prototypeObject.drawStrip = drawStrip;
        prototypeObject.drawLabels = drawLabels;
        prototypeObject.adjustLabels = adjustLabels;
        prototypeObject.adjustStripLabels = adjustStripLabels;
        prototypeObject.drawTitle = drawTitle;
        prototypeObject.adjustTitle = adjustTitle;
        prototypeObject.checkNeedsLabelAdjustment = checkNeedsLabelAdjustment;
        prototypeObject.initAxisPositions = initAxisPositions;
        return prototypeObject
    }())
})(jQuery, DevExpress);

// Module viz, file baseChart.js

(function($, DX, undefined) {
    var ui = DX.ui,
        Component = ui.Component,
        charts = DX.viz.charts,
        utils = DX.utils;
    var REDRAW_DELAY = 100;
    var resizeRedrawOptions = {animate: false};
    charts.BaseChart = Component.inherit({
        _defaultOptions: function() {
            return {
                    done: $.noop,
                    redrawOnResize: true,
                    incidentOccured: $.noop,
                    margin: {
                        left: 0,
                        top: 0,
                        right: 0,
                        bottom: 0
                    },
                    size: {
                        width: undefined,
                        height: undefined
                    },
                    title: {text: null},
                    legend: {hoverMode: 'includePoints'},
                    animation: {
                        enabled: true,
                        duration: 1000,
                        easing: 'easeOutCubic',
                        maxPointCountSupported: 1000,
                        asyncSeriesRendering: false
                    },
                    seriesSelectionMode: 'single',
                    pointSelectionMode: 'single',
                    seriesClick: $.noop,
                    pointClick: $.noop,
                    argumentAxisClick: $.noop,
                    seriesHover: $.noop,
                    pointHover: $.noop,
                    seriesSelected: $.noop,
                    pointSelected: $.noop
                }
        },
        _init: function() {
            var self = this;
            self.tooltip = {};
            self.layoutManager = self._createLayoutManager();
            self._saveUserCanvas();
            self._initRenderer();
            if (self.option('redrawOnResize') && window)
                utils.windowResizeCallbacks.add(self._resizeHandler());
            if (!$.isFunction(self.option('incidentOccured'))) {
                utils.debug.assert(false, 'Function should be passed as "incidentOccured" callback');
                self.option('incidentOccured', $.noop)
            }
            if (self.option('incidentOccured') === $.noop)
                self.option('incidentOccured', utils.logger.warn);
            self._reinitDataSource()
        },
        destroy: function destroy() {
            var self = this,
                element = self.rootElement();
            if (self.destroyed)
                return;
            self._dispose();
            self._render = $.noop;
            if (element.data(self.NAME))
                element.data(self.NAME, null);
            self.destroyed = true
        },
        _clean: function _clean() {
            var container = this.rootElement();
            container.empty();
            this._saveDirtyCanvas()
        },
        dispose: function dispose() {
            this._dispose()
        },
        _initRenderer: function _initRenderer() {
            this.renderer = this.renderer || this.createRenderer()
        },
        _initSeries: function() {
            this.series = this.series || this._populateSeries()
        },
        _reinitDataSource: function() {
            this._initDataSource();
            this._loadDataSource()
        },
        _initOptions: function(options) {
            var self = this,
                changedTitle;
            if (options.commonSeriesSettings && options.commonSeriesSettings.type && !utils.isString(options.commonSeriesSettings.type))
                options.commonSeriesSettings.type = '';
            options.userCommonSeriesSettings = options.commonSeriesSettings;
            changedTitle = this._processTitleOption(options.title, this.option('title'));
            if (changedTitle)
                options.title = changedTitle;
            this._processAxesOption(options);
            self.themeManager = self._createThemeManager(options);
            self.option(self.themeManager.applyChartTheme(options))
        },
        _processTitleOption: function(title, oldTitle) {
            if (utils.isString(title)) {
                var text = title;
                title = oldTitle;
                title.text = text;
                return title
            }
        },
        _processAxesOption: function(options) {
            var argumentAxesOptions = $.isArray(options.argumentAxis) ? options.argumentAxis : [options.argumentAxis],
                valueAxesOptions = $.isArray(options.valueAxis) ? options.valueAxis : [options.valueAxis],
                checkOptions = function(axesOptions) {
                    var axisOptions,
                        text,
                        i = 0;
                    for (i = 0; i < axesOptions.length; i++) {
                        axisOptions = axesOptions[i];
                        if (axisOptions && axisOptions.title)
                            if (utils.isString(axisOptions.title)) {
                                text = axisOptions.title;
                                axisOptions.title = {};
                                axisOptions.title.text = text
                            }
                        if (axisOptions && axisOptions.label) {
                            if (axisOptions.label.alignment)
                                axisOptions.label['userAlignment'] = true;
                            if (utils.isString(axisOptions.label.overlappingBehavior))
                                axisOptions.label.overlappingBehavior = {mode: axisOptions.label.overlappingBehavior};
                            if (!axisOptions.label.overlappingBehavior || !axisOptions.label.overlappingBehavior.mode) {
                                axisOptions.label.overlappingBehavior = axisOptions.label.overlappingBehavior || {};
                                if (axisOptions.label.rotationAngle) {
                                    axisOptions.label.overlappingBehavior.mode = 'rotate';
                                    if (!axisOptions.label.overlappingBehavior.rotationAngle)
                                        axisOptions.label.overlappingBehavior.rotationAngle = axisOptions.label.rotationAngle
                                }
                                if (axisOptions.label.staggered) {
                                    axisOptions.label.overlappingBehavior.mode = 'stagger';
                                    if (!axisOptions.label.overlappingBehavior.staggeringSpacing)
                                        axisOptions.label.overlappingBehavior.staggeringSpacing = axisOptions.label.staggeringSpacing
                                }
                            }
                        }
                    }
                };
            options.userCommonAxisSettings = options.commonAxisSettings;
            checkOptions([options.commonAxisSettings]);
            checkOptions(argumentAxesOptions);
            checkOptions(valueAxesOptions)
        },
        _saveUserCanvas: function() {
            var canvas = this.option('size');
            if (canvas.width)
                canvas.userWidth = canvas.width;
            if (canvas.height)
                canvas.userHeight = canvas.height
        },
        _saveDirtyCanvas: function() {
            this.dirtyCanvas = this._calculateCanvas()
        },
        _resizeHandler: function() {
            var chart = this,
                jqWindow = $(window),
                currentDelayTimeout,
                formatSize = function() {
                    return [jqWindow.width(), jqWindow.height()].join()
                };
            return function() {
                    var prevSize = formatSize(),
                        currentSize;
                    if (currentDelayTimeout) {
                        clearTimeout(currentDelayTimeout);
                        currentDelayTimeout = 0
                    }
                    currentDelayTimeout = setTimeout(function() {
                        currentSize = formatSize();
                        if (currentSize === prevSize)
                            chart._render(resizeRedrawOptions)
                    }, REDRAW_DELAY)
                }
        },
        createRenderer: function() {
            var animationOptions = this.option('animation');
            return charts.factory.createRenderer({animation: animationOptions})
        },
        _createThemeManager: function(options) {
            options = options || {};
            return charts.factory.createThemeManager({
                    theme: options.theme,
                    palette: options.palette
                })
        },
        _calculateCanvas: function() {
            var canvas = this.option('size'),
                container = this.rootElement();
            if (!utils.isDefined(canvas.userWidth))
                canvas.width = container.width();
            if (!utils.isDefined(canvas.userHeight))
                canvas.height = container.height();
            return $.extend({}, canvas, this.option('margin'))
        },
        _createLayoutManager: function() {
            return new charts.factory.createChartLayoutManager(this)
        },
        _processTracker: function() {
            var container = this.rootElement(),
                events = this.option('events'),
                rotated = this.option('rotated');
            this.tracker = new charts.Tracker({
                container: container,
                series: this.series,
                valueAxis: rotated ? this.horizontalAxes : this.verticalAxes,
                argumentAxis: rotated ? this.verticalAxes : this.horizontalAxes,
                seriesSelectionMode: this.option('seriesSelectionMode'),
                pointSelectionMode: this.option('pointSelectionMode'),
                events: {
                    seriesClick: this.option('seriesClick'),
                    pointClick: this.option('pointClick'),
                    argumentAxisClick: this.option('argumentAxisClick'),
                    seriesHover: this.option('seriesHover'),
                    seriesSelected: this.option('seriesSelected'),
                    pointHover: this.option('pointHover'),
                    pointSelected: this.option('pointSelected')
                }
            })
        },
        _render: function(drawOptions) {
            var self = this,
                renderer = self.renderer,
                translators = self.translators,
                layoutManager = self.layoutManager,
                updatedCanvas = self.canvas,
                container = self.rootElement(),
                currentDirtyCanvas = self._calculateCanvas(),
                oldDirtyCanvas = self.dirtyCanvas;
            drawOptions = drawOptions || {recreateCanvas: true};
            drawOptions.recreateCanvas = drawOptions.recreateCanvas || !renderer.isInitialized();
            if (!drawOptions.force && oldDirtyCanvas && oldDirtyCanvas.width === currentDirtyCanvas.width && oldDirtyCanvas.height === currentDirtyCanvas.height) {
                self.stopRedraw = true;
                return
            }
            if (drawOptions.recreateCanvas) {
                renderer.killContainer();
                updatedCanvas = self._calculateCanvas()
            }
            if (updatedCanvas.width && updatedCanvas.height && container.is(':visible'))
                self.hiddenContainer = false;
            else {
                self.option('incidentOccured')('Chart can not be drawn as container is not visible');
                self.hiddenContainer = true;
                self.stopRedraw = true;
                return
            }
            if (drawOptions.recreateCanvas) {
                self.canvas = updatedCanvas;
                renderer.recreateCanvas(self.canvas.width, self.canvas.height);
                self.renderer.draw(self.rootElement()[0]);
                self._createCanvasClipRect();
                if (translators)
                    translators.length = 0
            }
            layoutManager.init();
            self.seriesGroup.clear();
            self.seriesTrackerGroup.clear();
            self.markerTrackerGroup.clear();
            self.trackerGroup.clear();
            self.seriesLabelsGroup.clear();
            self._saveDirtyCanvas()
        },
        _drawTitle: function() {
            var self = this,
                titleOptions = self.option('title'),
                renderer = self.renderer;
            self.chartTitle = new charts.ChartTitle(renderer, self.canvas, titleOptions);
            self.chartTitle.render()
        },
        _createTooltip: function() {
            var self = this,
                tooltipOptions = self.option('tooltip') || {};
            if (!tooltipOptions.enabled)
                return;
            tooltipOptions = $.extend(true, {
                renderer: self.renderer,
                canvasWidth: self.canvas.width
            }, tooltipOptions);
            if (!$.isFunction(tooltipOptions.customizeText) && utils.isDefined(tooltipOptions.customizeText)) {
                self.option('incidentOccured').call(null, 'customizeText can not be applied as it is not a function');
                tooltipOptions.customizeText = undefined
            }
            self.tooltip = charts.factory.createTooltip(tooltipOptions);
            self.tooltip.draw();
            self.tracker.tooltip = self.tooltip
        },
        _prepareDrawOptions: function(drawOptions) {
            var animationOptions = this.option('animation'),
                options = $.extend({}, {
                    force: false,
                    adjustAxes: true,
                    drawLegend: true,
                    drawTitle: true,
                    adjustSeriesLabels: true,
                    animate: animationOptions.enabled,
                    animationPointsLimit: animationOptions.maxPointCountSupported,
                    asyncSeriesRendering: animationOptions.asyncSeriesRendering
                }, drawOptions);
            if (!utils.isDefined(options.recreateCanvas))
                options.recreateCanvas = !(!options.adjustAxes || !options.drawLegend || !options.drawTitle);
            return options
        },
        _optionChanged: function(name, value, prevValue) {
            var changedTitle;
            if (name === 'dataSource')
                this._reinitDataSource();
            else if (name === 'series') {
                this.series = this._populateSeries();
                this._handleDataSourceChanged()
            }
            else if (name === 'commonSeriesSettings') {
                this.option('userCommonSeriesSettings', value);
                this.series = this._populateSeries()
            }
            else if (name === 'commonAxisSettings')
                this.option('userCommonAxisSettings', value);
            else if (name === 'panes' || name === 'valueAxis') {
                this._panesChanged = true;
                this._needInit = true;
                this.callBase.apply(this, arguments)
            }
            else if (name === 'title') {
                changedTitle = this._processTitleOption(value, prevValue);
                if (changedTitle) {
                    this.option('title', prevValue);
                    return
                }
                this.callBase.apply(this, arguments)
            }
            else {
                this._needInit = true;
                this.callBase.apply(this, arguments)
            }
        },
        _refresh: function() {
            this._needInit && this._init();
            this._needInit = false;
            this._clean();
            this._render({force: true})
        },
        _dataSourceOptions: function() {
            return {paginate: false}
        },
        _createCanvasClipRect: function() {
            var self = this,
                renderer = self.renderer,
                rect,
                canvas = self.canvas;
            rect = renderer.createClipRect(canvas.left, canvas.top, canvas.width - canvas.left - canvas.right, canvas.height - canvas.top - canvas.bottom);
            self.canvasClipRectID = rect.id
        },
        _getCanvasClipRectID: function() {
            return this.canvasClipRectID
        },
        _handleDataSourceChanged: function() {
            this._dataSpecificInit(true)
        },
        _dataSpecificInit: function(needRedraw) {
            this._seriesInitializing = true;
            this._initSeries();
            this._repopulateSeries(needRedraw)
        },
        _processSeriesTemplate: function(needRedraw) {
            var self = this,
                seriesTemplate = this.option('seriesTemplate'),
                customizeSeries = utils.isFunction(seriesTemplate.customizeSeries) ? seriesTemplate.customizeSeries : $.noop,
                nameField = seriesTemplate.nameField || 'series',
                dataSource = this._dataSource.store().toDataSource({group: nameField});
            if (!dataSource)
                return;
            dataSource.load().done(function() {
                self._templatedSeries = $.map(dataSource.items(), function(group) {
                    var seriesOptions = customizeSeries.call(null, group.key);
                    return $.extend({
                            name: group.key,
                            data: group.items
                        }, seriesOptions)
                });
                self._populateSeries();
                delete self._templatedSeries;
                self._handleSeriesPopulated(needRedraw)
            })
        },
        getAllSeries: function getAllSeries() {
            var series = [];
            $.each(this.series, function(i, singleSeries) {
                series.push(singleSeries)
            });
            return series
        },
        getSeriesByName: function getSeriesByName(name) {
            var found = null;
            $.each(this.series, function(i, singleSeries) {
                if (singleSeries.name === name) {
                    found = singleSeries;
                    return false
                }
            });
            return found
        },
        getSeriesByPos: function getSeriesByPos(pos) {
            return this.series[pos]
        },
        getSelectedSeries: function getSelectedSeries() {
            return null
        },
        clearSelection: function clearSelection() {
            this.tracker.clearSelection()
        }
    }).include(ui.DataHelperMixin)
})(jQuery, DevExpress);

// Module viz, file chart.js

(function($, DX, undefined) {
    var charts = DX.viz.charts,
        utils = DX.utils,
        MAX_ADJUSTMENT_ATTEMPTS = 5,
        DEFAULT_PANE_NAME = 'default',
        DEFAULT_AXIS_NAME = 'defaultAxisName',
        DEFAULT_BUSINESS_RANGE_VALUE_MARGIN = 0.1,
        PANE_CLIP_RECT_PADDING = 12;
    charts.Chart = charts.BaseChart.inherit({
        _defaultOptions: function() {
            return $.extend(true, this.callBase(), {
                    commonSeriesSettings: {
                        type: 'line',
                        maxLabelCount: undefined,
                        pane: DEFAULT_PANE_NAME,
                        stack: 'default',
                        label: {
                            visible: false,
                            alignment: 'center',
                            rotationAngle: 0,
                            horizontalOffset: 0,
                            verticalOffset: 0,
                            radialOffset: 0,
                            format: '',
                            argumentFormat: '',
                            precision: 0,
                            argumentPrecision: 0,
                            percentPrecision: 0,
                            customizeText: undefined,
                            position: 'outside',
                            connector: {
                                visible: false,
                                width: 0
                            }
                        }
                    },
                    defaultPane: DEFAULT_PANE_NAME,
                    adjustOnZoom: true,
                    rotated: false,
                    synchronizeMultiAxes: true,
                    equalBarWidth: true,
                    commonPaneSettings: {
                        backgroundColor: 'none',
                        border: {
                            visible: false,
                            top: true,
                            bottom: true,
                            left: true,
                            right: true,
                            dashStyle: 'solid'
                        }
                    },
                    panes: [{
                            name: DEFAULT_PANE_NAME,
                            border: {}
                        }],
                    commonAxisSettings: {
                        tickInterval: undefined,
                        setTicksAtUnitBeginning: true,
                        valueMarginsEnabled: true,
                        placeholderSize: null
                    }
                })
        },
        _init: function() {
            this.paneAxis = this.paneAxis || {};
            if (this._panesChanged) {
                delete this.series;
                this.paneAxis = {}
            }
            delete this._panesChanges;
            this.translators = [];
            this.panes = this._createPanes();
            this._initRenderer();
            this._populateAxes();
            this.callBase();
            delete this._seriesInitializing;
            if (!this.series)
                this._dataSpecificInit();
            else
                this._correctValueAxes()
        },
        _populateBusinessRange: function(visibleArea) {
            var self = this,
                panes = self.panes,
                businessRanges = [],
                range,
                i,
                rotated = self.option('rotated'),
                singleSeriesRange,
                valAxes = rotated ? self.horizontalAxes : self.verticalAxes,
                argAxes = rotated ? self.verticalAxes : self.horizontalAxes,
                valueField = rotated && 'X' || 'Y',
                argumentField = rotated && 'Y' || 'X',
                valueBoundRange = 'getBoundRange' + valueField,
                argumentBoundRange = 'getBoundRange' + argumentField,
                businessLength,
                paneList = $.map(panes, function(pane) {
                    return pane.name
                }),
                series = self.series;
            var hideGridsOnNonFirstValueAxisForPane = function(paneName) {
                    var axesForPane = [];
                    $.each(valAxes, function(_, axis) {
                        if (axis.pane === paneName)
                            axesForPane.push(axis)
                    });
                    if (axesForPane.length > 1)
                        for (i = 1; i < axesForPane.length; i++) {
                            var gridOpt = axesForPane[i].options.grid;
                            if (gridOpt && gridOpt.visible)
                                gridOpt.visible = false
                        }
                };
            var paneAxis = self.paneAxis;
            var argRange = new charts.Range;
            var getFirstAxisNameForPane = function(axes, paneName) {
                    var result;
                    for (var i = 0; i < axes.length; i++)
                        if (axes[i].pane === paneName) {
                            result = axes[i].name;
                            break
                        }
                    if (!result)
                        result = valAxes[0].name;
                    return result
                };
            $.each(series, function(i, particularSeries) {
                particularSeries.axis = particularSeries.axis || getFirstAxisNameForPane(valAxes, particularSeries.pane);
                if (particularSeries.axis) {
                    paneAxis[particularSeries.pane] = paneAxis[particularSeries.pane] || {};
                    paneAxis[particularSeries.pane][particularSeries.axis] = true
                }
            });
            $.each(valAxes, function(_, axis) {
                if (axis.name && axis.pane && $.inArray(axis.pane, paneList) != -1) {
                    paneAxis[axis.pane] = paneAxis[axis.pane] || {};
                    paneAxis[axis.pane][axis.name] = true
                }
            });
            self._correctValueAxes();
            $.each(paneAxis, function(paneName, pane) {
                hideGridsOnNonFirstValueAxisForPane(paneName);
                $.each(pane, function(axisName, _) {
                    var seriesForRange = [],
                        valueAxesForRange = [],
                        argumentAxesForRange = [];
                    var valRange = new charts.Range({
                            pane: paneName,
                            axis: axisName,
                            minValueMarginX: DEFAULT_BUSINESS_RANGE_VALUE_MARGIN,
                            maxValueMarginX: DEFAULT_BUSINESS_RANGE_VALUE_MARGIN,
                            minValueMarginY: DEFAULT_BUSINESS_RANGE_VALUE_MARGIN,
                            maxValueMarginY: DEFAULT_BUSINESS_RANGE_VALUE_MARGIN
                        });
                    $.each(series, function(_, particularSeries) {
                        if (particularSeries.pane === paneName && particularSeries.axis === axisName)
                            seriesForRange.push(particularSeries)
                    });
                    $.each(argAxes, function(_, axis) {
                        argumentAxesForRange.push(axis)
                    });
                    $.each(valAxes, function(_, axis) {
                        if (axis.pane === paneName && axis.name === axisName)
                            valueAxesForRange.push(axis)
                    });
                    $.each(argumentAxesForRange, function(_, axis) {
                        argRange = argRange[argumentBoundRange](axis.getRangeData())
                    });
                    $.each(valueAxesForRange, function(_, axis) {
                        valRange = valRange[valueBoundRange](axis.getRangeData())
                    });
                    for (i = 0; i < seriesForRange.length; i++) {
                        singleSeriesRange = seriesForRange[i].getRangeData(visibleArea);
                        valRange = valRange[valueBoundRange](singleSeriesRange);
                        argRange = argRange[argumentBoundRange](singleSeriesRange)
                    }
                    if (!valRange['isDefined' + valueField]())
                        valRange['setStubData' + valueField]();
                    businessRanges.push(valRange)
                })
            });
            if (!argRange['isDefined' + argumentField]())
                argRange['setStubData' + argumentField]();
            $.each(businessRanges, function(_, range) {
                range = range.getBoundRange(argRange);
                range.applyValueMargins();
                range['stubData' + argumentField] = argRange['stubData' + argumentField];
                if (!range.isDefined())
                    range.setStubData()
            });
            self.businessRanges = businessRanges
        },
        _createPanes: function() {
            var self = this,
                panes = self.option('panes'),
                bottomPaneName;
            self.defaultPane = self.option('defaultPane');
            if (!self._doesPaneExists(panes, self.defaultPane) && panes.length > 0) {
                bottomPaneName = panes[panes.length - 1].name;
                self.option('incidentOccured')('Pane "' + self.defaultPane + '" does not exist. Use pane "' + bottomPaneName + '" instead');
                self.defaultPane = bottomPaneName
            }
            if (self.option('rotated'))
                panes = panes.reverse();
            return panes
        },
        _doesPaneExists: function(panes, paneName) {
            var found = false;
            $.each(panes, function(_, pane) {
                if (pane.name === paneName) {
                    found = true;
                    return false
                }
            });
            return found
        },
        _populateSeries: function() {
            var self = this,
                hasSeriesTemplate = !!self.option('seriesTemplate'),
                series = hasSeriesTemplate ? self._templatedSeries : self.option('series'),
                allSeriesOptions = $.isArray(series) ? series : series ? [series] : [],
                argumentAxisOptions = self.option('argumentAxis'),
                valueAxisOptions = self.option('valueAxis'),
                themeManager = self.themeManager,
                data,
                particularSeriesOptions,
                commonSeriesSettings = self.option('commonSeriesSettings'),
                userCommonSeriesSettings = self.option('userCommonSeriesSettings'),
                particularSeries,
                seriesGroup = self.renderer.createGroup({'class': 'series'}),
                seriesLabelsGroup = self.renderer.createGroup({'class': 'labels'}),
                trackerGroup = self.renderer.createGroup({'class': 'tracker'}),
                seriesTrackerGroup = self.renderer.createGroup({'class': 'seriesTracker'}),
                markerTrackerGroup = self.renderer.createGroup({'class': 'markerTracker'}),
                rotated = self.option('rotated'),
                incidentOccured = self.option('incidentOccured'),
                i,
                paneList = $.map(self.panes, function(pane) {
                    return pane.name
                }),
                paneName;
            this.series = [];
            themeManager.resetPalette();
            commonSeriesSettings.containerBackgroundColor = self.option('containerBackgroundColor');
            for (i = 0; i < allSeriesOptions.length; i++) {
                particularSeriesOptions = allSeriesOptions[i];
                if (particularSeriesOptions.type && !utils.isString(particularSeriesOptions.type))
                    particularSeriesOptions.type = '';
                paneName = particularSeriesOptions.pane || self.defaultPane;
                if ($.inArray(paneName, paneList) === -1)
                    continue;
                data = particularSeriesOptions.data;
                particularSeriesOptions.data = null;
                particularSeriesOptions.seriesGroup = seriesGroup;
                particularSeriesOptions.seriesLabelsGroup = seriesLabelsGroup;
                particularSeriesOptions.trackerGroup = trackerGroup;
                particularSeriesOptions.seriesTrackerGroup = seriesTrackerGroup;
                particularSeriesOptions.markerTrackerGroup = markerTrackerGroup;
                if (argumentAxisOptions) {
                    particularSeriesOptions.argumentCategories = argumentAxisOptions.categories;
                    particularSeriesOptions.argumentAxisType = argumentAxisOptions.type;
                    particularSeriesOptions.argumentType = argumentAxisOptions.argumentType
                }
                if (valueAxisOptions) {
                    particularSeriesOptions.valueCategories = valueAxisOptions.categories;
                    particularSeriesOptions.valueAxisType = valueAxisOptions.type;
                    particularSeriesOptions.valueType = valueAxisOptions.valueType
                }
                particularSeriesOptions.rotated = rotated;
                particularSeriesOptions.incidentOccured = incidentOccured;
                if (!particularSeriesOptions.name)
                    particularSeriesOptions.name = 'Series ' + (i + 1).toString();
                var seriesTheme = themeManager.applyNextSeriesTheme(particularSeriesOptions, commonSeriesSettings, userCommonSeriesSettings);
                particularSeries = charts.factory.createSeries(seriesTheme.type, this.renderer, data, seriesTheme);
                if (!particularSeries)
                    incidentOccured.call(null, 'Unknown series type requested: ' + seriesTheme.type);
                else {
                    particularSeries.axis = particularSeriesOptions.axis;
                    particularSeries.pane = paneName;
                    particularSeries.index = i;
                    self.series.push(particularSeries)
                }
                particularSeriesOptions.data = data
            }
            self.seriesGroup = seriesGroup;
            self.seriesLabelsGroup = seriesLabelsGroup;
            self.trackerGroup = trackerGroup;
            self.seriesTrackerGroup = seriesTrackerGroup;
            self.markerTrackerGroup = markerTrackerGroup;
            return self.series
        },
        _createValueAxis: function(axisOptions, rotated, tickProvider) {
            var self = this,
                axis;
            axisOptions = $.extend({
                isHorizontal: rotated,
                tickProvider: tickProvider,
                incidentOccured: self.option('incidentOccured')
            }, axisOptions);
            axisOptions = $.extend(true, {}, self.option('commonAxisSettings'), self.option(rotated ? 'horizontalAxis' : 'verticalAxis'), self.option('valueAxisStyle'), self.option('userCommonAxisSettings'), self.option('valueAxis'), axisOptions);
            if (axisOptions.strips)
                $.each(axisOptions.strips, function(i, strips) {
                    axisOptions.strips[i] = $.extend(true, {}, axisOptions.stripStyle, axisOptions.strips[i])
                });
            axis = charts.factory.createAxis(self.renderer, axisOptions);
            axis.name = axisOptions.name;
            axis.pane = axis.pane || axisOptions.pane;
            axis.priority = axisOptions.priority;
            return axis
        },
        _populateAxes: function() {
            var self = this,
                horizontalAxes = [],
                verticalAxes = [],
                panes = self.panes,
                rotated = self.option('rotated'),
                themeManager = self.themeManager,
                valueAxisOptions = self.option('valueAxis') || {},
                argumentOption = self.option('argumentAxis') || {},
                argumentAxesOptions = $.isArray(argumentOption) ? argumentOption : [argumentOption],
                valueAxesOptions = $.isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions],
                i,
                axis,
                axisNames = [],
                axisOptions,
                tickProvider = charts.factory.getAxisTickProvider(),
                paneWithNonVirtualAxis;
            var createArgumentAxis = function(axisOptions, virtual) {
                    axisOptions = $.extend(true, {
                        isHorizontal: !rotated,
                        tickProvider: tickProvider,
                        pane: self.defaultPane,
                        incidentOccured: self.option('incidentOccured')
                    }, axisOptions);
                    axisOptions = $.extend(true, {}, self.option('commonAxisSettings'), self.option(rotated ? 'verticalAxis' : 'horizontalAxis'), self.option('argumentAxisStyle'), self.option('userCommonAxisSettings'), self.option('argumentAxis'), axisOptions);
                    if (axisOptions.strips)
                        $.each(axisOptions.strips, function(i, strips) {
                            axisOptions.strips[i] = $.extend(true, {}, axisOptions.stripStyle, axisOptions.strips[i])
                        });
                    axis = charts.factory.createAxis(self.renderer, axisOptions);
                    axis._virtual = virtual;
                    if (axisOptions.isHorizontal)
                        horizontalAxes.push(axis);
                    else
                        verticalAxes.push(axis)
                };
            if (rotated)
                paneWithNonVirtualAxis = argumentAxesOptions[0].position === 'right' ? panes[panes.length - 1].name : panes[0].name;
            else
                paneWithNonVirtualAxis = argumentAxesOptions[0].position === 'top' ? panes[0].name : panes[panes.length - 1].name;
            $.each(panes, function(_, pane) {
                var paneName = pane.name,
                    virtual = paneName != paneWithNonVirtualAxis;
                var axisOptions = $.extend(true, {}, {pane: paneName}, argumentAxesOptions[0]);
                createArgumentAxis(axisOptions, virtual)
            });
            var createValueAxis = function(axisOptions) {
                    var axis = self._createValueAxis(axisOptions, rotated, tickProvider);
                    if (rotated)
                        horizontalAxes.push(axis);
                    else
                        verticalAxes.push(axis)
                };
            var valueAxesCounter = 0;
            var getNextAxisName = function() {
                    return DEFAULT_AXIS_NAME + valueAxesCounter++
                };
            var unique = function(array) {
                    var values = {},
                        i,
                        len = array.length;
                    for (i = 0; i < len; i++)
                        values[array[i]] = true;
                    return $.map(values, function(_, key) {
                            return key
                        })
                };
            $.each(valueAxesOptions, function(priority, axisOptions) {
                var axisPanes = [],
                    name = axisOptions.name;
                if (name && $.inArray(name, axisNames) != -1) {
                    self.option('incidentOccured').call(null, 'The valueAxis configuration array contains axes with the same name.');
                    return
                }
                name && axisNames.push(name);
                if (axisOptions.pane)
                    axisPanes.push(axisOptions.pane);
                if (axisOptions.panes && axisOptions.panes.length)
                    axisPanes = axisPanes.concat(axisOptions.panes.slice(0));
                axisPanes = unique(axisPanes);
                if (!axisPanes.length)
                    axisPanes.push(undefined);
                $.each(axisPanes, function(_, pane) {
                    createValueAxis($.extend(true, {}, axisOptions, {
                        name: name || getNextAxisName(),
                        pane: pane,
                        priority: priority
                    }))
                })
            });
            self.horizontalAxes = horizontalAxes;
            self.verticalAxes = verticalAxes
        },
        _correctValueAxes: function() {
            var self = this,
                rotated = self.option('rotated'),
                themeManager = self.themeManager,
                valueAxisOptions = self.option('valueAxis') || {},
                valueAxesOptions = $.isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions],
                tickProvider = charts.factory.getAxisTickProvider(),
                valueAxes = (rotated ? self.horizontalAxes : self.verticalAxes) || [],
                defaultAxisName = valueAxes[0].name,
                paneAxis = self.paneAxis || {},
                panes = self.panes,
                i,
                neededAxis = {};
            var getPaneForAxis = function(axisNameWithoutPane) {
                    var result;
                    $.each(self.paneAxis, function(paneName, pane) {
                        $.each(pane, function(axisName, _) {
                            if (axisNameWithoutPane == axisName) {
                                result = paneName;
                                return false
                            }
                        })
                    });
                    return result
                };
            var axesWithoutPanes = $.map(valueAxes, function(axis) {
                    if (axis.pane)
                        return null;
                    return axis
                });
            $.each(axesWithoutPanes, function(_, axis) {
                axis.pane = getPaneForAxis(axis.name);
                if (!axis.pane) {
                    axis.pane = self.defaultPane;
                    paneAxis[axis.pane] = paneAxis[axis.pane] || {};
                    paneAxis[axis.pane][axis.name] = true
                }
                axis.options.pane = axis.pane
            });
            for (i = 0; i < panes.length; i++)
                if (!paneAxis[panes[i].name]) {
                    paneAxis[panes[i].name] = {};
                    paneAxis[panes[i].name][defaultAxisName] = true
                }
            var findAxisOptions = function(axisName) {
                    var result,
                        axInd;
                    for (axInd = 0; axInd < valueAxesOptions.length; axInd++)
                        if (valueAxesOptions[axInd].name == axisName) {
                            result = valueAxisOptions[axInd];
                            result.priority = axInd;
                            break
                        }
                    if (!result)
                        for (axInd = 0; axInd < valueAxes.length; axInd++)
                            if (valueAxes[axInd].name == axisName) {
                                result = valueAxes[axInd].options;
                                result.priority = valueAxes[axInd].priority;
                                break
                            }
                    if (!result) {
                        self.option('incidentOccured').call(null, 'Value axis with name "' + axisName + '" does not exist. It was created.');
                        result = {
                            name: axisName,
                            priority: valueAxes.length
                        }
                    }
                    return result
                };
            var findAxis = function(paneName, axisName) {
                    var axis;
                    for (i = 0; i < valueAxes.length; i++) {
                        axis = valueAxes[i];
                        if (axis.name === axisName && axis.pane === paneName)
                            return axis
                    }
                };
            $.each(self.paneAxis, function(paneName, axisNames) {
                $.each(axisNames, function(axisName, _) {
                    neededAxis[axisName + '-' + paneName] = true;
                    var axis = findAxis(paneName, axisName);
                    if (!axis) {
                        var axisOptions = findAxisOptions(axisName);
                        if (axisOptions)
                            valueAxes.push(self._createValueAxis($.extend(true, {}, axisOptions, {
                                pane: paneName,
                                name: axisName
                            }), rotated, tickProvider))
                    }
                })
            });
            valueAxes = $.grep(valueAxes, function(elem) {
                return !!neededAxis[elem.name + '-' + elem.pane]
            });
            valueAxes.sort(function(a, b) {
                return a.priority - b.priority
            });
            rotated ? self.horizontalAxes = valueAxes : self.verticalAxes = valueAxes
        },
        _processSeriesFamilies: function() {
            var self = this,
                types = [],
                families = [],
                paneSeries,
                rotated = self.option('rotated');
            $.each(self.series, function(i, item) {
                if ($.inArray(item.type, types) === -1)
                    types.push(item.type)
            });
            $.each(self.panes, function(_, pane) {
                paneSeries = [];
                $.each(self.series, function(_, oneSeries) {
                    if (oneSeries.pane === pane.name)
                        paneSeries.push(oneSeries)
                });
                $.each(types, function(_, type) {
                    var family = new charts.factory.createSeriesFamily({
                            type: type,
                            pane: pane.name,
                            rotated: rotated,
                            equalBarWidth: self.option('equalBarWidth')
                        });
                    family.add(paneSeries);
                    family.adjustSeriesValues();
                    families.push(family)
                })
            });
            self.seriesFamilies = families
        },
        _createLegend: function() {
            var themeManager = this.themeManager,
                legendOptions = $.extend(true, {
                    renderer: this.renderer,
                    series: this.series,
                    containerBackgroundColor: this.option('commonSeriesSettings').containerBackgroundColor
                }, this.option('legend'));
            this.legend = charts.factory.createLegend(legendOptions)
        },
        _createTranslator: function(range, canvas) {
            return new DX.viz.core.LinearTranslator(range, canvas)
        },
        _createPanesBorderOptions: function() {
            var self = this,
                commonBorderOptions = self.option('commonPaneSettings').border,
                panesBorderOptions = {};
            $.each(self.panes, function(_, pane) {
                var borderOptions = $.extend(true, {}, commonBorderOptions, pane.border);
                panesBorderOptions[pane.name] = borderOptions
            });
            return panesBorderOptions
        },
        _render: function(drawOptions) {
            if (this._seriesInitializing === true)
                return;
            var self = this,
                renderer = self.renderer,
                translators = self.translators,
                rotated = self.option('rotated'),
                i,
                layoutManager = self.layoutManager,
                titleOptions = self.option('title'),
                adjustmentCounter = 0,
                paneName,
                rangeForPane,
                onRenderCompletedCallback = self.option('done'),
                multiAxesSynchronizer = new charts.MultiAxesSynchronizer,
                panesBorderOptions = self._createPanesBorderOptions(),
                stripsGroup = self.stripsGroup = self.stripsGroup || self.renderer.createGroup({'class': 'axis-strips'});
            var updateAxesPerPane = function(self, axes) {
                    var translator,
                        range,
                        axis,
                        axisName;
                    for (i = 0; i < axes.length; i++) {
                        axis = axes[i];
                        paneName = axis.pane;
                        axisName = axis.name;
                        translator = self._getTranslator(paneName, axisName);
                        range = self._getBusinessRange(paneName, axisName);
                        if (translator && range) {
                            translator.init();
                            axis.setRange(range);
                            axis.setTranslator(translator)
                        }
                    }
                };
            var drawSeries = function drawSeries() {
                    var particularSeries;
                    $.each(self.seriesFamilies || [], function(_, seriesFamily) {
                        seriesFamily.adjustSeriesDimensions(self._getTranslator(seriesFamily.pane))
                    });
                    self.seriesGroup.append();
                    self.seriesLabelsGroup.append();
                    for (i = 0; i < self.series.length; i++) {
                        particularSeries = self.series[i];
                        particularSeries.clipRectID = self._getClipRectID(self.series[i].pane);
                        particularSeries.adjustSeriesLabels = drawOptions.adjustSeriesLabels;
                        particularSeries.draw(self._getTranslator(self.series[i].pane, self.series[i].axis));
                        if (drawOptions.animate && particularSeries.getPoints().length <= drawOptions.animationPointsLimit)
                            self.series[i].animate()
                    }
                    self._createTooltip();
                    self.trackerGroup.append();
                    self.seriesTrackerGroup.append(self.trackerGroup);
                    self.markerTrackerGroup.append(self.trackerGroup);
                    if (drawOptions.drawLegend && self.legend && self.legend.options.position === 'inside') {
                        self.legend.clipRectID = self._getCanvasClipRectID();
                        self.legend.canvas = self.canvas;
                        self.legend.draw();
                        layoutManager.applyLegendLayout()
                    }
                    else
                        self.legend.options.position == 'inside' && self.legend.toForeground();
                    if (onRenderCompletedCallback)
                        onRenderCompletedCallback()
                };
            drawOptions = self._prepareDrawOptions(drawOptions);
            self.callBase(drawOptions);
            if (self.stopRedraw) {
                self.stopRedraw = false;
                return
            }
            self._createPanesBackground();
            if (titleOptions.text && drawOptions.drawTitle) {
                self._drawTitle();
                layoutManager.applyTitleLayout()
            }
            if (drawOptions.drawLegend && self.legend && self.legend.options.position === 'outside') {
                self.legend.canvas = self.canvas;
                self.legend.clipRectID = self._getCanvasClipRectID();
                self.legend.draw();
                layoutManager.applyLegendLayout();
                if (layoutManager.isCanvasExceeded(false)) {
                    self.option('incidentOccured')('Container is too small to draw chart with current settings');
                    self._clean();
                    return
                }
            }
            self._setPanesClipRectPadding(panesBorderOptions, rotated);
            if (drawOptions.recreateCanvas) {
                layoutManager.createPanesCanvases();
                $.each(self.paneAxis, function(paneName, pane) {
                    $.each(pane, function(axisName, _) {
                        var translator = self._createTranslator(self._getBusinessRange(paneName, axisName), self._getCanvasForPane(paneName));
                        translator.pane = paneName;
                        translator.axis = axisName;
                        translators.push(translator)
                    })
                })
            }
            else
                $.each(translators, function(_, translator) {
                    translator.updateBusinessRange(self._getBusinessRange(translator.pane, translator.axis));
                    translator.init()
                });
            updateAxesPerPane(self, self.horizontalAxes);
            updateAxesPerPane(self, self.verticalAxes);
            stripsGroup.append();
            do {
                for (i = 0; i < self.horizontalAxes.length; i++)
                    self.horizontalAxes[i].resetTicks();
                for (i = 0; i < self.verticalAxes.length; i++)
                    self.verticalAxes[i].resetTicks();
                if (self.option('synchronizeMultiAxes'))
                    multiAxesSynchronizer.synchronize(rotated ? self.horizontalAxes : self.verticalAxes, rotated);
                for (i = 0; i < self.horizontalAxes.length; i++) {
                    self.horizontalAxes[i].clipRectID = self._getCanvasClipRectID();
                    self.horizontalAxes[i].stripsGroup = stripsGroup;
                    self.horizontalAxes[i].draw({borderOptions: panesBorderOptions[self.horizontalAxes[i].pane]})
                }
                layoutManager.requireAxesRedraw = false;
                if (drawOptions.adjustAxes) {
                    layoutManager.applyHorizontalAxesLayout();
                    $.each(translators, function(_, translator) {
                        translator.init()
                    })
                }
                for (i = 0; i < self.verticalAxes.length; i++) {
                    self.verticalAxes[i].clipRectID = self._getCanvasClipRectID();
                    self.verticalAxes[i].stripsGroup = stripsGroup;
                    self.verticalAxes[i].draw({borderOptions: panesBorderOptions[self.verticalAxes[i].pane]})
                }
                if (drawOptions.adjustAxes) {
                    layoutManager.applyVerticalAxesLayout();
                    $.each(translators, function(_, translator) {
                        translator.init()
                    })
                }
                adjustmentCounter = adjustmentCounter + 1;
                if (layoutManager.isCanvasExceeded(true)) {
                    self.option('incidentOccured')('Container is too small to draw chart with current settings');
                    self._clean();
                    utils.logger.info('CHART - Adjusment attempts performed :' + adjustmentCounter);
                    return
                }
            } while (layoutManager.requireAxesRedraw && adjustmentCounter < MAX_ADJUSTMENT_ATTEMPTS);
            utils.logger.info('CHART - Adjusment attempts performed :' + adjustmentCounter);
            if (self.chartTitle)
                self.chartTitle.setClipRectSettings();
            self._drawPanesBorders(panesBorderOptions);
            self._createClipRectsForPanes();
            self._fillPanesBackground();
            if (drawOptions.asyncSeriesRendering)
                setTimeout(drawSeries, 25);
            else
                drawSeries()
        },
        _setPanesClipRectPadding: function(panesBorderOptions, rotated) {
            var self = this,
                allPanesHaveBorder = true,
                firstPaneHasBorder = panesBorderOptions[self.panes[0].name].visible,
                lastPaneHasBorder = panesBorderOptions[self.panes[self.panes.length - 1].name].visible,
                position = '';
            $.each(self.panes, function(_, pane) {
                allPanesHaveBorder = allPanesHaveBorder && !!panesBorderOptions[pane.name].visible
            });
            $.each(self.horizontalAxes, function(_, axis) {
                position += axis.options.position
            });
            $.each(self.verticalAxes, function(_, axis) {
                position += axis.options.position
            });
            var processCanvasPadding = function(position, side, skip) {
                    var originalSide = 'original' + side,
                        delta;
                    side = side.toLowerCase();
                    if (skip)
                        return;
                    if (position.indexOf(side) === -1) {
                        delta = PANE_CLIP_RECT_PADDING - self.canvas[side];
                        if (delta > 0) {
                            self.canvas[originalSide] += delta;
                            self.canvas[side] += delta
                        }
                    }
                };
            processCanvasPadding(position, 'Bottom', rotated ? allPanesHaveBorder : lastPaneHasBorder);
            processCanvasPadding(position, 'Top', rotated ? allPanesHaveBorder : firstPaneHasBorder);
            processCanvasPadding(position, 'Left', !rotated ? allPanesHaveBorder : firstPaneHasBorder);
            processCanvasPadding(position, 'Right', !rotated ? allPanesHaveBorder : lastPaneHasBorder)
        },
        _createPanesBackground: function() {
            var self = this,
                defaultBackgroundColor = self.option('commonPaneSettings').backgroundColor,
                backgroundColor,
                attr,
                renderer = self.renderer,
                rect,
                i,
                rects = [];
            for (i = 0; i < self.panes.length; i++) {
                backgroundColor = self.panes[i].backgroundColor || defaultBackgroundColor;
                if (!backgroundColor || backgroundColor === 'none') {
                    rects.push(null);
                    continue
                }
                attr = {
                    fill: backgroundColor,
                    strokeWidth: 0
                };
                rect = renderer.createRect(0, 0, 0, 0, 0, attr).append();
                rects.push(rect)
            }
            self.panesBackground = rects
        },
        _fillPanesBackground: function() {
            var self = this,
                bc;
            $.each(self.panes, function(i, pane) {
                bc = pane.borderCoords;
                if (self.panesBackground[i] != null)
                    self.panesBackground[i].applySettings({
                        x: bc.left,
                        y: bc.top,
                        width: bc.width,
                        height: bc.height
                    })
            })
        },
        _calcPaneBorderCoords: function(pane, rotated) {
            var canvas = pane.canvas,
                bc = pane.borderCoords = pane.borderCoords || {};
            bc.left = canvas.left;
            bc.top = canvas.top;
            bc.right = canvas.width - canvas.right;
            bc.bottom = canvas.height - canvas.bottom;
            bc.width = bc.right - bc.left;
            bc.height = bc.bottom - bc.top
        },
        _drawPanesBorders: function(panesBorderOptions) {
            var self = this,
                rotated = self.option('rotated'),
                renderer = self.renderer,
                borderGroup = self.borderGroup = self.borderGroup || renderer.createGroup({'class': 'dxBorder'});
            borderGroup.clear();
            $.each(self.panes, function(i, pane) {
                var bc,
                    borderOptions = panesBorderOptions[pane.name],
                    attr = {
                        fill: 'none',
                        stroke: borderOptions.color,
                        strokeOpacity: borderOptions.opacity,
                        strokeWidth: borderOptions.width,
                        dashStyle: borderOptions.dashStyle
                    };
                self._calcPaneBorderCoords(pane, rotated);
                if (!borderOptions.visible)
                    return;
                bc = pane.borderCoords;
                renderer.createSegmentRect(bc.left, bc.top, bc.width, bc.height, 0, borderOptions, attr).append(borderGroup)
            });
            borderGroup.append()
        },
        _createClipRectsForPanes: function() {
            var self = this,
                renderer = self.renderer,
                commonBorderOptions = self.option('commonPaneSettings').border;
            self.clipRectID = [];
            $.each(self.panes, function(i, pane) {
                var rect,
                    borderOptions = $.extend({}, commonBorderOptions, pane.border),
                    bc = pane.borderCoords,
                    correction = !borderOptions.visible && PANE_CLIP_RECT_PADDING || 0;
                rect = renderer.createClipRect(bc.left - correction, bc.top - correction, bc.width + 2 * correction, bc.height + 2 * correction);
                self.clipRectID.push(rect.id)
            })
        },
        _getClipRectID: function(paneName) {
            var self = this,
                panes = self.panes,
                panesNumber = panes.length,
                i;
            for (i = 0; i < panesNumber; i++)
                if (panes[i].name === paneName)
                    return self.clipRectID[i]
        },
        _getTranslator: function(paneName, axisName) {
            var self = this,
                translators = self.translators,
                translatorsNumber = translators.length,
                foundTranslator = null,
                i;
            for (i = 0; i < translatorsNumber; i++)
                if (translators[i].pane === paneName && translators[i].axis === axisName) {
                    foundTranslator = translators[i];
                    break
                }
            if (!foundTranslator)
                for (i = 0; i < translatorsNumber; i++)
                    if (translators[i].pane === paneName) {
                        foundTranslator = translators[i];
                        break
                    }
            return foundTranslator
        },
        _getCanvasForPane: function(paneName) {
            var panes = this.panes,
                panesNumber = panes.length,
                i;
            for (i = 0; i < panesNumber; i++)
                if (panes[i].name === paneName)
                    return panes[i].canvas
        },
        _getBusinessRange: function(paneName, axisName) {
            var ranges = this.businessRanges || [],
                rangesNumber = ranges.length,
                foundRange,
                i;
            for (i = 0; i < rangesNumber; i++)
                if (ranges[i].pane === paneName && ranges[i].axis === axisName) {
                    foundRange = ranges[i];
                    break
                }
            if (!foundRange)
                for (i = 0; i < rangesNumber; i++)
                    if (ranges[i].pane === paneName) {
                        foundRange = ranges[i];
                        break
                    }
            return foundRange
        },
        _handleSeriesPopulated: function(needRedraw) {
            this._processSeriesFamilies();
            this._createLegend();
            this._populateBusinessRange();
            this._processValueAxisFormat();
            this._processTracker();
            delete this._seriesInitializing;
            needRedraw && this._render({force: true})
        },
        _processValueAxisFormat: function() {
            var self = this,
                rotated = self.option('rotated'),
                series = self.series,
                valueAxes = rotated ? self.horizontalAxes : self.verticalAxes,
                axesWithFullStackedFormat = [];
            $.each(series, function() {
                if (this.isFullStackedSeries() && $.inArray(this.axis, axesWithFullStackedFormat) === -1)
                    axesWithFullStackedFormat.push(this.axis)
            });
            $.each(valueAxes, function() {
                var axisName = this.name;
                if ($.inArray(axisName, axesWithFullStackedFormat) !== -1)
                    this.setPercentLabelFormat()
            })
        },
        _repopulateSeries: function(needRedraw) {
            var data = this._dataSource && this._dataSource.items(),
                seriesTemplate = this.option('seriesTemplate');
            if (this._dataSource && seriesTemplate) {
                this._processSeriesTemplate(needRedraw);
                return
            }
            else {
                data && $.each(this.series, function(_, singleSeries) {
                    singleSeries.reinitData(data)
                });
                this._handleSeriesPopulated(needRedraw)
            }
        },
        zoomArgument: function(min, max) {
            var self = this;
            self.minX = min;
            self.maxX = max;
            if (self.option('adjustOnZoom'))
                self._populateBusinessRange({
                    minArg: min,
                    maxArg: max
                });
            $.each(self.paneAxis, function(paneName, pane) {
                $.each(pane, function(axisName, _) {
                    var translator = self._getTranslator(paneName, axisName);
                    var range = self._getBusinessRange(paneName, axisName);
                    translator.updateBusinessRange(range);
                    if (self.minX || self.maxX) {
                        translator.zoomX(self.minX, self.maxX);
                        translator.init()
                    }
                })
            });
            this._render({
                force: true,
                drawTitle: false,
                drawLegend: false,
                adjustAxes: false,
                animate: false,
                adjustSeriesLabels: false
            })
        }
    })
})(jQuery, DevExpress);

// Module viz, file pieChart.js

(function($, DX, undefined) {
    var charts = DX.viz.charts,
        Class = DX.Class,
        utils = DX.utils;
    charts.PieChart = charts.BaseChart.inherit({
        _defaultOptions: function() {
            return $.extend(true, this.callBase(), {commonSeriesSettings: {
                        type: 'pie',
                        pie: {label: {percentPrecision: 0}}
                    }})
        },
        _init: function() {
            this.callBase();
            delete this._seriesInitializing;
            if (!this.series)
                this._dataSpecificInit()
        },
        _populateBusinessRange: function() {
            var self = this,
                businessRanges = [],
                series = self.series,
                singleSeries = series[0],
                range,
                i,
                singleSeriesRange;
            if (singleSeries) {
                range = new charts.Range({series: singleSeries});
                singleSeriesRange = singleSeries.getRangeData();
                range = range.getBoundRange(singleSeriesRange);
                if (!range.isDefined())
                    range.setStubData();
                businessRanges.push(range)
            }
            self.businessRanges = businessRanges
        },
        _createTranslator: function(range, canvas) {
            return new DevExpress.viz.core.Translator1D(range.minY, range.maxY, 360 - 0.0001, 0)
        },
        _populateSeries: function() {
            var self = this,
                hasSeriesTemplate = !!self.option('seriesTemplate'),
                seriesOptions = hasSeriesTemplate ? self._templatedSeries : self.option('series'),
                allSeriesOptions = $.isArray(seriesOptions) ? seriesOptions : seriesOptions ? [seriesOptions] : [],
                themeManager = self.themeManager,
                data,
                particularSeriesOptions,
                particularSeries,
                seriesTheme,
                seriesType,
                commonSeriesSettings = self.option('commonSeriesSettings'),
                seriesGroup = self.renderer.createGroup({'class': 'series'}),
                trackerGroup = self.renderer.createGroup({'class': 'tracker'}),
                seriesTrackerGroup = self.renderer.createGroup({'class': 'seriesTracker'}),
                markerTrackerGroup = self.renderer.createGroup({'class': 'markerTracker'}),
                seriesLabelsGroup = self.renderer.createGroup({'class': 'labels'}),
                incidentOccured = self.option('incidentOccured'),
                i;
            self.series = [];
            themeManager.resetPalette();
            if (allSeriesOptions.length) {
                particularSeriesOptions = allSeriesOptions[0];
                if (particularSeriesOptions.type && !utils.isString(particularSeriesOptions.type))
                    particularSeriesOptions.type = '';
                data = particularSeriesOptions.data;
                particularSeriesOptions.data = null;
                particularSeriesOptions.incidentOccured = incidentOccured;
                particularSeriesOptions.seriesGroup = seriesGroup;
                particularSeriesOptions.trackerGroup = trackerGroup;
                particularSeriesOptions.seriesTrackerGroup = seriesTrackerGroup;
                particularSeriesOptions.markerTrackerGroup = markerTrackerGroup;
                particularSeriesOptions.seriesLabelsGroup = seriesLabelsGroup;
                seriesTheme = themeManager.applyPieSeriesTheme(particularSeriesOptions, commonSeriesSettings);
                seriesType = seriesTheme.type !== undefined ? seriesTheme.type : self.option('commonSeriesSettings').type;
                particularSeries = charts.factory.createSeries(seriesType, self.renderer, data, seriesTheme);
                if (!particularSeries)
                    incidentOccured.call(null, 'Unknown series type requested: ' + seriesType);
                else {
                    self._processSingleSeries(particularSeries, particularSeries.userOptions);
                    self.series.push(particularSeries)
                }
                particularSeriesOptions.data = data
            }
            self.seriesGroup = seriesGroup;
            self.trackerGroup = trackerGroup;
            self.seriesTrackerGroup = seriesTrackerGroup;
            self.markerTrackerGroup = markerTrackerGroup;
            self.seriesLabelsGroup = seriesLabelsGroup;
            return self.series
        },
        _processSingleSeries: function(singleSeries, options) {
            var self = this,
                commonSeriesSettings = self.option('commonSeriesSettings'),
                points;
            singleSeries.arrangePoints();
            points = singleSeries && singleSeries.getPoints() || [];
            for (var j = 0; j < points.length; j++) {
                var theme = self.themeManager.applyNextPieSegmentTheme(options, commonSeriesSettings);
                var convertedTheme = singleSeries.parseStyleOptions(theme);
                points[j].setOptions(convertedTheme.point);
                points[j].index = j
            }
        },
        _handleSeriesPopulated: function(needRedraw) {
            this._populateBusinessRange();
            this._processTracker();
            this._createLegend();
            delete this._seriesInitializing;
            needRedraw && this._render({
                force: true,
                recreateCanvas: true
            })
        },
        _repopulateSeries: function(needRedraw) {
            var self = this,
                data = self._dataSource && self._dataSource.items(),
                seriesTemplate = this.option('seriesTemplate');
            self.themeManager.resetPalette();
            if (this._dataSource && seriesTemplate) {
                this._processSeriesTemplate(needRedraw);
                return
            }
            else {
                data && $.each(self.series, function(_, singleSeries) {
                    singleSeries.reinitData(data);
                    self._processSingleSeries(singleSeries, singleSeries.userOptions)
                });
                this._handleSeriesPopulated(needRedraw)
            }
        },
        _createLegend: function() {
            var self = this,
                legendOptions = $.extend(true, {
                    renderer: self.renderer,
                    series: $.map(self.series[0] ? self.series[0].getPoints() : [], function(item) {
                        item.name = item.argument;
                        item.options.showInLegend = true,
                        item.styles = {themeColor: item.options.attributes.fill};
                        return item
                    })
                }, self.option('legend'));
            if (legendOptions.position !== 'outside')
                legendOptions.position = 'outside';
            this.legend = charts.factory.createLegend(legendOptions)
        },
        _render: function(drawOptions) {
            if (this._seriesInitializing === true)
                return;
            var self = this,
                renderer = self.renderer,
                i,
                titleOptions = self.option('title'),
                layoutManager = self.layoutManager;
            drawOptions = self._prepareDrawOptions(drawOptions);
            this.callBase(drawOptions);
            if (self.stopRedraw) {
                self.stopRedraw = false;
                return
            }
            if (titleOptions.text && drawOptions.drawTitle) {
                self._drawTitle();
                layoutManager.applyTitleLayout()
            }
            if (drawOptions.drawLegend && self.legend) {
                self.legend.clipRectID = self._getCanvasClipRectID();
                self.legend.canvas = self.canvas;
                self.legend.draw();
                layoutManager.applyLegendLayout()
            }
            if (self.chartTitle)
                self.chartTitle.setClipRectSettings();
            if (self.series && self.series[0]) {
                layoutManager.applyPieChartSeriesLayout();
                self.seriesGroup.append();
                self.seriesLabelsGroup.append();
                self.series[0].canvas = self.canvas;
                self.series[0].draw(self._createTranslator(self.businessRanges[0], self.canvas));
                if (self.series[0].redraw) {
                    self.seriesGroup.clear();
                    self.seriesTrackerGroup.clear();
                    self.markerTrackerGroup.clear();
                    self.trackerGroup.clear();
                    self.seriesLabelsGroup.clear();
                    layoutManager.applyPieChartSeriesLayout();
                    self.series[0].draw(self._createTranslator(self.businessRanges[0], self.canvas))
                }
                self.series[0].animate();
                self._createTooltip();
                self.trackerGroup.append();
                self.seriesTrackerGroup.append(self.trackerGroup);
                self.markerTrackerGroup.append(self.trackerGroup)
            }
        },
        getSeries: function getSeries() {
            return this.series && this.series[0]
        }
    })
})(jQuery, DevExpress);

// Module viz, file themeManager.js

(function($, DX, undefined) {
    var viz = DX.viz,
        core = viz.core,
        charts = DX.viz.charts,
        Class = DX.Class,
        utils = DX.utils;
    var BORDER_COLOR_HIGHLIGHTING = 120,
        HOVER_COLOR_HIGHLIGHTING = 20,
        HOVER_BORDER_COLOR_HIGHLIGHTING = 20,
        POINT_DARKENING = 20,
        POINT_BORDER_DARKENING = 30,
        POINT_HOVER_BORDER_DARKENING = 20;
    charts.ThemeManager = core.BaseThemeManager.inherit(function() {
        var ctor = function(options, themeGroupName) {
                options = options || {};
                this.callBase(options.theme, themeGroupName || 'chart');
                this.palette = new core.Palette(options.palette || this.theme.defaultPalette, 50);
                this.init()
            };
        var init = function() {
                var self = this;
                self.theme.legend = self.theme.legend || {};
                self.theme.legend.font = self.theme.legend.font || {};
                self.initializeFont(self.theme.legend.font);
                initDefaultSeriesTheme(self);
                initAxisTheme(self);
                self.theme.title = self.theme.title || {};
                self.theme.title.font = self.theme.title.font || {};
                self.initializeFont(self.theme.title.font);
                self.theme.tooltip = self.theme.tooltip || {};
                self.theme.tooltip.font = self.theme.tooltip.font || {};
                self.initializeFont(self.theme.tooltip.font)
            };
        var initDefaultSeriesTheme = function(self) {
                var theme = self.theme,
                    commonSeriesSettings = theme.commonSeriesSettings,
                    fontOptions = theme.font,
                    pointTheme;
                commonSeriesSettings.point = commonSeriesSettings.point || {};
                commonSeriesSettings.containerBackgroundColor = commonSeriesSettings.containerBackgroundColor || theme.containerBackgroundColor;
                commonSeriesSettings.label = commonSeriesSettings.label || {};
                self.initializeFont(commonSeriesSettings.label.font)
            };
        var initAxisTheme = function(self) {
                var theme = self.theme,
                    axisTheme = theme.commonAxisSettings,
                    fontOptions = theme.font,
                    titleTheme,
                    labelTheme;
                if (axisTheme) {
                    axisTheme.label = axisTheme.label || {};
                    axisTheme.grid = axisTheme.grid || {};
                    axisTheme.ticks = axisTheme.ticks || {};
                    axisTheme.line = axisTheme.line || {};
                    axisTheme.title = axisTheme.title || {};
                    axisTheme.label.font = axisTheme.label.font || {};
                    self.initializeFont(axisTheme.label.font);
                    axisTheme.title.font = axisTheme.title.font || {};
                    self.initializeFont(axisTheme.title.font)
                }
            };
        var applyChartTheme = function(userOptions) {
                var self = this,
                    refs = {
                        dataSource: userOptions.dataSource,
                        series: userOptions.series
                    },
                    result;
                delete userOptions.dataSource;
                delete userOptions.series;
                result = self.applyTheme(self.theme, userOptions);
                result.dataSource = refs.dataSource;
                result.series = refs.series;
                userOptions.series = refs.series;
                return result
            };
        var applyNextSeriesTheme = function(userOptions, commonSeriesSettings, userCommonSeriesSettings) {
                var debug = utils.debug;
                debug.assertParam(userOptions, 'User options were not passed');
                if (commonSeriesSettings) {
                    debug.assertParam(commonSeriesSettings.hoverStyle, 'hoverStyle option was not passed');
                    debug.assertParam(commonSeriesSettings.selectionStyle, 'selectionStyle option was not passed');
                    debug.assertParam(commonSeriesSettings.point, 'point option was not passed');
                    debug.assertParam(commonSeriesSettings.point.hoverStyle, 'point.hoverStyle option was not passed');
                    debug.assertParam(commonSeriesSettings.point.selectionStyle, 'point.selectionStyle option was not passed')
                }
                var self = this,
                    mergedSettings = $.extend(true, {}, commonSeriesSettings || self.theme.commonSeriesSettings),
                    mergedUserSettings = $.extend(true, {}, userCommonSeriesSettings || {}),
                    seriesType = (userOptions.type || mergedSettings.type || '').toLowerCase(),
                    isAreaOrBar = ~seriesType.indexOf('area') || ~seriesType.indexOf('bar');
                mergedUserSettings = $.extend(true, mergedUserSettings, mergedUserSettings[seriesType]);
                mergedSettings = $.extend(true, mergedSettings, mergedSettings[seriesType], mergedUserSettings);
                userOptions = userOptions || {};
                var mainColor = new charts.Color(userOptions.color || mergedUserSettings.color || self.palette.getNextColor());
                mergedSettings.color = mainColor.toHex();
                mergedSettings.border.color = mergedSettings.border.color || mainColor.toHex();
                mergedSettings.hoverStyle.color = mergedSettings.hoverStyle.color || isAreaOrBar && mainColor.highlight(HOVER_COLOR_HIGHLIGHTING) || mainColor.toHex();
                mergedSettings.hoverStyle.border.color = mergedSettings.hoverStyle.border.color || mainColor.toHex();
                mergedSettings.selectionStyle.color = mergedSettings.selectionStyle.color || isAreaOrBar && mainColor.highlight(HOVER_COLOR_HIGHLIGHTING) || mainColor.toHex();
                mergedSettings.selectionStyle.border.color = mergedSettings.selectionStyle.border.color || mainColor.toHex();
                mergedSettings.point.color = mergedSettings.point.color || mainColor.toHex();
                mergedSettings.point.border.color = mergedSettings.point.border.color || mainColor.toHex();
                mergedSettings.point.hoverStyle.color = mergedSettings.point.hoverStyle.color || mergedSettings.containerBackgroundColor;
                mergedSettings.point.hoverStyle.border.color = mergedSettings.point.hoverStyle.border.color || mainColor.toHex();
                mergedSettings.point.selectionStyle.color = mergedSettings.point.selectionStyle.color || mergedSettings.containerBackgroundColor;
                mergedSettings.point.selectionStyle.border.color = mergedSettings.point.selectionStyle.border.color || mainColor.toHex();
                return self.applyTheme(mergedSettings, userOptions)
            };
        var applyPieSeriesTheme = function applyPieSeriesTheme(userOptions, commonSeriesSettings) {
                var self = this,
                    commonSettings = commonSeriesSettings || self.theme.commonSeriesSettings || {},
                    seriesType = (userOptions.type || commonSettings.type || '').toLowerCase();
                if (seriesType && seriesType !== 'pie')
                    commonSettings[seriesType] = $.extend(true, {}, commonSettings[seriesType], commonSettings.pie);
                userOptions = userOptions || {};
                userOptions = $.extend(true, {}, commonSettings, commonSettings[seriesType], userOptions);
                return userOptions
            };
        var applyNextPieSegmentTheme = function applyNextPieSegmentTheme(userOptions, commonSeriesSettings) {
                var self = this,
                    commonSettings = commonSeriesSettings || self.theme.commonSeriesSettings || {},
                    mergedSettings = $.extend(true, {}, commonSettings.pie),
                    seriesType = userOptions.type || mergedSettings.type || '';
                userOptions = userOptions || {};
                var mainColor = new charts.Color(userOptions.color || self.palette.getNextColor());
                mergedSettings.color = mainColor.toHex();
                mergedSettings.border.color = mergedSettings.border.color || mainColor.toHex();
                mergedSettings.hoverStyle.color = mergedSettings.hoverStyle.color || mainColor.highlight(20);
                mergedSettings.hoverStyle.border.color = mergedSettings.hoverStyle.border.color || mainColor.toHex();
                mergedSettings.selectionStyle.color = mergedSettings.selectionStyle.color || mainColor.highlight(20);
                mergedSettings.selectionStyle.border.color = mergedSettings.selectionStyle.border.color || mainColor.toHex();
                return self.applyTheme(mergedSettings, userOptions)
            };
        var resetPalette = function() {
                this.palette.reset()
            };
        return {
                ctor: ctor,
                init: init,
                applyChartTheme: applyChartTheme,
                applyNextSeriesTheme: applyNextSeriesTheme,
                applyPieSeriesTheme: applyPieSeriesTheme,
                applyNextPieSegmentTheme: applyNextPieSegmentTheme,
                resetPalette: resetPalette
            }
    }())
})(jQuery, DevExpress);

// Module viz, file layoutManager.js

(function($, DX, undefined) {
    var charts = DX.viz.charts,
        Class = DX.Class,
        utils = DX.utils,
        math = Math,
        round = math.round;
    charts.LayoutManager = Class.inherit(function() {
        var ctor = function(chart) {
                var self = this,
                    canvas = chart.canvas;
                self.chart = chart;
                self.init()
            };
        var setCanvasValues = function(self) {
                var canvas = self.canvas;
                if (canvas) {
                    canvas.originalTop = canvas.top;
                    canvas.originalBottom = canvas.bottom;
                    canvas.originalLeft = canvas.left;
                    canvas.originalRight = canvas.right
                }
            };
        var init = function() {
                var self = this,
                    chart = self.chart;
                self.legend = chart.legend;
                self.canvas = chart.canvas;
                setCanvasValues(self)
            };
        var createPanesCanvases = function() {
                var debug = DX.utils.debug;
                $.each(this.chart.panes, function(i, item) {
                    debug.assert(item, 'pane is null object');
                    debug.assert(item.name, 'Pane does not have name')
                });
                var self = this,
                    chartCanvas = self.canvas,
                    panes = self.chart.panes,
                    rotated = self.chart.option('rotated'),
                    pane,
                    i,
                    panesNumber = panes.length,
                    paneSpaceHeight = chartCanvas.height - chartCanvas.top - chartCanvas.bottom,
                    paneSpaceWidth = chartCanvas.width - chartCanvas.left - chartCanvas.right,
                    weightSum = 0,
                    oneWeightHeight,
                    oneWeightWidth,
                    padding = panes.padding || 10,
                    distributedTopSpace = 0,
                    distributedLeftSpace = 0;
                for (i = 0; i < panesNumber; i++) {
                    pane = panes[i];
                    pane.weight = pane.weight || 1;
                    weightSum = weightSum + pane.weight
                }
                oneWeightHeight = (paneSpaceHeight - padding * (panesNumber - 1)) / weightSum;
                oneWeightWidth = (paneSpaceWidth - padding * (panesNumber - 1)) / weightSum;
                if (!rotated)
                    for (i = 0; i < panesNumber; i++) {
                        pane = panes[i];
                        pane.calcHeight = round(pane.weight * oneWeightHeight);
                        pane.canvas = $.extend({}, chartCanvas);
                        pane.canvas.top = pane.canvas.originalTop = chartCanvas.top + distributedTopSpace;
                        pane.canvas.bottom = pane.canvas.originalBottom = chartCanvas.bottom + (paneSpaceHeight - pane.calcHeight - distributedTopSpace);
                        distributedTopSpace = distributedTopSpace + pane.calcHeight + padding
                    }
                else
                    for (i = 0; i < panesNumber; i++) {
                        pane = panes[i];
                        pane.calcWidth = round(pane.weight * oneWeightWidth);
                        pane.canvas = $.extend({}, chartCanvas);
                        pane.canvas.left = pane.canvas.originalLeft = chartCanvas.left + distributedLeftSpace;
                        pane.canvas.right = pane.canvas.originalRight = chartCanvas.right + (paneSpaceWidth - pane.calcWidth - distributedLeftSpace);
                        distributedLeftSpace = distributedLeftSpace + pane.calcWidth + padding
                    }
            };
        var applyTitleLayout = function() {
                var self = this,
                    canvas = self.canvas,
                    title = self.chart.chartTitle,
                    box,
                    horizontalPadding = 15,
                    verticalPadding = 10,
                    shiftX,
                    shiftY;
                if (!title)
                    return;
                box = title.getBoundingRect();
                switch (title.horizontalAlignment) {
                    case'left':
                        shiftX = round(horizontalPadding + canvas.left);
                        break;
                    case'center':
                        shiftX = round((canvas.width - canvas.left - canvas.right - box.width) / 2 + canvas.left) - box.x;
                        break;
                    case'right':
                        shiftX = round(canvas.width - canvas.right - box.x - box.width - horizontalPadding);
                        break
                }
                if (title.verticalAlignment === 'top') {
                    shiftY = round(canvas.top - box.y);
                    canvas.top = canvas.top + box.height + verticalPadding
                }
                else {
                    shiftY = round(canvas.height - canvas.bottom - box.height - box.y);
                    canvas.bottom = canvas.bottom + box.height + verticalPadding
                }
                title.shift(shiftX, shiftY);
                setCanvasValues(self)
            };
        var adjustTitleLayout = function adjustTitleLayout() {
                var self = this,
                    canvas = self.canvas,
                    horizontalPadding = 15,
                    title = self.chart.chartTitle,
                    box,
                    shiftX,
                    shiftY = title.innerTitleGroup.settings.translateY || 0;
                box = title.getBoundingRect();
                switch (title.horizontalAlignment) {
                    case'left':
                        shiftX = round(horizontalPadding + canvas.left);
                        break;
                    case'center':
                        shiftX = round((canvas.width - canvas.right - canvas.left - box.width) / 2 + canvas.left - box.x);
                        break;
                    case'right':
                        shiftX = round(canvas.width - canvas.right - box.x - box.width - horizontalPadding);
                        break
                }
                title.shift(shiftX, shiftY)
            };
        var applyLegendLayout = function applyLegendLayout() {
                var self = this,
                    canvas = self.canvas,
                    legend = self.legend,
                    options = self.legend.options,
                    rect = legend.getBoundingRect(),
                    verticalPadding = 10,
                    horizontalPadding = 10,
                    shiftX,
                    shiftY,
                    title = self.chart.chartTitle;
                if (!options.visible)
                    return;
                if (!utils.isNumber(rect.width) || !utils.isNumber(rect.height))
                    return;
                if (options.position === 'outside') {
                    switch (options.horizontalAlignment) {
                        case'left':
                            shiftX = round(canvas.left - rect.x + horizontalPadding);
                            canvas.left = canvas.left + rect.width + options.margin + horizontalPadding;
                            if (title)
                                self.adjustTitleLayout();
                            break;
                        case'center':
                            shiftX = round((canvas.width - canvas.left - canvas.right - rect.width) / 2 + canvas.left - rect.x);
                            break;
                        case'right':
                            shiftX = round(canvas.width - canvas.right - rect.width - rect.x - horizontalPadding);
                            canvas.right = canvas.right + rect.width + options.margin + horizontalPadding;
                            if (title)
                                self.adjustTitleLayout();
                            break
                    }
                    switch (options.verticalAlignment) {
                        case'top':
                            shiftY = round(verticalPadding + canvas.top - rect.y);
                            if (options.horizontalAlignment === 'center')
                                canvas.top = canvas.top + rect.height + options.margin + verticalPadding;
                            break;
                        case'bottom':
                            shiftY = round(canvas.height - rect.height - canvas.bottom - verticalPadding - rect.y);
                            if (options.horizontalAlignment === 'center')
                                canvas.bottom = canvas.bottom + rect.height + options.margin + verticalPadding;
                            break
                    }
                    legend.shift(shiftX, shiftY);
                    setCanvasValues(self)
                }
                else {
                    canvas = $.extend(true, {}, self.chart.panes[0].canvas);
                    canvas.bottom = self.chart.panes[self.chart.panes.length - 1].canvas.bottom;
                    switch (options.horizontalAlignment) {
                        case'left':
                            shiftX = round(canvas.left - rect.x + options.margin);
                            break;
                        case'center':
                            shiftX = round((canvas.width - canvas.left - canvas.right - rect.width) / 2 + canvas.left - rect.x);
                            break;
                        case'right':
                            shiftX = round(canvas.width - canvas.right - rect.width - rect.x - options.margin);
                            break
                    }
                    switch (options.verticalAlignment) {
                        case'top':
                            shiftY = round(canvas.top - rect.y + options.margin);
                            break;
                        case'bottom':
                            shiftY = round(canvas.height - rect.height - canvas.bottom - options.margin - rect.y);
                            break
                    }
                    legend.shift(shiftX, shiftY)
                }
            };
        var applyPieChartSeriesLayout = function() {
                var self = this,
                    canvas = self.canvas,
                    series = self.chart.series,
                    singleSeries = series[0] || {},
                    paneSpaceHeight = canvas.height - canvas.top - canvas.bottom,
                    paneSpaceWidth = canvas.width - canvas.left - canvas.right,
                    min = paneSpaceWidth < paneSpaceHeight ? paneSpaceWidth : paneSpaceHeight,
                    accessibleRadius,
                    outerRadius = singleSeries.outerRadius,
                    innerRadius = singleSeries.type === 'pie' ? 0 : singleSeries.innerRadius || 0;
                if (!(singleSeries && singleSeries.correctPosition))
                    return;
                if (singleSeries.type !== 'pie')
                    if (!utils.isNumber(innerRadius))
                        innerRadius = 0.5;
                    else {
                        innerRadius = Number(innerRadius);
                        if (innerRadius < 0.2)
                            innerRadius = 0.2;
                        if (innerRadius > 0.8)
                            innerRadius = 0.8
                    }
                accessibleRadius = outerRadius || (min - singleSeries.labelSpace - singleSeries.hoverSpace) / 2;
                singleSeries.correctPosition({
                    centerX: round(paneSpaceWidth / 2 + canvas.left),
                    centerY: round(paneSpaceHeight / 2 + canvas.top),
                    radiusInner: round(accessibleRadius * innerRadius),
                    radiusOuter: round(accessibleRadius)
                })
            };
        var isValidBox = function isValidBox(box) {
                return !!(box.x || box.y || box.width || box.height)
            };
        var correctDeltaMarginValue = function(panes, canvasesGrid, marginSides) {
                var axisPanePosition,
                    canvasCell,
                    canvas,
                    deltaSide,
                    requireAxesRedraw;
                $.each(panes, function(_, pane) {
                    axisPanePosition = getPanePosition(canvasesGrid, pane.name);
                    canvasCell = canvasesGrid[axisPanePosition.row][axisPanePosition.col];
                    canvas = canvasCell.canvas;
                    $.each(marginSides, function(_, side) {
                        deltaSide = 'delta' + side;
                        canvasCell[deltaSide] = math.max(canvasCell[deltaSide] - (canvas[side.toLowerCase()] - canvas['original' + side]), 0);
                        if (canvasCell[deltaSide] > 0)
                            requireAxesRedraw = true
                    })
                });
                return requireAxesRedraw
            };
        var applyVerticalAxesLayout = function() {
                var self = this,
                    axes = self.chart.verticalAxes,
                    canvas,
                    axisPanePosition,
                    axisPosition,
                    canvasesGrid,
                    canvasCell,
                    box,
                    delta,
                    axis,
                    axisWidth,
                    commonAxisWidht = 0,
                    direction,
                    directionMultiplier,
                    i;
                canvasesGrid = distributeCanvases(self, self.chart.panes);
                for (i = 0; i < axes.length; i++) {
                    axis = axes[i];
                    axisPosition = axis.options.position || 'left';
                    axis.delta = {};
                    box = axis.getBoundingRect();
                    if (!isValidBox(box))
                        continue;
                    axisPanePosition = getPanePosition(canvasesGrid, axes[i].pane);
                    canvasCell = canvasesGrid[axisPanePosition.row][axisPanePosition.col];
                    canvas = canvasCell.canvas;
                    if (axisPosition == 'right') {
                        direction = 'deltaRight';
                        directionMultiplier = 1
                    }
                    else {
                        direction = 'deltaLeft';
                        directionMultiplier = -1
                    }
                    axisWidth = box.width;
                    if (!axis.delta[axisPosition] && canvasCell[direction] > 0)
                        canvasCell[direction] += axes[i].getMultipleAxesSpacing();
                    axes[i].delta[axisPosition] = axes[i].delta[axisPosition] || 0;
                    axes[i].delta[axisPosition] += canvasCell[direction] * directionMultiplier;
                    canvasCell[direction] += axisWidth;
                    delta = box.y + box.height - (canvas.height - canvas.originalBottom);
                    if (delta > 0) {
                        self.requireAxesRedraw = true;
                        canvasCell.deltaBottom += delta
                    }
                    delta = canvas.originalTop - box.y;
                    if (delta > 0) {
                        self.requireAxesRedraw = true;
                        canvasCell.deltaTop += delta
                    }
                }
                self.requireAxesRedraw = correctDeltaMarginValue(self.chart.panes, canvasesGrid, ['Left', 'Right']) || self.requireAxesRedraw;
                applyFoundExceedings(canvasesGrid)
            };
        var applyHorizontalAxesLayout = function() {
                var self = this,
                    axes = self.chart.horizontalAxes,
                    canvas,
                    axisPanePosition,
                    canvasesGrid,
                    canvasCell,
                    box,
                    delta,
                    axis,
                    axisHeight,
                    direction,
                    directionMultiplier,
                    axisPosition,
                    i;
                canvasesGrid = distributeCanvases(self, self.chart.panes);
                for (i = axes.length - 1; i >= 0; i--) {
                    axis = axes[i];
                    axisPosition = axis.options.position || 'bottom';
                    axes[i].delta = {};
                    box = axes[i].getBoundingRect();
                    if (!isValidBox(box))
                        continue;
                    axisPanePosition = getPanePosition(canvasesGrid, axes[i].pane);
                    canvasCell = canvasesGrid[axisPanePosition.row][axisPanePosition.col];
                    canvas = canvasCell.canvas;
                    if (axisPosition == 'top') {
                        direction = 'deltaTop';
                        directionMultiplier = -1
                    }
                    else {
                        direction = 'deltaBottom';
                        directionMultiplier = 1
                    }
                    axisHeight = box.height;
                    if (!axis.delta[axisPosition] && canvasCell[direction] > 0)
                        canvasCell[direction] += axes[i].getMultipleAxesSpacing();
                    axes[i].delta[axisPosition] = axes[i].delta[axisPosition] || 0;
                    axes[i].delta[axisPosition] += canvasCell[direction] * directionMultiplier;
                    canvasCell[direction] += axisHeight;
                    delta = canvas.originalLeft - box.x;
                    if (delta > 0) {
                        self.requireAxesRedraw = true;
                        canvasCell.deltaLeft += delta
                    }
                    delta = box.x + box.width - (canvas.width - canvas.originalRight);
                    if (delta > 0) {
                        self.requireAxesRedraw = true;
                        canvasCell.deltaRight = delta
                    }
                }
                self.requireAxesRedraw = correctDeltaMarginValue(self.chart.panes, canvasesGrid, ['Bottom', 'Top']) || self.requireAxesRedraw;
                applyFoundExceedings(canvasesGrid)
            };
        var distributeCanvases = function distributeCanvases(self, panes) {
                var panesLength = panes.length,
                    i,
                    j,
                    canvasesGrid = [],
                    canvasesRow = [],
                    rotated = self.chart.option('rotated');
                for (i = 0; i < panesLength; i++) {
                    if (!rotated)
                        canvasesRow = [];
                    canvasesRow.push({
                        canvas: panes[i].canvas,
                        pane: panes[i].name,
                        deltaLeft: 0,
                        deltaRight: 0,
                        deltaTop: 0,
                        deltaBottom: 0
                    });
                    !rotated && canvasesGrid.push(canvasesRow)
                }
                rotated && canvasesGrid.push(canvasesRow);
                return canvasesGrid
            };
        var getPanePosition = function getPanePosition(canvasesGrid, pane) {
                var row,
                    col;
                for (row = 0; row < canvasesGrid.length; row++)
                    for (col = 0; col < canvasesGrid[row].length; col++)
                        if (canvasesGrid[row][col].pane === pane)
                            return {
                                    row: row,
                                    col: col
                                }
            };
        var changeRowCanvas = function changeRowCanvas(canvasesGrid, row, callback) {
                var col;
                for (col = 0; col < canvasesGrid[row].length; col++)
                    callback(canvasesGrid[row][col].canvas)
            };
        var changeColumnCanvas = function changeRowCanvas(canvasesGrid, col, callback) {
                var row;
                for (row = 0; row < canvasesGrid.length; row++)
                    callback(canvasesGrid[row][col].canvas)
            };
        var applyFoundExceedings = function applyFoundExceedings(canvasesGrid) {
                var col,
                    row,
                    canvasesRow,
                    maxLeft = 0,
                    maxRight = 0,
                    maxTop = 0,
                    maxBottom = 0,
                    maxColNumber = 0;
                for (row = 0; row < canvasesGrid.length; row++) {
                    maxTop = 0;
                    maxBottom = 0;
                    canvasesRow = canvasesGrid[row];
                    if (canvasesRow.length > maxColNumber)
                        maxColNumber = canvasesRow.length;
                    for (col = 0; col < canvasesRow.length; col++) {
                        if (canvasesRow[col] && canvasesRow[col].deltaTop > maxTop)
                            maxTop = canvasesRow[col].deltaTop;
                        if (canvasesRow[col] && canvasesRow[col].deltaBottom > maxBottom)
                            maxBottom = canvasesRow[col].deltaBottom
                    }
                    if (maxTop)
                        changeRowCanvas(canvasesGrid, row, function(canvas) {
                            canvas.top += maxTop
                        });
                    if (maxBottom)
                        changeRowCanvas(canvasesGrid, row, function(canvas) {
                            canvas.bottom += maxBottom
                        })
                }
                for (col = 0; col < maxColNumber; col++) {
                    maxLeft = 0;
                    maxRight = 0;
                    for (row = 0; row < canvasesGrid.length; row++) {
                        canvasesRow = canvasesGrid[row];
                        if (canvasesRow[col] && canvasesRow[col].deltaLeft > maxLeft)
                            maxLeft = canvasesRow[col].deltaLeft;
                        if (canvasesRow[col] && canvasesRow[col].deltaRight > maxRight)
                            maxRight = canvasesRow[col].deltaRight
                    }
                    if (maxLeft)
                        changeColumnCanvas(canvasesGrid, col, function(canvas) {
                            canvas.left += maxLeft
                        });
                    if (maxRight)
                        changeColumnCanvas(canvasesGrid, col, function(canvas) {
                            canvas.right += maxRight
                        })
                }
            };
        var isSingleCanvasExceeded = function isSingleCanvasExceeded(canvas) {
                if (canvas.left > canvas.width - canvas.right || canvas.right > canvas.width - canvas.left || canvas.top > canvas.height - canvas.bottom || canvas.bottom > canvas.height - canvas.top)
                    return true
            };
        var isCanvasExceeded = function isCanvasExceeded(includePanes) {
                var self = this,
                    canvas = self.canvas,
                    panes = self.chart && self.chart.panes,
                    paneCanvasesExceed = false;
                if (isSingleCanvasExceeded(canvas))
                    return true;
                if (includePanes)
                    $.each(panes || {}, function(_, pane) {
                        if (pane.canvas && isSingleCanvasExceeded(pane.canvas)) {
                            paneCanvasesExceed = true;
                            return false
                        }
                    });
                return paneCanvasesExceed
            };
        return {
                ctor: ctor,
                createPanesCanvases: createPanesCanvases,
                applyLegendLayout: applyLegendLayout,
                applyTitleLayout: applyTitleLayout,
                adjustTitleLayout: adjustTitleLayout,
                applyVerticalAxesLayout: applyVerticalAxesLayout,
                applyHorizontalAxesLayout: applyHorizontalAxesLayout,
                applyPieChartSeriesLayout: applyPieChartSeriesLayout,
                init: init,
                isCanvasExceeded: isCanvasExceeded
            }
    }())
})(jQuery, DevExpress);

// Module viz, file multiAxesSynchronizer.js

(function($, DX, undefined) {
    var charts = DX.viz.charts,
        utils = DX.utils;
    charts.MultiAxesSynchronizer = DX.Class.inherit(function() {
        var getValueAxesPerPanes = function(valueAxes) {
                var result = {};
                $.each(valueAxes, function() {
                    if (!result[this.pane])
                        result[this.pane] = [];
                    result[this.pane].push(this)
                });
                return result
            };
        var restoreOriginalBusinessRange = function(axis, argumentField) {
                var businessRange,
                    minVisible = 'minVisible' + argumentField,
                    maxVisible = 'maxVisible' + argumentField,
                    minArgumentVisibleValue,
                    maxArgumentVisibleValue;
                if (!axis.translator._originalBusinessRange)
                    axis.translator._originalBusinessRange = new charts.Range(axis.translator.getBusinessRange());
                else {
                    minArgumentVisibleValue = axis.translator.businessRange[minVisible];
                    maxArgumentVisibleValue = axis.translator.businessRange[maxVisible];
                    businessRange = new charts.Range(axis.translator._originalBusinessRange);
                    businessRange[minVisible] = minArgumentVisibleValue;
                    businessRange[maxVisible] = maxArgumentVisibleValue;
                    axis.translator.updateBusinessRange(businessRange);
                    axis.setRange(businessRange)
                }
            };
        var populateAxesInfo = function(axes, rotated) {
                var axesInfo = [];
                $.each(axes, function() {
                    var tickValues,
                        minValue,
                        maxValue,
                        inverted,
                        axisInfo,
                        businessRange,
                        stubData = rotated && 'stubDataX' || 'stubDataY';
                    restoreOriginalBusinessRange(this, rotated ? 'Y' : 'X');
                    tickValues = this.getTickValues();
                    if (tickValues && tickValues.length > 0 && utils.isNumber(tickValues[0])) {
                        businessRange = this.translator.getBusinessRange();
                        minValue = rotated ? businessRange.minVisibleX : businessRange.minVisibleY;
                        maxValue = rotated ? businessRange.maxVisibleX : businessRange.maxVisibleY;
                        inverted = rotated ? businessRange.invertX : businessRange.invertY;
                        axisInfo = {
                            axis: this,
                            tickValues: tickValues,
                            minValue: minValue,
                            oldMinValue: minValue,
                            maxValue: maxValue,
                            oldMaxValue: maxValue,
                            inverted: inverted,
                            synchronizedValue: this.options.synchronizedValue
                        };
                        if (businessRange[stubData]) {
                            axisInfo.stubData = true;
                            axisInfo.tickInterval = axisInfo.axis.options.tickInterval
                        }
                        if (!axisInfo.tickInterval && tickValues.length > 1)
                            axisInfo.tickInterval = tickValues[1] - tickValues[0];
                        axesInfo.push(axisInfo)
                    }
                });
                return axesInfo
            };
        var updateTickValues = function(axesInfo) {
                var maxTicksCount = 0,
                    ticksMultiplier,
                    ticksCount,
                    additionalStartTicksCount = 0;
                $.each(axesInfo, function() {
                    maxTicksCount = Math.max(maxTicksCount, this.tickValues.length)
                });
                $.each(axesInfo, function() {
                    if (utils.isDefined(this.synchronizedValue)) {
                        this.baseTickValue = this.synchronizedValue;
                        this.invertedBaseTickValue = this.synchronizedValue;
                        this.tickValues = [this.baseTickValue]
                    }
                    else {
                        if (this.tickValues.length > 1 && this.tickInterval) {
                            ticksMultiplier = Math.floor((maxTicksCount + 1) / this.tickValues.length);
                            ticksCount = ticksMultiplier > 1 ? Math.floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;
                            additionalStartTicksCount = Math.floor((ticksCount - this.tickValues.length) / 2);
                            while (additionalStartTicksCount > 0 && this.tickValues[0] !== 0) {
                                this.tickValues.unshift(utils.adjustValue(this.tickValues[0] - this.tickInterval));
                                additionalStartTicksCount--
                            }
                            while (this.tickValues.length < ticksCount)
                                this.tickValues.push(utils.adjustValue(this.tickValues[this.tickValues.length - 1] + this.tickInterval));
                            this.tickInterval = this.tickInterval / ticksMultiplier
                        }
                        this.baseTickValue = this.tickValues[0];
                        this.invertedBaseTickValue = this.tickValues[this.tickValues.length - 1]
                    }
                })
            };
        var getAxisRange = function(axisInfo) {
                return axisInfo.maxValue - axisInfo.minValue
            };
        var getMainAxisInfo = function(axesInfo) {
                var i;
                for (i = 0; i < axesInfo.length; i++)
                    if (!axesInfo[i].stubData)
                        return axesInfo[i];
                return null
            };
        var correctMinMaxValues = function(axesInfo) {
                var mainAxisInfo = getMainAxisInfo(axesInfo);
                $.each(axesInfo, function() {
                    var scale,
                        move,
                        mainAxisBaseValueOffset;
                    if (this !== mainAxisInfo) {
                        if (mainAxisInfo.tickInterval && this.tickInterval) {
                            if (this.stubData && utils.isDefined(this.synchronizedValue)) {
                                this.oldMinValue = this.minValue = this.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfo.tickInterval * this.tickInterval;
                                this.oldMaxValue = this.maxValue = this.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfo.tickInterval * this.tickInterval;
                                this.stubData = false
                            }
                            scale = mainAxisInfo.tickInterval / getAxisRange(mainAxisInfo) / this.tickInterval * getAxisRange(this);
                            this.maxValue = this.minValue + getAxisRange(this) / scale
                        }
                        if (mainAxisInfo.inverted && !this.inverted || !mainAxisInfo.inverted && this.inverted)
                            mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue;
                        else
                            mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue;
                        move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (this.baseTickValue - this.minValue) / getAxisRange(this)) * getAxisRange(this);
                        this.minValue -= move;
                        this.maxValue -= move
                    }
                })
            };
        var calculatePaddings = function(axesInfo) {
                var minPadding,
                    maxPadding,
                    startPadding = 0,
                    endPadding = 0;
                $.each(axesInfo, function() {
                    minPadding = this.minValue > this.oldMinValue ? (this.minValue - this.oldMinValue) / getAxisRange(this) : 0;
                    maxPadding = this.maxValue < this.oldMaxValue ? (this.oldMaxValue - this.maxValue) / getAxisRange(this) : 0;
                    if (this.inverted) {
                        startPadding = Math.max(startPadding, maxPadding);
                        endPadding = Math.max(endPadding, minPadding)
                    }
                    else {
                        startPadding = Math.max(startPadding, minPadding);
                        endPadding = Math.max(endPadding, maxPadding)
                    }
                });
                return {
                        start: startPadding,
                        end: endPadding
                    }
            };
        var correctMinMaxValuesByPaddings = function(axesInfo, paddings) {
                var range;
                $.each(axesInfo, function() {
                    range = getAxisRange(this);
                    if (this.inverted) {
                        this.minValue -= paddings.end * range;
                        this.maxValue += paddings.start * range
                    }
                    else {
                        this.minValue -= paddings.start * range;
                        this.maxValue += paddings.end * range
                    }
                    this.minValue = Math.min(this.minValue, utils.adjustValue(this.minValue));
                    this.maxValue = Math.max(this.maxValue, utils.adjustValue(this.maxValue))
                })
            };
        var updateTickValuesIfSyncronizedValueUsed = function(axesInfo) {
                var hasSyncronizedValue = false;
                $.each(axesInfo, function() {
                    hasSyncronizedValue = hasSyncronizedValue || utils.isDefined(this.synchronizedValue)
                });
                $.each(axesInfo, function() {
                    var lastTickValue;
                    if (hasSyncronizedValue && this.tickInterval) {
                        while (this.tickValues[0] - this.tickInterval >= this.minValue)
                            this.tickValues.unshift(utils.adjustValue(this.tickValues[0] - this.tickInterval));
                        lastTickValue = this.tickValues[this.tickValues.length - 1];
                        while ((lastTickValue = lastTickValue + this.tickInterval) <= this.maxValue)
                            this.tickValues.push(utils.adjustValue(lastTickValue))
                    }
                    while (this.tickValues[0] < this.minValue)
                        this.tickValues.shift();
                    while (this.tickValues[this.tickValues.length - 1] > this.maxValue)
                        this.tickValues.pop()
                })
            };
        var applyMinMaxValues = function(axesInfo, rotated) {
                var axis,
                    range,
                    stubData = rotated && 'stubDataX' || 'stubDataY';
                $.each(axesInfo, function() {
                    axis = this.axis;
                    range = axis.translator.getBusinessRange();
                    if (rotated) {
                        if (range.minX === range.minVisibleX)
                            range.minX = this.minValue;
                        if (range.maxX === range.maxVisibleX)
                            range.maxX = this.maxValue;
                        range.minVisibleX = this.minValue;
                        range.maxVisibleX = this.maxValue
                    }
                    else {
                        if (range.minY === range.minVisibleY)
                            range.minY = this.minValue;
                        if (range.maxY === range.maxVisibleY)
                            range.maxY = this.maxValue;
                        range.minVisibleY = this.minValue;
                        range.maxVisibleY = this.maxValue
                    }
                    if (utils.isDefined(this.stubData))
                        range[stubData] = this.stubData;
                    axis.translator.updateBusinessRange(range);
                    axis.setRange(range);
                    axis.setTickValues(this.tickValues)
                })
            };
        return {synchronize: function(valueAxes, rotated) {
                    var valueAxesPerPanes;
                    valueAxesPerPanes = getValueAxesPerPanes(valueAxes);
                    $.each(valueAxesPerPanes, function(i, axes) {
                        var axesInfo,
                            paddings;
                        if (axes.length > 1) {
                            axesInfo = populateAxesInfo(axes, rotated);
                            if (axesInfo.length === 0 || !getMainAxisInfo(axesInfo))
                                return;
                            updateTickValues(axesInfo);
                            correctMinMaxValues(axesInfo);
                            paddings = calculatePaddings(axesInfo);
                            correctMinMaxValuesByPaddings(axesInfo, paddings);
                            updateTickValuesIfSyncronizedValueUsed(axesInfo);
                            applyMinMaxValues(axesInfo, rotated)
                        }
                    })
                }}
    }())
})(jQuery, DevExpress);

// Module viz, file seriesConsts.js

(function(DX) {
    DX.viz.charts.series.consts = {
        events: {
            mouseover: 'mouseover',
            mouseout: 'mouseout',
            mousemove: 'mousemove',
            click: 'click',
            selectSeries: 'selectseries',
            deselectSeries: 'deselectseries',
            selectPoint: 'selectpoint',
            deselectPoint: 'deselectpoint'
        },
        states: {
            hover: 'hover',
            normal: 'normal',
            selected: 'selected',
            normalMark: 0,
            hoverMark: 1,
            selectedMark: 2
        }
    }
})(DevExpress);

// Module viz, file basePoint.js

(function($, DX) {
    var series = DX.viz.charts.series,
        eventsConsts = series.consts.events,
        statesConsts = series.consts.states,
        utils = DX.utils,
        Class = DX.Class,
        core = DX.viz.core,
        formatHelper = DX.formatHelper,
        CANVAS_POSITION_DEFAULT = 'canvas_position_default';
    var BasePoint = Class.inherit({
            ctor: function(data) {
                var debug = DX.utils.debug;
                debug.assertParam(data, 'data was not passed');
                debug.assertParam(data.options, 'options were not passed');
                this.LABEL_BACKGROUND_PADDING_X = 8;
                this.LABEL_BACKGROUND_PADDING_Y = 4;
                this.LABEL_OFFSET = 10;
                this.rotated = !!data.rotated;
                if (data.options.label && data.options.label.position && data.options.label.position !== 'outside' && data.options.label.position !== 'inside')
                    data.options.label.position = 'outside';
                this.options = data.options;
                this.series = data.series;
                this.value = this.originalValue = data.value;
                this.argument = this.originalArgument = data.argument;
                this.minValue = CANVAS_POSITION_DEFAULT;
                this.labelFormatObject = {
                    argument: this.originalArgument,
                    value: this.originalValue,
                    seriesName: this.options.seriesName
                };
                this.tag = data.tag
            },
            formatLabel: function(options) {
                this.valueText = formatHelper.format(this.value, options.format, options.precision);
                this.argumentText = formatHelper.format(this.argument, options.argumentFormat, options.argumentPrecision);
                if (this.percent !== undefined)
                    this.percentText = formatHelper.format(this.percent, 'percent', options.percentPrecision);
                return options.customizeText ? options.customizeText.call(this, this) : this.valueText
            },
            setOptions: function(options) {
                this.options = options
            },
            translate: function(translator) {
                this.translator = translator = translator || this.translator;
                if (!this.translator || !this.hasValue())
                    return;
                if (!this.rotated) {
                    this.y = translator.translateY(this.value);
                    this.minY = translator.translateY(this.minValue);
                    this.x = translator.translateX(this.argument);
                    this.defaultY = translator.translateY(CANVAS_POSITION_DEFAULT)
                }
                else {
                    this.y = translator.translateY(this.argument);
                    this.x = translator.translateX(this.value);
                    this.minX = translator.translateX(this.minValue);
                    this.defaultX = translator.translateX(CANVAS_POSITION_DEFAULT)
                }
                this.prepareStatesOptions()
            },
            correctValue: function(correction) {
                this.value += correction;
                if (!utils.isNumber(this.minValue))
                    this.minValue = correction;
                else
                    this.minValue += correction;
                this.translate()
            },
            normalizeValue: function(total) {
                this.value = this.value / total || 0;
                if (utils.isNumber(this.minValue)) {
                    this.minValue = this.minValue / total;
                    this.labelFormatObject.percent = this.value - this.minValue
                }
                else
                    this.labelFormatObject.percent = this.value;
                this.translate()
            },
            getCoords: function(min) {
                if (!min)
                    return {
                            x: this.x,
                            y: this.y
                        };
                if (!this.rotated)
                    return {
                            x: this.x,
                            y: this.minY
                        };
                return {
                        x: this.minX,
                        y: this.y
                    }
            },
            getDefaultCoords: function() {
                return !this.rotated ? {
                        x: this.x,
                        y: this.defaultY
                    } : {
                        x: this.defaultX,
                        y: this.y
                    }
            },
            getTooltipCoords: function() {
                if (this.graphic)
                    return {
                            x: this.x,
                            y: this.y,
                            offset: this.graphic.getBBox().height / 2
                        };
                else
                    return {
                            x: this.x,
                            y: this.y,
                            offset: 0
                        }
            },
            drawMarker: function(renderer, group) {
                if (!this.hasValue())
                    return;
                var radius = this.options.attributes.r;
                var states = this.options.states.normal;
                if (this.options.symbol === 'circle') {
                    var circle = renderer.createCircle(this.x, this.y, radius, this.options.attributes);
                    circle.append(group);
                    this.graphic = circle
                }
                if (this.options.symbol === 'square') {
                    var rect = renderer.createArea(this.points, this.options.attributes);
                    rect.append(group);
                    this.graphic = rect
                }
                if (this.options.symbol === 'polygon') {
                    var polygon = renderer.createArea(this.points, this.options.attributes);
                    polygon.append(group);
                    this.graphic = polygon
                }
                if (this.options.symbol === 'triangle') {
                    var triangle = renderer.createArea(this.points, this.options.attributes);
                    triangle.append(group);
                    this.graphic = triangle
                }
                if (this.options.symbol === 'cross') {
                    var cross = renderer.createArea(this.points, this.options.attributes);
                    cross.append(group);
                    this.graphic = cross
                }
                switch (this.state) {
                    case statesConsts.selected:
                        this.series.setPointSelectedState(this);
                        break;
                    case statesConsts.hover:
                        this.series.setPointHoverState(this);
                        break;
                    default:
                        this.state = statesConsts.normal;
                        this.fullState = statesConsts.normalMark
                }
            },
            _trackerAttrs: {
                stroke: 'none',
                fill: 'grey',
                opacity: 0.0001
            },
            storeTrackerR: function() {
                this.options.trackerR = this.options.attributes.r < 10 ? 10 : this.options.attributes.r;
                return this.options.trackerR
            },
            drawTrackerMarker: function(renderer, trackerGroup) {
                if (!this.hasValue())
                    return;
                var point = this;
                var options = point.options;
                var trackerCircle = renderer.createCircle(point.x, point.y, options.trackerR || point.storeTrackerR(), point._trackerAttrs);
                trackerCircle.append(trackerGroup);
                this.initEventTriggering(trackerCircle)
            },
            initEventTriggering: function(svgElement, mode) {
                var point = this,
                    eventParameters = [point, mode];
                svgElement.on({
                    mouseover: function(event) {
                        $(point).trigger(event, eventParameters)
                    },
                    mouseout: function(event) {
                        $(point).trigger(event, point)
                    },
                    mousemove: function(event) {
                        $(point).trigger(event, point)
                    },
                    click: function(event) {
                        $(point).trigger(event, point)
                    }
                })
            },
            select: function() {
                this.series.selectPoint(this)
            },
            clearSelection: function() {
                this.series.deselectPoint(this)
            },
            _populatePointShape: function(target, radius) {
                var self = this;
                if (self.options.symbol === 'square')
                    target.points = [{
                            x: self.x - radius,
                            y: self.y - radius
                        }, {
                            x: self.x + radius,
                            y: self.y - radius
                        }, {
                            x: self.x + radius,
                            y: self.y + radius
                        }, {
                            x: self.x - radius,
                            y: self.y + radius
                        }, {
                            x: self.x - radius,
                            y: self.y - radius
                        }];
                if (self.options.symbol === 'polygon')
                    target.points = [{
                            x: self.x - radius,
                            y: self.y
                        }, {
                            x: self.x,
                            y: self.y - radius
                        }, {
                            x: self.x + radius,
                            y: self.y
                        }, {
                            x: self.x,
                            y: self.y + radius
                        }, {
                            x: self.x - radius,
                            y: self.y
                        }];
                if (self.options.symbol === 'triangle')
                    target.points = [{
                            x: self.x - radius,
                            y: self.y - radius
                        }, {
                            x: self.x + radius,
                            y: self.y - radius
                        }, {
                            x: self.x,
                            y: self.y + radius
                        }, {
                            x: self.x - radius,
                            y: self.y - radius
                        }];
                if (self.options.symbol === 'cross')
                    target.points = [{
                            x: self.x - radius,
                            y: self.y - radius / 2
                        }, {
                            x: self.x - radius / 2,
                            y: self.y - radius
                        }, {
                            x: self.x,
                            y: self.y - radius / 2
                        }, {
                            x: self.x + radius / 2,
                            y: self.y - radius
                        }, {
                            x: self.x + radius,
                            y: self.y - radius / 2
                        }, {
                            x: self.x + radius / 2,
                            y: self.y
                        }, {
                            x: self.x + radius,
                            y: self.y + radius / 2
                        }, {
                            x: self.x + radius / 2,
                            y: self.y + radius
                        }, {
                            x: self.x,
                            y: self.y + radius / 2
                        }, {
                            x: self.x - radius / 2,
                            y: self.y + radius
                        }, {
                            x: self.x - radius,
                            y: self.y + radius / 2
                        }, {
                            x: self.x - radius / 2,
                            y: self.y
                        }, {
                            x: self.x - radius,
                            y: self.y - radius / 2
                        }]
            },
            prepareStatesOptions: function() {
                var self = this;
                if (self.options.states && self.options.states.normal)
                    self._populatePointShape(self, self.options.states.normal.r)
            },
            applyNormalStyle: function() {
                if (this.graphic) {
                    this._populatePointShape(this.options.states.normal, this.options.states.normal.r);
                    this.graphic.applySettings(this.options.states.normal)
                }
                return this
            },
            applyHoverStyle: function() {
                if (this.graphic) {
                    this._populatePointShape(this.options.states.hover, this.options.states.hover.r);
                    this.graphic.applySettings(this.options.states.hover);
                    this.graphic.toForeground()
                }
                return this
            },
            applySelectionStyle: function() {
                if (this.graphic) {
                    this._populatePointShape(this.options.states.selected, this.options.states.selected.r);
                    this.graphic.applySettings(this.options.states.selected)
                }
                return this
            },
            setHoverState: function() {
                this.series.setPointHoverState(this)
            },
            releaseHoverState: function() {
                this.series.releasePointHoverState(this)
            },
            setSelectedState: function(mode) {
                this.series.setPointSelectedState(this)
            },
            releaseSelectedState: function() {
                this.series.releasePointSelectedState(this)
            },
            on: function(events, data, handler) {
                $(this).on(events, data, handler);
                return this
            },
            off: function(events) {
                $(this).off(events);
                return this
            },
            correctLabel: function() {
                this.correctBackgroundPosition();
                this.rotateLabel();
                this.correctLabelPosition()
            },
            drawLabel: function(renderer, group) {
                if (!this.hasValue())
                    return;
                if (!utils.isDefined(this.labelFormatObject.value))
                    return;
                var labelOptions = this.options.label,
                    labelText = this.formatLabel.call(this.labelFormatObject, labelOptions);
                this.labelGroup = renderer.createGroup().append(group);
                if (this.options.label.connector && this.options.label.connector.strokeWidth)
                    this.connector = renderer.createPath([], labelOptions.connector).append(this.labelGroup);
                this.insideLabelGroup = renderer.createGroup().append(this.labelGroup);
                if (labelOptions.background.fill && labelOptions.background.fill !== 'none' || labelOptions.background.strokeWidth && labelOptions.background.stroke && labelOptions.background.stroke !== 'none')
                    this.labelBackground = renderer.createRect(this.x, this.y, 0, 0, 0, labelOptions.background).append(this.insideLabelGroup);
                this.label = renderer.createText(labelText, this.x, this.y, labelOptions.attributes).append(this.insideLabelGroup);
                this.correctLabel();
                this.correctConnectorPosition()
            },
            rotateLabel: function() {
                var bbox = this.insideLabelGroup.getBBox(),
                    labelOptions = this.options.label;
                this.insideLabelGroup.applySettings({
                    x: bbox.x + bbox.width / 2,
                    y: bbox.y + bbox.height / 2,
                    rotate: labelOptions.rotationAngle
                })
            },
            _hideLabel: function(animate) {
                return;
                if (this.labelGroup)
                    this.labelGroup.hide(animate)
            },
            _showLabel: function(animate) {
                return;
                if (this.labelGroup)
                    this.labelGroup.show(animate)
            },
            getGraphicSettings: function() {
                return {
                        x: this.graphic.settings.x || 0,
                        y: this.graphic.settings.y || 0,
                        height: this.graphic.settings.height || 0,
                        width: this.graphic.settings.width || 0
                    }
            },
            correctLabelPosition: function() {
                var bbox = this.insideLabelGroup.getBBox(),
                    bboxgraphic = this.graphic ? this.graphic.getBBox() : {
                        x: this.x,
                        y: this.y,
                        height: 0,
                        width: 0
                    },
                    x = 0,
                    y = 0;
                if (bboxgraphic.isEmpty)
                    bboxgraphic = {
                        x: this.x,
                        y: this.y,
                        height: 0,
                        width: 0
                    };
                if (!this.rotated)
                    if (this.originalValue > 0 || this.series.isFullStackedSeries())
                        y += bboxgraphic.y - bbox.y - bbox.height - this.LABEL_OFFSET;
                    else
                        y += bboxgraphic.y + bboxgraphic.height - bbox.y + this.LABEL_OFFSET;
                else {
                    y += bboxgraphic.y - bbox.y - bbox.height / 2 + bboxgraphic.height / 2;
                    if (this.originalValue > 0 || this.series.isFullStackedSeries())
                        x += bboxgraphic.x + bboxgraphic.width - bbox.x + this.LABEL_OFFSET;
                    else
                        x += bboxgraphic.x - bbox.x - bbox.width - this.LABEL_OFFSET
                }
                x += this.options.label.horizontalOffset;
                y += this.options.label.verticalOffset;
                this.checkLabelPosition({
                    x: bbox.x + x,
                    y: bbox.y + y,
                    height: bbox.height,
                    width: bbox.width
                }, x, y)
            },
            checkLabelPosition: function(bbox, x, y) {
                var bboxgraphic = this.graphic ? this.graphic.getBBox() : {
                        x: this.x,
                        y: this.y,
                        height: 0,
                        width: 0
                    },
                    visibleArea = this.translator.getCanvasVisibleArea();
                if (bboxgraphic.isEmpty)
                    bboxgraphic = {
                        x: this.x,
                        y: this.y,
                        height: 0,
                        width: 0
                    };
                if (!this.rotated)
                    if (visibleArea.minX < bboxgraphic.x + bboxgraphic.width && visibleArea.maxX > bboxgraphic.x) {
                        if (visibleArea.minX > bbox.x && this.adjustSeriesLabels)
                            x += visibleArea.minX - bbox.x;
                        if (visibleArea.maxX < bbox.x + bbox.width && this.adjustSeriesLabels)
                            x -= bbox.x + bbox.width - visibleArea.maxX;
                        if (visibleArea.minY > bbox.y)
                            y += bboxgraphic.y + bboxgraphic.height - bbox.y + this.LABEL_OFFSET;
                        if (visibleArea.maxY < bbox.y + bbox.height)
                            y -= bbox.y + bbox.height - bboxgraphic.y + this.LABEL_OFFSET
                    }
                if (this.rotated)
                    if (visibleArea.minY < bboxgraphic.y + bboxgraphic.height && visibleArea.maxY > bboxgraphic.y) {
                        if (visibleArea.minX > bbox.x)
                            x += bboxgraphic.x + bboxgraphic.width - bbox.x + this.LABEL_OFFSET;
                        if (visibleArea.maxX < bbox.x + bbox.width)
                            x -= bbox.x + bbox.width - bboxgraphic.x + this.LABEL_OFFSET;
                        if (visibleArea.minY > bbox.y && this.adjustSeriesLabels)
                            y += visibleArea.minY - bbox.y;
                        if (visibleArea.maxY < bbox.y + bbox.height && this.adjustSeriesLabels)
                            y -= bbox.y + bbox.height - visibleArea.maxY
                    }
                this.insideLabelGroup.move(~~x, ~~y)
            },
            correctBackgroundPosition: function() {
                if (!this.labelBackground)
                    return;
                var bbox = this.label.getBBox(),
                    x = bbox.x - this.LABEL_BACKGROUND_PADDING_X,
                    y = bbox.y - this.LABEL_BACKGROUND_PADDING_Y,
                    width = bbox.width + 2 * this.LABEL_BACKGROUND_PADDING_X,
                    height = bbox.height + 2 * this.LABEL_BACKGROUND_PADDING_Y;
                this.labelBackground.applySettings({
                    x: x,
                    y: y,
                    width: width,
                    height: height
                })
            },
            correctConnectorPosition: function(bboxgraphic) {
                var bbox = this.insideLabelGroup.getBBox(),
                    bboxgraphic = bboxgraphic || (this.graphic ? this.graphic.getBBox() : {
                        x: this.x,
                        y: this.y,
                        height: 0,
                        width: 0
                    }),
                    x1,
                    x2,
                    y1,
                    y2,
                    centerLabelY,
                    centerLabelX;
                if (!this.connector)
                    return;
                if (bboxgraphic.isEmpty)
                    bboxgraphic = {
                        x: this.x,
                        y: this.y,
                        height: 0,
                        width: 0
                    };
                bbox.x = bbox.x + (this.insideLabelGroup.settings.translateX || 0);
                bbox.y = bbox.y + (this.insideLabelGroup.settings.translateY || 0);
                centerLabelY = this.labelBackground ? bbox.y + bbox.height / 2 : null;
                centerLabelX = this.labelBackground ? bbox.x + bbox.width / 2 : null;
                if (!this.rotated) {
                    if ((centerLabelY || bbox.y + bbox.height) < bboxgraphic.y) {
                        y1 = centerLabelY || bbox.y + bbox.height;
                        y2 = bboxgraphic.y
                    }
                    else if ((centerLabelY || bbox.y) > bboxgraphic.y + bboxgraphic.height) {
                        y1 = centerLabelY || bbox.y;
                        y2 = bboxgraphic.y + bboxgraphic.height
                    }
                    else
                        return;
                    x1 = Math.round(bbox.x + bbox.width / 2);
                    if (x1 > bboxgraphic.x + bboxgraphic.width)
                        x2 = bboxgraphic.x + bboxgraphic.width;
                    else if (x1 < bboxgraphic.x)
                        x2 = bboxgraphic.x;
                    else
                        x2 = x1
                }
                else {
                    if ((centerLabelX || bbox.x) > bboxgraphic.x + bboxgraphic.width) {
                        x1 = centerLabelX || bbox.x;
                        x2 = bboxgraphic.x + bboxgraphic.width
                    }
                    else if ((centerLabelX || bbox.x + bbox.width) < bboxgraphic.x) {
                        x1 = centerLabelX || bbox.x + bbox.width;
                        x2 = bboxgraphic.x
                    }
                    else
                        return;
                    y1 = Math.round(bbox.y + bbox.height / 2);
                    if (y1 > bboxgraphic.y + bboxgraphic.height)
                        y2 = bboxgraphic.y + bboxgraphic.height;
                    else if (y1 < bboxgraphic.y)
                        y2 = bboxgraphic.y;
                    else
                        y2 = y1
                }
                this.connector.applySettings({points: [x1, y1, x2, y2]})
            },
            getColor: function() {
                return this.options.attributes.fill
            },
            getTooltipFormatObject: function(tooltip) {
                var value = tooltip.formatValueTooltip.call({value: this.originalValue}, tooltip.options);
                return $.extend({}, this.labelFormatObject, {
                        point: this,
                        valueText: value
                    })
            },
            animate: function() {
                var self = this,
                    translator = self.translator,
                    graphic = self.graphic;
                if (!graphic || !translator)
                    return;
                self._hideLabel();
                if (!self.rotated)
                    graphic.move(0, self.defaultY - self.y);
                else
                    graphic.move(self.defaultX - self.x, 0);
                graphic.move(0, 0, true, {complete: function() {
                        self._showLabel(true)
                    }})
            },
            hasValue: function() {
                return this.originalValue !== null
            }
        });
    series.BasePoint = BasePoint
})(jQuery, DevExpress);

// Module viz, file barPoint.js

(function($, DX) {
    var series = DX.viz.charts.series,
        statesConsts = series.consts.states,
        BasePoint = series.BasePoint,
        CANVAS_POSITION_DEFAULT = 'canvas_position_default';
    var BarPoint = BasePoint.inherit({
            translate: function(translator) {
                this.translator = translator = translator || this.translator;
                if (!this.translator || !this.hasValue())
                    return;
                if (!this.rotated) {
                    var minY = translator.translateY(this.minValue);
                    var y = translator.translateY(this.value);
                    var x = translator.translateX(this.argument);
                    this.height = Math.abs(minY - y);
                    this.x = x + (this.xCorrection || 0);
                    this.y = Math.min(y, minY) + (this.yCorrection || 0);
                    this.minY = minY + (this.yCorrection || 0);
                    this.defaultY = translator.translateY(CANVAS_POSITION_DEFAULT)
                }
                else {
                    var minX = translator.translateX(this.minValue);
                    var y = translator.translateY(this.argument);
                    var x = translator.translateX(this.value);
                    this.width = Math.abs(x - minX);
                    this.y = y + (this.yCorrection || 0);
                    this.x = Math.min(minX, x) + (this.xCorrection || 0);
                    this.minX = minX + (this.minXCorrection || 0);
                    this.defaultX = translator.translateX(CANVAS_POSITION_DEFAULT)
                }
            },
            getTooltipCoords: function() {
                return {
                        x: this.x + this.width / 2,
                        y: this.y + this.height / 2,
                        offset: 0
                    }
            },
            correctCoordinates: function(correctOptions) {
                var correction = correctOptions.offset - Math.round(correctOptions.width / 2);
                if (!this.rotated) {
                    this.width = correctOptions.width;
                    this.xCorrection = correction;
                    this.minXCorrection = correction
                }
                else {
                    this.height = correctOptions.width;
                    this.yCorrection = correction;
                    this.minYCorrection = correction
                }
            },
            drawMarker: function(renderer, group) {
                var attributes,
                    rect;
                if (!this.hasValue())
                    return;
                switch (this.state) {
                    case statesConsts.hover:
                        attributes = this.options.states.hover;
                        break;
                    case statesConsts.selected:
                        attributes = this.options.states.selected;
                        break;
                    default:
                        attributes = this.options.attributes;
                        this.state = statesConsts.normal;
                        this.fullState = statesConsts.normalMark
                }
                rect = renderer.createRect(this.x, this.y, this.width, this.height, attributes.r, attributes);
                rect.append(group);
                this.graphic = rect
            },
            drawTrackerMarker: function(renderer, trackerGroup) {
                if (!this.hasValue())
                    return;
                var point = this,
                    y = point.y,
                    height = point.height,
                    x = point.x,
                    width = point.width;
                if (point.rotated) {
                    if (width === 1) {
                        width = 9;
                        x -= 4
                    }
                }
                else if (height === 1) {
                    height = 9;
                    y -= 4
                }
                var options = point.options;
                var trackerRect = renderer.createRect(x, y, width, height, options.attributes.r, {
                        stroke: 'none',
                        fill: 'grey',
                        opacity: 0.0001
                    });
                trackerRect.append(trackerGroup);
                this.initEventTriggering(trackerRect)
            },
            correctConnectorPosition: function() {
                this.callBase(this.getBboxGraphic())
            },
            drawLabel: function(renderer, group) {
                if (!this.hasValue() || !this.options.label.showForZeroValues && !this.labelFormatObject.value)
                    return;
                else
                    this.callBase(renderer, group)
            },
            getBboxGraphic: function() {
                var bboxgraphic = this.graphic && this.graphic.getBBox(),
                    deltaX,
                    deltaY;
                if (bboxgraphic.isEmpty)
                    bboxgraphic = this.getGraphicSettings();
                deltaX = bboxgraphic.x - this.x;
                deltaY = bboxgraphic.y - this.y;
                bboxgraphic.x -= deltaX;
                bboxgraphic.y -= deltaY;
                bboxgraphic.width += 2 * deltaX;
                bboxgraphic.height += 2 * deltaY;
                return bboxgraphic
            },
            correctLabelPosition: function() {
                var bbox = this.insideLabelGroup.getBBox(),
                    bboxgraphic = this.getBboxGraphic(),
                    x = 0,
                    y = 0;
                if (this.options.label.position === 'outside')
                    if (!this.rotated) {
                        x += bboxgraphic.width / 2;
                        if (this.originalValue > 0 || this.series.isFullStackedSeries())
                            y += bboxgraphic.y - bbox.y - bbox.height - this.LABEL_OFFSET;
                        else
                            y += bboxgraphic.y + bboxgraphic.height - bbox.y + this.LABEL_OFFSET
                    }
                    else {
                        y += bboxgraphic.y - bbox.y - bbox.height / 2 + bboxgraphic.height / 2;
                        if (this.originalValue > 0 || this.series.isFullStackedSeries())
                            x += bboxgraphic.x + bboxgraphic.width - bbox.x + this.LABEL_OFFSET;
                        else
                            x += bboxgraphic.x - bbox.x - bbox.width - this.LABEL_OFFSET
                    }
                else if (this.options.label.position === 'inside')
                    if (!this.rotated) {
                        x += bboxgraphic.width / 2;
                        if (this.originalValue > 0 || this.series.isFullStackedSeries())
                            y += bboxgraphic.y - bbox.y - bbox.height + this.LABEL_OFFSET + bbox.height;
                        else
                            y += bboxgraphic.y + bboxgraphic.height - bbox.y - this.LABEL_OFFSET - bbox.height
                    }
                    else {
                        y += bboxgraphic.y - bbox.y - bbox.height / 2 + bboxgraphic.height / 2;
                        if (this.originalValue > 0 || this.series.isFullStackedSeries())
                            x += bboxgraphic.x + bboxgraphic.width - bbox.x - bbox.width - this.LABEL_OFFSET;
                        else
                            x += bboxgraphic.x - bbox.x + this.LABEL_OFFSET
                    }
                x += this.options.label.horizontalOffset;
                y += this.options.label.verticalOffset;
                this.checkLabelPosition({
                    x: bbox.x + x,
                    y: bbox.y + y,
                    height: bbox.height,
                    width: bbox.width
                }, x, y, bboxgraphic)
            },
            checkLabelPosition: function(bbox, x, y, bboxgraphic) {
                var bboxgraphic = bboxgraphic || this.graphic.getBBox(),
                    visibleArea = this.translator.getCanvasVisibleArea();
                if (bboxgraphic.isEmpty)
                    bboxgraphic = this.getGraphicSettings();
                if (!this.rotated)
                    if (visibleArea.minX < bboxgraphic.x + bboxgraphic.width && visibleArea.maxX > bboxgraphic.x) {
                        if (visibleArea.minX > bbox.x && this.adjustSeriesLabels)
                            x += visibleArea.minX - bbox.x;
                        if (visibleArea.maxX < bbox.x + bbox.width && this.adjustSeriesLabels)
                            x -= bbox.x + bbox.width - visibleArea.maxX;
                        if (visibleArea.minY > bbox.y)
                            y += bboxgraphic.y - bbox.y + this.LABEL_OFFSET;
                        if (visibleArea.maxY < bbox.y + bbox.height)
                            y -= bbox.y + bbox.height - bboxgraphic.y - bboxgraphic.height + this.LABEL_OFFSET
                    }
                if (this.rotated)
                    if (visibleArea.minY < bboxgraphic.y + bboxgraphic.height && visibleArea.maxY > bboxgraphic.y) {
                        if (visibleArea.minX > bbox.x)
                            x += bboxgraphic.x - bbox.x + this.LABEL_OFFSET;
                        if (visibleArea.maxX < bbox.x + bbox.width)
                            x -= bbox.x + bbox.width - bboxgraphic.x - bboxgraphic.width + this.LABEL_OFFSET;
                        if (visibleArea.minY > bbox.y && this.adjustSeriesLabels)
                            y += visibleArea.minY - bbox.y;
                        if (visibleArea.maxY < bbox.y + bbox.height && this.adjustSeriesLabels)
                            y -= bbox.y + bbox.height - visibleArea.maxY
                    }
                this.insideLabelGroup.move(~~x, ~~y)
            },
            animate: function() {
                var self = this,
                    translator = self.translator,
                    graphic = self.graphic;
                if (!graphic || !translator)
                    return;
                self._hideLabel();
                if (!self.rotated) {
                    var startY = self.defaultY;
                    var startHeight = 0;
                    var endHeight = self.height;
                    var endY = self.y;
                    graphic.applySettings({
                        height: startHeight,
                        y: startY,
                        sharpEdges: false
                    });
                    graphic.animate({
                        height: endHeight,
                        y: endY
                    }, {complete: function() {
                            self._showLabel(true)
                        }})
                }
                else {
                    var startX = self.defaultX;
                    var startWidth = 0;
                    var endWidth = self.width;
                    var endX = self.x;
                    graphic.applySettings({
                        width: startWidth,
                        x: startX,
                        sharpEdges: false
                    });
                    graphic.animate({
                        width: endWidth,
                        x: endX
                    }, {complete: function() {
                            self._showLabel(true)
                        }})
                }
            }
        });
    series.BarPoint = BarPoint
})(jQuery, DevExpress);

// Module viz, file ohlcPoint.js

(function($, DX) {
    var series = DX.viz.charts.series,
        utils = DX.utils,
        core = DX.viz.core,
        BasePoint = series.BasePoint,
        statesConsts = series.consts.states,
        formatHelper = DX.formatHelper;
    var OhlcPoint = BasePoint.inherit({
            ctor: function(data) {
                var debug = DX.utils.debug;
                debug.assertParam(data, 'data was not passed');
                debug.assertParam(data.options, 'options were not passed');
                this.LABEL_BACKGROUND_PADDING_X = 8;
                this.LABEL_BACKGROUND_PADDING_Y = 4;
                this.LABEL_OFFSET = 10;
                this.argument = this.originalArgument = data.argument;
                this.openValue = data.openValue;
                this.highValue = data.highValue;
                this.lowValue = data.lowValue;
                this.closeValue = data.closeValue;
                this.originalValue = data.reductionValue;
                this.tag = data.tag;
                this.options = data.options;
                this.series = data.series;
                this.rotated = !!(this.series && this.series.options && this.series.options.rotated || false);
                this.labelFormatObject = {
                    openValue: this.openValue,
                    highValue: this.highValue,
                    lowValue: this.lowValue,
                    closeValue: this.closeValue,
                    reductionValue: this.originalValue,
                    argument: this.originalArgument,
                    value: this.originalValue,
                    seriesName: this.options.seriesName
                }
            },
            formatLabel: function(options) {
                this.openValueText = formatHelper.format(this.openValue, options.format, options.precision);
                this.highValueText = formatHelper.format(this.highValue, options.format, options.precision);
                this.lowValueText = formatHelper.format(this.lowValue, options.format, options.precision);
                this.closeValueText = formatHelper.format(this.closeValue, options.format, options.precision);
                this.reductionValueText = formatHelper.format(this.reductionValue, options.format, options.precision);
                this.valueText = formatHelper.format(this.value, options.format, options.precision);
                this.argumentText = formatHelper.format(this.argument, options.argumentFormat, options.argumentPrecision);
                return options.customizeText ? options.customizeText.call(this, this) : this.valueText
            },
            translate: function(translator) {
                var rotated = this.rotated,
                    translateArg = rotated ? 'translateY' : 'translateX',
                    translateVal = rotated ? 'translateX' : 'translateY';
                this.translator = translator = translator || this.translator;
                if (!this.translator || !this.hasValue())
                    return;
                var openY = translator[translateVal](this.openValue);
                var highY = translator[translateVal](this.highValue);
                var lowY = translator[translateVal](this.lowValue);
                var closeY = translator[translateVal](this.closeValue);
                var x = translator[translateArg](this.argument);
                this.width = 10;
                this.x = x;
                this.openY = openY;
                this.highY = highY;
                this.lowY = lowY;
                this.closeY = closeY
            },
            drawMarker: function(renderer, group) {
                if (!this.hasValue())
                    return;
                var self = this,
                    path,
                    attributes,
                    rotated = this.rotated,
                    createPoint = rotated ? function(x, y) {
                        return {
                                x: y,
                                y: x
                            }
                    } : function(x, y) {
                        return {
                                x: x,
                                y: y
                            }
                    };
                switch (this.state) {
                    case statesConsts.selected:
                        attributes = this.options.states.selected;
                        break;
                    case statesConsts.hover:
                        attributes = this.options.states.hover;
                        break;
                    default:
                        attributes = this.options.attributes;
                        this.state = statesConsts.normal;
                        this.fullState = statesConsts.normalMark
                }
                if (self.openValue > self.closeValue)
                    path = renderer.createPath([createPoint(self.x, self.highY), createPoint(self.x, self.openY), createPoint(self.x + self.width / 2, self.openY), createPoint(self.x + self.width / 2, self.closeY), createPoint(self.x, self.closeY), createPoint(self.x, self.lowY), createPoint(self.x, self.closeY), createPoint(self.x - self.width / 2, self.closeY), createPoint(self.x - self.width / 2, self.openY), createPoint(self.x, self.openY)], attributes).append(group);
                else if (self.openValue < self.closeValue)
                    path = renderer.createPath([createPoint(self.x, self.highY), createPoint(self.x, self.closeY), createPoint(self.x + self.width / 2, self.closeY), createPoint(self.x + self.width / 2, self.openY), createPoint(self.x, self.openY), createPoint(self.x, self.lowY), createPoint(self.x, self.openY), createPoint(self.x - self.width / 2, self.openY), createPoint(self.x - self.width / 2, self.closeY), createPoint(self.x, self.closeY)], attributes).append(group);
                else if (self.openValue === self.closeValue)
                    path = renderer.createPath([createPoint(self.x, self.highY), createPoint(self.x, self.lowY), createPoint(self.x, self.closeY), createPoint(self.x - self.width / 2, self.closeY), createPoint(self.x + self.width / 2, self.closeY), createPoint(self.x, self.closeY)], attributes).append(group);
                this.graphic = path
            },
            drawTrackerMarker: function(renderer, trackerGroup) {
                if (!this.hasValue())
                    return;
                var point = this,
                    highY = point.highY,
                    lowY = point.lowY;
                if (highY === lowY) {
                    highY -= 2;
                    lowY += 2
                }
                if (!this.rotated)
                    var trackerRect = renderer.createRect(point.x - point.width / 2, highY, point.width, lowY - highY, 0, {
                            stroke: 'none',
                            fill: 'grey',
                            opacity: 0.0001
                        });
                else
                    var trackerRect = renderer.createRect(lowY, point.x - point.width / 2, highY - lowY, point.width, 0, {
                            stroke: 'none',
                            fill: 'grey',
                            opacity: 0.0001
                        });
                trackerRect.append(trackerGroup);
                this.initEventTriggering(trackerRect)
            },
            animate: function(){},
            drawLabel: function(renderer, group) {
                if (!this.hasValue())
                    return;
                if (!utils.isDefined(this.labelFormatObject.value))
                    return;
                var labelOptions = this.options.label,
                    labelText = this.formatLabel.call(this.labelFormatObject, labelOptions),
                    rotated = this.rotated;
                this.labelGroup = renderer.createGroup().append(group);
                this.insideLabelGroup = renderer.createGroup().append(this.labelGroup);
                if (labelOptions.background.fill && labelOptions.background.fill !== 'none' || labelOptions.background.strokeWidth && labelOptions.background.stroke && labelOptions.background.stroke !== 'none') {
                    labelOptions.background.fill = this.options.attributes.stroke;
                    this.labelBackground = rotated ? renderer.createRect(this.highY, this.x, 0, 0, 0, labelOptions.background).append(this.insideLabelGroup) : renderer.createRect(this.x, this.highY, 0, 0, 0, labelOptions.background).append(this.insideLabelGroup)
                }
                this.label = rotated ? renderer.createText(labelText, this.highY, this.x, labelOptions.attributes).append(this.insideLabelGroup) : renderer.createText(labelText, this.x, this.highY, labelOptions.attributes).append(this.insideLabelGroup);
                this.correctBackgroundPosition();
                this.rotateLabel();
                this.correctLabelPosition()
            },
            correctLabelPosition: function() {
                var bbox = this.insideLabelGroup.getBBox(),
                    bboxgraphic = this.graphic.getBBox(),
                    rotated = this.rotated,
                    x = 0,
                    y = 0;
                if (!rotated)
                    y += bboxgraphic.y - bbox.y - bbox.height - this.LABEL_OFFSET;
                else
                    x += bboxgraphic.x - bbox.x + bboxgraphic.width + this.LABEL_OFFSET;
                x += this.options.label.horizontalOffset;
                y += this.options.label.verticalOffset;
                this.checkLabelPosition({
                    x: bbox.x + x,
                    y: bbox.y + y,
                    height: bbox.height,
                    width: bbox.width
                }, x, y)
            },
            checkLabelPosition: function(bbox, x, y) {
                var visibleArea = this.translator.getCanvasVisibleArea(),
                    bboxgraphic = this.graphic.getBBox();
                if (visibleArea.minX < bboxgraphic.x + bboxgraphic.width && visibleArea.maxX > bboxgraphic.x) {
                    if (visibleArea.minX > bbox.x && this.adjustSeriesLabels)
                        x += visibleArea.minX - bbox.x;
                    if (visibleArea.maxX < bbox.x + bbox.width && this.adjustSeriesLabels)
                        x -= bbox.x + bbox.width - visibleArea.maxX;
                    if (visibleArea.minY > bbox.y)
                        y += visibleArea.minY - bbox.y;
                    if (visibleArea.maxY < bbox.y + bbox.height)
                        y -= bbox.y + bbox.height - visibleArea.maxY
                }
                this.insideLabelGroup.move(~~x, ~~y)
            },
            getTooltipCoords: function() {
                if (this.graphic)
                    return {
                            x: this.x,
                            y: this.lowY + (this.highY - this.lowY) / 2,
                            offset: 0
                        }
            },
            getTooltipFormatObject: function(tooltip) {
                var highValue = tooltip.formatValueTooltip.call({value: this.highValue}, tooltip.options),
                    openValue = tooltip.formatValueTooltip.call({value: this.openValue}, tooltip.options),
                    closeValue = tooltip.formatValueTooltip.call({value: this.closeValue}, tooltip.options),
                    lowValue = tooltip.formatValueTooltip.call({value: this.lowValue}, tooltip.options);
                return {
                        argument: this.originalArgument,
                        valueText: 'h: ' + highValue + ' o: ' + openValue + ' c: ' + closeValue + ' l: ' + lowValue,
                        highValueText: highValue,
                        openValueText: openValue,
                        closeValueText: closeValue,
                        lowValueText: lowValue,
                        highValue: this.highValue,
                        openValue: this.openValue,
                        closeValue: this.closeValue,
                        lowValue: this.lowValue,
                        seriesName: this.options.seriesName,
                        point: this
                    }
            },
            getColor: function() {
                return this.options.attributes.stroke
            },
            hasValue: function() {
                return this.openValue !== null && this.closeValue !== null && this.highValue !== null && this.lowValue !== null
            }
        });
    series.OhlcPoint = OhlcPoint
})(jQuery, DevExpress);

// Module viz, file stockPoint.js

(function($, DX) {
    var series = DX.viz.charts.series,
        statesConsts = series.consts.states,
        OhlcPoint = series.OhlcPoint;
    var StockPoint = OhlcPoint.inherit({
            ctor: function(data) {
                this.callBase(data)
            },
            drawMarker: function(renderer, group) {
                var self = this,
                    path,
                    attributes,
                    rotated = this.rotated,
                    createPoint = rotated ? function(x, y) {
                        return {
                                x: y,
                                y: x
                            }
                    } : function(x, y) {
                        return {
                                x: x,
                                y: y
                            }
                    };
                if (!self.hasValue())
                    return;
                switch (this.state) {
                    case statesConsts.selected:
                        attributes = this.options.states.selected;
                        break;
                    case statesConsts.hover:
                        attributes = this.options.states.hover;
                        break;
                    default:
                        attributes = this.options.attributes;
                        this.state = statesConsts.normal;
                        this.fullState = statesConsts.normalMark
                }
                path = renderer.createPath([createPoint(self.x, self.highY), createPoint(self.x, self.openY), createPoint(self.x - self.width / 2, self.openY), createPoint(self.x, self.openY), createPoint(self.x, self.closeY), createPoint(self.x + self.width / 2, self.closeY), createPoint(self.x, self.closeY), createPoint(self.x, self.lowY)], attributes).append(group);
                this.graphic = path
            }
        });
    series.StockPoint = StockPoint
})(jQuery, DevExpress);

// Module viz, file rangePoint.js

(function($, DX) {
    var series = DX.viz.charts.series,
        utils = DX.utils,
        eventsConsts = series.consts.events,
        statesConsts = series.consts.states,
        BasePoint = series.BasePoint;
    var RangePoint = BasePoint.inherit({
            ctor: function(data) {
                this.callBase(data);
                this.minValue = this.originalMinValue = data.minValue !== undefined ? data.minValue : 'default';
                this.minLabelFormatObject = {
                    argument: this.originalArgument,
                    value: this.originalMinValue,
                    seriesName: this.options.seriesName
                }
            },
            getTooltipCoords: function() {
                var x,
                    y;
                if (!this.rotated) {
                    x = this.x;
                    y = Math.min(this.y, this.minY) + this.height / 2
                }
                else {
                    x = Math.min(this.x, this.minX) + this.width / 2;
                    y = this.y
                }
                return {
                        x: x,
                        y: y,
                        offset: 0
                    }
            },
            translate: function(translator) {
                if (!this.hasValue())
                    return;
                this.callBase(translator);
                if (!this.rotated) {
                    this.height = Math.abs(this.minY - this.y);
                    this.width = 0
                }
                else {
                    this.width = Math.abs(this.x - this.minX);
                    this.height = 0
                }
            },
            drawMarker: function(renderer, group) {
                if (!this.hasValue())
                    return;
                var radius = this.options.attributes.r,
                    topMarker,
                    x,
                    y,
                    bottomMarker;
                this.markerGroup = renderer.createGroup().append(group);
                if (this.options.symbol === 'circle') {
                    if (!this.rotated) {
                        x = this.x;
                        y = Math.min(this.y, this.minY)
                    }
                    else {
                        x = Math.min(this.x, this.minX);
                        y = this.y
                    }
                    topMarker = renderer.createCircle(x + this.width, y, radius, this.options.attributes).append(this.markerGroup);
                    bottomMarker = renderer.createCircle(x, y + this.height, radius, this.options.attributes).append(this.markerGroup)
                }
                if (this.options.symbol === 'square') {
                    topMarker = renderer.createArea(this.topPoints, this.options.attributes).append(this.markerGroup);
                    bottomMarker = renderer.createArea(this.bottomPoints, this.options.attributes).append(this.markerGroup)
                }
                if (this.options.symbol === 'polygon') {
                    topMarker = renderer.createArea(this.topPoints, this.options.attributes).append(this.markerGroup);
                    bottomMarker = renderer.createArea(this.bottomPoints, this.options.attributes).append(this.markerGroup)
                }
                if (this.options.symbol === 'triangle') {
                    topMarker = renderer.createArea(this.topPoints, this.options.attributes).append(this.markerGroup);
                    bottomMarker = renderer.createArea(this.bottomPoints, this.options.attributes).append(this.markerGroup)
                }
                if (this.options.symbol === 'cross') {
                    topMarker = renderer.createArea(this.topPoints, this.options.attributes).append(this.markerGroup);
                    bottomMarker = renderer.createArea(this.bottomPoints, this.options.attributes).append(this.markerGroup)
                }
                this.graphic = this.markerGroup;
                this.graphic.topMarker = topMarker;
                this.graphic.bottomMarker = bottomMarker;
                this.state = statesConsts.normal
            },
            _populatePointShape: function(target, radius) {
                var self = this,
                    topX,
                    topY,
                    bottomX,
                    bottomY;
                if (!this.rotated) {
                    topX = bottomX = self.x;
                    topY = Math.min(self.y, self.minY);
                    bottomY = Math.max(self.y, self.minY)
                }
                else {
                    topX = Math.max(self.x, self.minX);
                    bottomX = Math.min(self.x, self.minX);
                    topY = bottomY = self.y
                }
                if (self.options.symbol === 'square') {
                    target.topPoints = [{
                            x: topX - radius,
                            y: topY - radius
                        }, {
                            x: topX + radius,
                            y: topY - radius
                        }, {
                            x: topX + radius,
                            y: topY + radius
                        }, {
                            x: topX - radius,
                            y: topY + radius
                        }, {
                            x: topX - radius,
                            y: topY - radius
                        }];
                    target.bottomPoints = [{
                            x: bottomX - radius,
                            y: bottomY - radius
                        }, {
                            x: bottomX + radius,
                            y: bottomY - radius
                        }, {
                            x: bottomX + radius,
                            y: bottomY + radius
                        }, {
                            x: bottomX - radius,
                            y: bottomY + radius
                        }, {
                            x: bottomX - radius,
                            y: bottomY - radius
                        }]
                }
                if (self.options.symbol === 'polygon') {
                    target.topPoints = [{
                            x: topX - radius,
                            y: topY
                        }, {
                            x: topX,
                            y: topY - radius
                        }, {
                            x: topX + radius,
                            y: topY
                        }, {
                            x: topX,
                            y: topY + radius
                        }, {
                            x: topX - radius,
                            y: topY
                        }];
                    target.bottomPoints = [{
                            x: bottomX - radius,
                            y: bottomY
                        }, {
                            x: bottomX,
                            y: bottomY - radius
                        }, {
                            x: bottomX + radius,
                            y: bottomY
                        }, {
                            x: bottomX,
                            y: bottomY + radius
                        }, {
                            x: bottomX - radius,
                            y: bottomY
                        }]
                }
                if (self.options.symbol === 'triangle') {
                    target.topPoints = [{
                            x: topX - radius,
                            y: topY - radius
                        }, {
                            x: topX + radius,
                            y: topY - radius
                        }, {
                            x: topX,
                            y: topY + radius
                        }, {
                            x: topX - radius,
                            y: topY - radius
                        }];
                    target.bottomPoints = [{
                            x: bottomX - radius,
                            y: bottomY - radius
                        }, {
                            x: bottomX + radius,
                            y: bottomY - radius
                        }, {
                            x: bottomX,
                            y: bottomY + radius
                        }, {
                            x: bottomX - radius,
                            y: bottomY - radius
                        }]
                }
                if (self.options.symbol === 'cross') {
                    target.topPoints = [{
                            x: topX - radius,
                            y: topY - radius / 2
                        }, {
                            x: topX - radius / 2,
                            y: topY - radius
                        }, {
                            x: topX,
                            y: topY - radius / 2
                        }, {
                            x: topX + radius / 2,
                            y: topY - radius
                        }, {
                            x: topX + radius,
                            y: topY - radius / 2
                        }, {
                            x: topX + radius / 2,
                            y: topY
                        }, {
                            x: topX + radius,
                            y: topY + radius / 2
                        }, {
                            x: topX + radius / 2,
                            y: topY + radius
                        }, {
                            x: topX,
                            y: topY + radius / 2
                        }, {
                            x: topX - radius / 2,
                            y: topY + radius
                        }, {
                            x: topX - radius,
                            y: topY + radius / 2
                        }, {
                            x: topX - radius / 2,
                            y: topY
                        }, {
                            x: topX - radius,
                            y: topY - radius / 2
                        }];
                    target.bottomPoints = [{
                            x: bottomX - radius,
                            y: bottomY - radius / 2
                        }, {
                            x: bottomX - radius / 2,
                            y: bottomY - radius
                        }, {
                            x: bottomX,
                            y: bottomY - radius / 2
                        }, {
                            x: bottomX + radius / 2,
                            y: bottomY - radius
                        }, {
                            x: bottomX + radius,
                            y: bottomY - radius / 2
                        }, {
                            x: bottomX + radius / 2,
                            y: bottomY
                        }, {
                            x: bottomX + radius,
                            y: bottomY + radius / 2
                        }, {
                            x: bottomX + radius / 2,
                            y: bottomY + radius
                        }, {
                            x: bottomX,
                            y: bottomY + radius / 2
                        }, {
                            x: bottomX - radius / 2,
                            y: bottomY + radius
                        }, {
                            x: bottomX - radius,
                            y: bottomY + radius / 2
                        }, {
                            x: bottomX - radius / 2,
                            y: bottomY
                        }, {
                            x: bottomX - radius,
                            y: bottomY - radius / 2
                        }]
                }
            },
            drawTrackerMarker: function(renderer, trackerGroup) {
                if (!this.hasValue())
                    return;
                var point = this,
                    options = point.options,
                    radius = options.trackerR || point.storeTrackerR(),
                    x,
                    y;
                if (!this.rotated) {
                    x = this.x - radius;
                    y = Math.min(this.y, this.minY) - radius
                }
                else {
                    x = Math.min(this.x, this.minX) - radius;
                    y = this.y - radius
                }
                var trackerRect = renderer.createRect(x, y, point.width + 2 * radius, point.height + 2 * radius, 0, point._trackerAttrs);
                trackerRect.append(trackerGroup);
                this.initEventTriggering(trackerRect)
            },
            applyNormalStyle: function() {
                var normal = this.options.states.normal;
                if (this.graphic) {
                    this._populatePointShape(normal, normal.r);
                    this.graphic.topMarker.applySettings(normal.topPoints ? {
                        points: normal.topPoints,
                        style: normal
                    } : normal);
                    this.graphic.bottomMarker.applySettings(normal.bottomPoints ? {
                        points: normal.bottomPoints,
                        style: normal
                    } : normal)
                }
                return this.callBase()
            },
            applyHoverStyle: function() {
                var hover = this.options.states.hover;
                if (this.graphic) {
                    this._populatePointShape(hover, hover.r);
                    this.graphic.topMarker.applySettings(hover.topPoints ? {
                        points: hover.topPoints,
                        style: hover
                    } : hover);
                    this.graphic.bottomMarker.applySettings(hover.bottomPoints ? {
                        points: hover.bottomPoints,
                        style: hover
                    } : hover)
                }
                return this.callBase()
            },
            applySelectionStyle: function() {
                var selected = this.options.states.selected;
                if (this.graphic) {
                    this._populatePointShape(selected, selected.r);
                    this.graphic.topMarker.applySettings(selected.topPoints ? {
                        points: selected.topPoints,
                        style: selected
                    } : selected);
                    this.graphic.bottomMarker.applySettings(selected.bottomPoints ? {
                        points: selected.bottomPoints,
                        style: selected
                    } : selected)
                }
                return this.callBase()
            },
            drawLabel: function(renderer, group) {
                if (!this.hasValue())
                    return;
                if (!utils.isDefined(this.labelFormatObject.value) || !utils.isDefined(this.minLabelFormatObject.value))
                    return;
                var labelOptions = this.options.label,
                    maxLabelText = this.formatLabel.call(this.labelFormatObject, labelOptions),
                    minLabelText = this.formatLabel.call(this.minLabelFormatObject, labelOptions);
                this.labelGroup = renderer.createGroup().append(group);
                if (this.options.label.connector && this.options.label.connector.strokeWidth) {
                    this.maxConnector = renderer.createLine(0, 0, 0, 0, this.options.label.connector).append(this.labelGroup);
                    this.minConnector = renderer.createLine(0, 0, 0, 0, this.options.label.connector).append(this.labelGroup)
                }
                this.maxLabelGroup = renderer.createGroup().append(this.labelGroup);
                this.insideMaxLabelGroup = renderer.createGroup().append(this.maxLabelGroup);
                this.minLabelGroup = renderer.createGroup().append(this.labelGroup);
                this.insideMinLabelGroup = renderer.createGroup().append(this.minLabelGroup);
                if (labelOptions.background.fill && labelOptions.background.fill !== 'none' || labelOptions.background.strokeWidth && labelOptions.background.stroke && labelOptions.background.stroke !== 'none') {
                    this.maxLabelBackground = renderer.createRect(this.x, this.y, 0, 0, 0, labelOptions.background).append(this.insideMaxLabelGroup);
                    this.minLabelBackground = renderer.createRect(this.x, this.y, 0, 0, 0, labelOptions.background).append(this.insideMinLabelGroup)
                }
                this.maxLabel = renderer.createText(this.value > this.minValue ? maxLabelText : minLabelText, this.x, this.y, labelOptions.attributes).append(this.insideMaxLabelGroup);
                this.minLabel = renderer.createText(this.value > this.minValue ? minLabelText : maxLabelText, this.x, this.y, labelOptions.attributes).append(this.insideMinLabelGroup);
                this.correctLabel();
                this.correctConnectorPosition(this.maxLabelGroup.getBBox(), this.maxConnector);
                this.correctConnectorPosition(this.minLabelGroup.getBBox(), this.minConnector)
            },
            rotateLabel: function() {
                var bboxmax = this.insideMaxLabelGroup.getBBox(),
                    bboxmin = this.insideMinLabelGroup.getBBox(),
                    labelOptions = this.options.label;
                this.insideMaxLabelGroup.applySettings({
                    x: bboxmax.x + bboxmax.width / 2,
                    y: bboxmax.y + bboxmax.height / 2,
                    rotate: labelOptions.rotationAngle
                });
                this.insideMinLabelGroup.applySettings({
                    x: bboxmin.x + bboxmin.width / 2,
                    y: bboxmin.y + bboxmin.height / 2,
                    rotate: labelOptions.rotationAngle
                })
            },
            correctLabelPosition: function() {
                var maxbbox = this.insideMaxLabelGroup.getBBox(),
                    minbbox = this.insideMinLabelGroup.getBBox(),
                    topBBoxgraphic = this.graphic && this.graphic.topMarker ? this.graphic.topMarker.getBBox() : {
                        x: this.rotated ? Math.max(this.x, this.minX) : this.x,
                        y: !this.rotated ? Math.min(this.y, this.minY) : this.y,
                        height: 0,
                        width: 0
                    },
                    bottomBBoxgraphic = this.graphic && this.graphic.bottomMarker ? this.graphic.bottomMarker.getBBox() : {
                        x: this.rotated ? Math.min(this.x, this.minX) : this.x,
                        y: !this.rotated ? Math.max(this.y, this.minY) : this.y,
                        height: 0,
                        width: 0
                    },
                    x1 = 0,
                    y1 = 0,
                    x2 = 0,
                    y2 = 0;
                if (this.options.label.position === 'outside')
                    if (!this.rotated) {
                        y1 += topBBoxgraphic.y - maxbbox.y - maxbbox.height - this.LABEL_OFFSET;
                        y2 += bottomBBoxgraphic.y + bottomBBoxgraphic.height - minbbox.y + this.LABEL_OFFSET
                    }
                    else {
                        y1 = y2 += topBBoxgraphic.y - maxbbox.y - maxbbox.height / 2 + topBBoxgraphic.height / 2;
                        x1 += topBBoxgraphic.x + topBBoxgraphic.width - maxbbox.x + this.LABEL_OFFSET;
                        x2 += bottomBBoxgraphic.x - minbbox.x - minbbox.width - this.LABEL_OFFSET
                    }
                else if (this.options.label.position === 'inside')
                    if (!this.rotated) {
                        y1 += topBBoxgraphic.y + topBBoxgraphic.height - maxbbox.y + this.LABEL_OFFSET;
                        y2 += bottomBBoxgraphic.y - minbbox.y - minbbox.height - this.LABEL_OFFSET
                    }
                    else {
                        y1 = y2 += topBBoxgraphic.y - maxbbox.y - maxbbox.height / 2 + topBBoxgraphic.height / 2;
                        x1 += topBBoxgraphic.x - maxbbox.x - maxbbox.width - this.LABEL_OFFSET;
                        x2 += bottomBBoxgraphic.x + bottomBBoxgraphic.width - minbbox.x + this.LABEL_OFFSET
                    }
                x1 += this.options.label.horizontalOffset;
                y1 += this.options.label.verticalOffset;
                x2 += this.options.label.horizontalOffset;
                y2 += this.options.label.verticalOffset;
                this.checkLabelPosition(x1, y1, x2, y2)
            },
            checkLabelPosition: function(x1, y1, x2, y2) {
                var maxgroupbbox = this.insideMaxLabelGroup.getBBox(),
                    mingroupbbox = this.insideMinLabelGroup.getBBox(),
                    newMaxbbox = {},
                    newMinbbox = {},
                    topBBoxgraphic = this.graphic && this.graphic.topMarker ? this.graphic.topMarker.getBBox() : {
                        x: this.rotated ? Math.max(this.x, this.minX) : this.x,
                        y: !this.rotated ? Math.min(this.y, this.minY) : this.y,
                        height: 0,
                        width: 0
                    },
                    bottomBBoxgraphic = this.graphic && this.graphic.bottomMarker ? this.graphic.bottomMarker.getBBox() : {
                        x: this.rotated ? Math.min(this.x, this.minX) : this.x,
                        y: !this.rotated ? Math.max(this.y, this.minY) : this.y,
                        height: 0,
                        width: 0
                    },
                    maxX = maxgroupbbox.x + x1,
                    maxY = maxgroupbbox.y + y1,
                    minX = mingroupbbox.x + x2,
                    minY = mingroupbbox.y + y2;
                var visibleArea = this.translator.getCanvasVisibleArea();
                if (!this.rotated)
                    if (visibleArea.minX < topBBoxgraphic.x + topBBoxgraphic.width && visibleArea.maxX > topBBoxgraphic.x && visibleArea.minY < bottomBBoxgraphic.y + bottomBBoxgraphic.height && visibleArea.maxY > topBBoxgraphic.y) {
                        if (visibleArea.minX > maxX && this.adjustSeriesLabels)
                            x1 += visibleArea.minX - maxX;
                        if (visibleArea.minX > minX && this.adjustSeriesLabels)
                            x2 += visibleArea.minX - minX;
                        if (visibleArea.maxX < maxX + maxgroupbbox.width && this.adjustSeriesLabels)
                            x1 -= maxX + maxgroupbbox.width - visibleArea.maxX;
                        if (visibleArea.maxX < minX + mingroupbbox.width && this.adjustSeriesLabels)
                            x2 -= minX + mingroupbbox.width - visibleArea.maxX;
                        if (visibleArea.minY > maxY)
                            y1 += visibleArea.minY - maxY;
                        if (visibleArea.maxY < minY + mingroupbbox.height)
                            y2 -= minY + mingroupbbox.height - visibleArea.maxY;
                        newMaxbbox.y = maxgroupbbox.y + y1;
                        newMinbbox.y = mingroupbbox.y + y2;
                        if (newMaxbbox.y + maxgroupbbox.height > newMinbbox.y) {
                            y1 -= (newMaxbbox.y + maxgroupbbox.height - newMinbbox.y) / 2;
                            y2 += (newMaxbbox.y + maxgroupbbox.height - newMinbbox.y) / 2;
                            newMaxbbox.y = maxgroupbbox.y + y1;
                            newMinbbox.y = mingroupbbox.y + y2;
                            if (visibleArea.minY > newMaxbbox.y) {
                                y2 += visibleArea.minY - newMaxbbox.y;
                                y1 += visibleArea.minY - newMaxbbox.y
                            }
                            else if (visibleArea.maxY < newMinbbox.y + mingroupbbox.height) {
                                y1 -= newMinbbox.y + mingroupbbox.height - visibleArea.maxY;
                                y2 -= newMinbbox.y + mingroupbbox.height - visibleArea.maxY
                            }
                        }
                    }
                if (this.rotated)
                    if (visibleArea.minY < topBBoxgraphic.y + topBBoxgraphic.height && visibleArea.maxY > topBBoxgraphic.y && visibleArea.minX < topBBoxgraphic.x + topBBoxgraphic.width && visibleArea.maxX > bottomBBoxgraphic.x) {
                        if (visibleArea.minX > minX)
                            x2 += visibleArea.minX - minX;
                        if (visibleArea.maxX < maxX + maxgroupbbox.width)
                            x1 -= maxX + maxgroupbbox.width - visibleArea.maxX;
                        if (visibleArea.minY > minY && this.adjustSeriesLabels)
                            y2 += visibleArea.minY - minY;
                        if (visibleArea.minY > maxY && this.adjustSeriesLabels)
                            y1 += visibleArea.minY - maxY;
                        if (visibleArea.maxY < minY + mingroupbbox.height && this.adjustSeriesLabels)
                            y2 -= minY + mingroupbbox.height - visibleArea.maxY;
                        if (visibleArea.maxY < maxY + maxgroupbbox.height && this.adjustSeriesLabels)
                            y1 -= maxY + maxgroupbbox.height - visibleArea.maxY;
                        newMaxbbox.x = maxgroupbbox.x + x1;
                        newMinbbox.x = mingroupbbox.x + x2;
                        if (newMaxbbox.x < newMinbbox.x + mingroupbbox.width) {
                            x1 += (newMinbbox.x + mingroupbbox.width - newMaxbbox.x) / 2;
                            x2 -= (newMinbbox.x + mingroupbbox.width - newMaxbbox.x) / 2;
                            newMaxbbox.x = maxgroupbbox.x + x1;
                            newMinbbox.x = mingroupbbox.x + x2;
                            if (visibleArea.minX > newMinbbox.x) {
                                x2 += visibleArea.minX - newMinbbox.x;
                                x1 += visibleArea.minX - newMinbbox.x
                            }
                            else if (visibleArea.maxX < newMaxbbox.x + maxgroupbbox.width) {
                                x1 -= newMaxbbox.x + maxgroupbbox.width - visibleArea.maxX;
                                x2 -= newMaxbbox.x + maxgroupbbox.width - visibleArea.maxX
                            }
                        }
                    }
                this.insideMaxLabelGroup.move(~~x1, ~~y1);
                this.insideMinLabelGroup.move(~~x2, ~~y2)
            },
            correctBackgroundPosition: function() {
                if (!this.maxLabelBackground || !this.minLabelBackground)
                    return;
                var maxbbox = this.maxLabel.getBBox(),
                    minbbox = this.minLabel.getBBox(),
                    x1 = maxbbox.x - this.LABEL_BACKGROUND_PADDING_X,
                    x2 = minbbox.x - this.LABEL_BACKGROUND_PADDING_X,
                    y1 = maxbbox.y - this.LABEL_BACKGROUND_PADDING_Y,
                    y2 = minbbox.y - this.LABEL_BACKGROUND_PADDING_Y,
                    width1 = maxbbox.width + 2 * this.LABEL_BACKGROUND_PADDING_X,
                    width2 = minbbox.width + 2 * this.LABEL_BACKGROUND_PADDING_X,
                    height1 = maxbbox.height + 2 * this.LABEL_BACKGROUND_PADDING_Y,
                    height2 = minbbox.height + 2 * this.LABEL_BACKGROUND_PADDING_Y;
                this.maxLabelBackground.applySettings({
                    x: x1,
                    y: y1,
                    width: width1,
                    height: height1
                });
                this.minLabelBackground.applySettings({
                    x: x2,
                    y: y2,
                    width: width2,
                    height: height2
                })
            },
            correctConnectorPosition: function(bbox, connector) {
                if (!connector)
                    return;
                var bboxgraphic = this.graphic ? this.graphic.getBBox() : {
                        x: this.rotated ? Math.min(this.x, this.minX) : this.x,
                        y: !this.rotated ? Math.min(this.y, this.minY) : this.y,
                        height: this.height,
                        width: this.width
                    },
                    centerLabelY = this.maxLabelBackground || this.minLabelBackground ? bbox.y + bbox.height / 2 : null,
                    centerLabelX = this.maxLabelBackground || this.minLabelBackground ? bbox.x + bbox.width / 2 : null,
                    x1,
                    x2,
                    y1,
                    y2;
                if (!this.rotated) {
                    if ((centerLabelY || bbox.y + bbox.height) < bboxgraphic.y) {
                        y1 = centerLabelY || bbox.y + bbox.height;
                        y2 = bboxgraphic.y
                    }
                    else if ((centerLabelY || bbox.y) > bboxgraphic.y + bboxgraphic.height) {
                        y1 = centerLabelY || bbox.y;
                        y2 = bboxgraphic.y + bboxgraphic.height
                    }
                    else
                        return false;
                    x1 = Math.round(bbox.x + bbox.width / 2);
                    if (x1 > bboxgraphic.x + bboxgraphic.width)
                        x2 = bboxgraphic.x + bboxgraphic.width;
                    else if (x1 < bboxgraphic.x)
                        x2 = bboxgraphic.x;
                    else
                        x2 = x1
                }
                else {
                    if ((centerLabelX || bbox.x) > bboxgraphic.x + bboxgraphic.width) {
                        x1 = centerLabelX || bbox.x;
                        x2 = bboxgraphic.x + bboxgraphic.width
                    }
                    else if ((centerLabelX || bbox.x + bbox.width) < bboxgraphic.x) {
                        x1 = centerLabelX || bbox.x + bbox.width;
                        x2 = bboxgraphic.x
                    }
                    else
                        return false;
                    y1 = Math.round(bbox.y + bbox.height / 2);
                    if (y1 > bboxgraphic.y + bboxgraphic.height)
                        y2 = bboxgraphic.y + bboxgraphic.height;
                    else if (y1 < bboxgraphic.y)
                        y2 = bboxgraphic.y;
                    else
                        y2 = y1
                }
                connector.applySettings({points: [x1, y1, x2, y2]})
            },
            getTooltipFormatObject: function(tooltip) {
                var minValue = tooltip.formatValueTooltip.call({value: this.originalMinValue}, tooltip.options),
                    value = tooltip.formatValueTooltip.call({value: this.originalValue}, tooltip.options);
                return {
                        argument: this.originalArgument,
                        valueText: minValue + ' - ' + value,
                        rangeValue1Text: minValue,
                        rangeValue2Text: value,
                        rangeValue1: this.originalMinValue,
                        rangeValue2: this.originalValue,
                        seriesName: this.options.seriesName,
                        point: this
                    }
            },
            animate: function() {
                var self = this,
                    translator = self.translator,
                    graphic = self.graphic;
                if (!graphic || !translator)
                    return;
                self._hideLabel();
                if (!self.rotated) {
                    graphic.topMarker.move(0, self.defaultY - Math.min(self.minY, self.y));
                    graphic.bottomMarker.move(0, self.defaultY - Math.max(self.minY, self.y))
                }
                else {
                    graphic.topMarker.move(self.defaultX - Math.max(self.minX, self.x), 0);
                    graphic.bottomMarker.move(self.defaultX - Math.min(self.minX, self.x), 0)
                }
                graphic.topMarker.move(0, 0, true, {complete: function() {
                        self._showLabel(true)
                    }});
                graphic.bottomMarker.move(0, 0, true, {complete: function() {
                        self._showLabel(true)
                    }})
            },
            hasValue: function() {
                return this.originalValue !== null && this.originalMinValue !== null
            }
        });
    series.RangePoint = RangePoint
})(jQuery, DevExpress);

// Module viz, file rangeBarPoint.js

(function($, DX) {
    var series = DX.viz.charts.series,
        BarPoint = series.BarPoint,
        utils = DX.utils,
        BasePoint = series.BasePoint;
    var RangeBarPoint = BarPoint.inherit({
            ctor: function(data) {
                this.callBase(data);
                this.minValue = this.originalMinValue = data.minValue !== undefined ? data.minValue : 'default';
                this.minLabelFormatObject = {
                    argument: this.originalArgument,
                    value: this.originalMinValue,
                    seriesName: this.options.seriesName
                }
            },
            translate: function(translator) {
                if (!this.hasValue())
                    return;
                this.callBase(translator);
                if (this.rotated)
                    this.width = this.width || 1;
                else
                    this.height = this.height || 1
            },
            drawLabel: function(renderer, group) {
                if (!this.hasValue() && (!utils.isDefined(this.labelFormatObject.value) || !utils.isDefined(this.minLabelFormatObject.value)))
                    return;
                var labelOptions = this.options.label,
                    maxLabelText = this.formatLabel.call(this.labelFormatObject, labelOptions),
                    minLabelText = this.formatLabel.call(this.minLabelFormatObject, labelOptions);
                this.labelGroup = renderer.createGroup().append(group);
                if (this.options.label.connector && this.options.label.connector.strokeWidth) {
                    this.maxConnector = renderer.createLine(0, 0, 0, 0, this.options.label.connector).append(this.labelGroup);
                    this.minConnector = renderer.createLine(0, 0, 0, 0, this.options.label.connector).append(this.labelGroup)
                }
                this.maxLabelGroup = renderer.createGroup().append(this.labelGroup);
                this.insideMaxLabelGroup = renderer.createGroup().append(this.maxLabelGroup);
                this.minLabelGroup = renderer.createGroup().append(this.labelGroup);
                this.insideMinLabelGroup = renderer.createGroup().append(this.minLabelGroup);
                if (labelOptions.background.fill && labelOptions.background.fill !== 'none' || labelOptions.background.strokeWidth && labelOptions.background.stroke && labelOptions.background.stroke !== 'none') {
                    this.maxLabelBackground = renderer.createRect(this.x, this.y, 0, 0, 0, labelOptions.background).append(this.insideMaxLabelGroup);
                    this.minLabelBackground = renderer.createRect(this.x, this.y, 0, 0, 0, labelOptions.background).append(this.insideMinLabelGroup)
                }
                this.maxLabel = renderer.createText(this.value > this.minValue ? maxLabelText : minLabelText, this.x, this.y, labelOptions.attributes).append(this.insideMaxLabelGroup);
                this.minLabel = renderer.createText(this.value > this.minValue ? minLabelText : maxLabelText, this.x, this.y, labelOptions.attributes).append(this.insideMinLabelGroup);
                this.correctLabel();
                this.correctConnectorPosition(this.maxLabelGroup.getBBox(), this.maxConnector);
                this.correctConnectorPosition(this.minLabelGroup.getBBox(), this.minConnector)
            },
            rotateLabel: function() {
                var bboxmax = this.insideMaxLabelGroup.getBBox(),
                    bboxmin = this.insideMinLabelGroup.getBBox(),
                    labelOptions = this.options.label;
                this.insideMaxLabelGroup.applySettings({
                    x: bboxmax.x + bboxmax.width / 2,
                    y: bboxmax.y + bboxmax.height / 2,
                    rotate: labelOptions.rotationAngle
                });
                this.insideMinLabelGroup.applySettings({
                    x: bboxmin.x + bboxmin.width / 2,
                    y: bboxmin.y + bboxmin.height / 2,
                    rotate: labelOptions.rotationAngle
                })
            },
            _hideLabel: function(animate) {
                return;
                if (this.labelGroup)
                    this.labelGroup.hide(animate);
                if (this.maxLabelGroup)
                    this.maxLabelGroup.hide(animate)
            },
            _showLabel: function(animate) {
                return;
                if (this.labelGroup)
                    this.labelGroup.show(animate);
                if (this.maxLabelGroup)
                    this.maxLabelGroup.show(animate)
            },
            correctLabelPosition: function() {
                var maxbbox = this.insideMaxLabelGroup.getBBox(),
                    minbbox = this.insideMinLabelGroup.getBBox(),
                    bboxgraphic = this.graphic.getBBox(),
                    x1 = 0,
                    y1 = 0,
                    x2 = 0,
                    y2 = 0;
                if (bboxgraphic.isEmpty)
                    bboxgraphic = this.getGraphicSettings();
                if (this.options.label.position === 'outside')
                    if (!this.rotated) {
                        x1 = x2 += bboxgraphic.width / 2;
                        y1 += bboxgraphic.y - maxbbox.y - maxbbox.height - this.LABEL_OFFSET;
                        y2 += bboxgraphic.y + bboxgraphic.height - minbbox.y + this.LABEL_OFFSET
                    }
                    else {
                        y1 = y2 += bboxgraphic.y - maxbbox.y - maxbbox.height / 2 + bboxgraphic.height / 2;
                        x1 += bboxgraphic.x + bboxgraphic.width - maxbbox.x + this.LABEL_OFFSET;
                        x2 += bboxgraphic.x - minbbox.x - minbbox.width - this.LABEL_OFFSET
                    }
                else if (this.options.label.position === 'inside')
                    if (!this.rotated) {
                        x1 = x2 += bboxgraphic.width / 2;
                        y1 += bboxgraphic.y - maxbbox.y + this.LABEL_OFFSET;
                        y2 += bboxgraphic.y + bboxgraphic.height - minbbox.y - minbbox.height - this.LABEL_OFFSET
                    }
                    else {
                        y1 = y2 += bboxgraphic.y - maxbbox.y - maxbbox.height / 2 + bboxgraphic.height / 2;
                        x1 += bboxgraphic.x + bboxgraphic.width - maxbbox.x - maxbbox.width - this.LABEL_OFFSET;
                        x2 += bboxgraphic.x - minbbox.x + this.LABEL_OFFSET
                    }
                x1 += this.options.label.horizontalOffset;
                y1 += this.options.label.verticalOffset;
                x2 += this.options.label.horizontalOffset;
                y2 += this.options.label.verticalOffset;
                this.checkLabelPosition(x1, y1, x2, y2)
            },
            checkLabelPosition: function(x1, y1, x2, y2) {
                var maxgroupbbox = this.insideMaxLabelGroup.getBBox(),
                    mingroupbbox = this.insideMinLabelGroup.getBBox(),
                    newMaxbbox = {},
                    newMinbbox = {},
                    bboxgraphic = this.graphic.getBBox(),
                    maxX = maxgroupbbox.x + x1,
                    maxY = maxgroupbbox.y + y1,
                    minX = mingroupbbox.x + x2,
                    minY = mingroupbbox.y + y2;
                var visibleArea = this.translator.getCanvasVisibleArea();
                if (!this.rotated)
                    if (visibleArea.minX < bboxgraphic.x + bboxgraphic.width && visibleArea.maxX > bboxgraphic.x && visibleArea.minY < bboxgraphic.y + bboxgraphic.height && visibleArea.maxY > bboxgraphic.y) {
                        if (visibleArea.minX > maxX && this.adjustSeriesLabels)
                            x1 += visibleArea.minX - maxX;
                        if (visibleArea.minX > minX && this.adjustSeriesLabels)
                            x2 += visibleArea.minX - minX;
                        if (visibleArea.maxX < maxX + maxgroupbbox.width && this.adjustSeriesLabels)
                            x1 -= maxX + maxgroupbbox.width - visibleArea.maxX;
                        if (visibleArea.maxX < minX + mingroupbbox.width && this.adjustSeriesLabels)
                            x2 -= minX + mingroupbbox.width - visibleArea.maxX;
                        if (visibleArea.minY > maxY)
                            y1 += visibleArea.minY - maxY;
                        if (visibleArea.maxY < minY + mingroupbbox.height)
                            y2 -= minY + mingroupbbox.height - visibleArea.maxY;
                        newMaxbbox.y = maxgroupbbox.y + y1;
                        newMinbbox.y = mingroupbbox.y + y2;
                        if (newMaxbbox.y + maxgroupbbox.height > newMinbbox.y) {
                            y1 -= (newMaxbbox.y + maxgroupbbox.height - newMinbbox.y) / 2;
                            y2 += (newMaxbbox.y + maxgroupbbox.height - newMinbbox.y) / 2;
                            newMaxbbox.y = maxgroupbbox.y + y1;
                            newMinbbox.y = mingroupbbox.y + y2;
                            if (visibleArea.minY > newMaxbbox.y) {
                                y2 += visibleArea.minY - newMaxbbox.y;
                                y1 += visibleArea.minY - newMaxbbox.y
                            }
                            else if (visibleArea.maxY < newMinbbox.y + mingroupbbox.height) {
                                y1 -= newMinbbox.y + mingroupbbox.height - visibleArea.maxY;
                                y2 -= newMinbbox.y + mingroupbbox.height - visibleArea.maxY
                            }
                        }
                    }
                if (this.rotated)
                    if (visibleArea.minY < bboxgraphic.y + bboxgraphic.height && visibleArea.maxY > bboxgraphic.y && visibleArea.minX < bboxgraphic.x + bboxgraphic.width && visibleArea.maxX > bboxgraphic.x) {
                        if (visibleArea.minX > minX)
                            x2 += visibleArea.minX - minX;
                        if (visibleArea.maxX < maxX + maxgroupbbox.width)
                            x1 -= maxX + maxgroupbbox.width - visibleArea.maxX;
                        if (visibleArea.minY > minY && this.adjustSeriesLabels)
                            y2 += visibleArea.minY - minY;
                        if (visibleArea.minY > maxY && this.adjustSeriesLabels)
                            y1 += visibleArea.minY - maxY;
                        if (visibleArea.maxY < minY + mingroupbbox.height && this.adjustSeriesLabels)
                            y2 -= minY + mingroupbbox.height - visibleArea.maxY;
                        if (visibleArea.maxY < maxY + maxgroupbbox.height && this.adjustSeriesLabels)
                            y1 -= maxY + maxgroupbbox.height - visibleArea.maxY;
                        newMaxbbox.x = maxgroupbbox.x + x1;
                        newMinbbox.x = mingroupbbox.x + x2;
                        if (newMaxbbox.x < newMinbbox.x + mingroupbbox.width) {
                            x1 += (newMinbbox.x + mingroupbbox.width - newMaxbbox.x) / 2;
                            x2 -= (newMinbbox.x + mingroupbbox.width - newMaxbbox.x) / 2;
                            newMaxbbox.x = maxgroupbbox.x + x1;
                            newMinbbox.x = mingroupbbox.x + x2;
                            if (visibleArea.minX > newMinbbox.x) {
                                x2 += visibleArea.minX - newMinbbox.x;
                                x1 += visibleArea.minX - newMinbbox.x
                            }
                            else if (visibleArea.maxX < newMaxbbox.x + maxgroupbbox.width) {
                                x1 -= newMaxbbox.x + maxgroupbbox.width - visibleArea.maxX;
                                x2 -= newMaxbbox.x + maxgroupbbox.width - visibleArea.maxX
                            }
                        }
                    }
                this.insideMaxLabelGroup.move(~~x1, ~~y1);
                this.insideMinLabelGroup.move(~~x2, ~~y2)
            },
            correctBackgroundPosition: function() {
                if (!this.maxLabelBackground || !this.minLabelBackground)
                    return;
                var maxbbox = this.maxLabel.getBBox(),
                    minbbox = this.minLabel.getBBox(),
                    x1 = maxbbox.x - this.LABEL_BACKGROUND_PADDING_X,
                    x2 = minbbox.x - this.LABEL_BACKGROUND_PADDING_X,
                    y1 = maxbbox.y - this.LABEL_BACKGROUND_PADDING_Y,
                    y2 = minbbox.y - this.LABEL_BACKGROUND_PADDING_Y,
                    width1 = maxbbox.width + 2 * this.LABEL_BACKGROUND_PADDING_X,
                    width2 = minbbox.width + 2 * this.LABEL_BACKGROUND_PADDING_X,
                    height1 = maxbbox.height + 2 * this.LABEL_BACKGROUND_PADDING_Y,
                    height2 = minbbox.height + 2 * this.LABEL_BACKGROUND_PADDING_Y;
                this.maxLabelBackground.applySettings({
                    x: x1,
                    y: y1,
                    width: width1,
                    height: height1
                });
                this.minLabelBackground.applySettings({
                    x: x2,
                    y: y2,
                    width: width2,
                    height: height2
                })
            },
            correctConnectorPosition: function(bbox, connector) {
                if (!connector)
                    return;
                var bboxgraphic = this.graphic.getBBox(),
                    x1,
                    x2,
                    y1,
                    y2,
                    centerLabelY = this.maxLabelBackground || this.minLabelBackground ? bbox.y + bbox.height / 2 : null,
                    centerLabelX = this.maxLabelBackground || this.minLabelBackground ? bbox.x + bbox.width / 2 : null;
                if (bboxgraphic.isEmpty)
                    bboxgraphic = this.getGraphicSettings();
                if (!this.rotated) {
                    if ((centerLabelY || bbox.y + bbox.height) < bboxgraphic.y) {
                        y1 = centerLabelY || bbox.y + bbox.height;
                        y2 = bboxgraphic.y
                    }
                    else if ((centerLabelY || bbox.y) > bboxgraphic.y + bboxgraphic.height) {
                        y1 = centerLabelY || bbox.y;
                        y2 = bboxgraphic.y + bboxgraphic.height
                    }
                    else
                        return false;
                    x1 = Math.round(bbox.x + bbox.width / 2);
                    if (x1 > bboxgraphic.x + bboxgraphic.width)
                        x2 = bboxgraphic.x + bboxgraphic.width;
                    else if (x1 < bboxgraphic.x)
                        x2 = bboxgraphic.x;
                    else
                        x2 = x1
                }
                else {
                    if ((centerLabelX || bbox.x) > bboxgraphic.x + bboxgraphic.width) {
                        x1 = centerLabelX || bbox.x;
                        x2 = bboxgraphic.x + bboxgraphic.width
                    }
                    else if ((centerLabelX || bbox.x + bbox.width) < bboxgraphic.x) {
                        x1 = centerLabelX || bbox.x + bbox.width;
                        x2 = bboxgraphic.x
                    }
                    else
                        return false;
                    y1 = Math.round(bbox.y + bbox.height / 2);
                    if (y1 > bboxgraphic.y + bboxgraphic.height)
                        y2 = bboxgraphic.y + bboxgraphic.height;
                    else if (y1 < bboxgraphic.y)
                        y2 = bboxgraphic.y;
                    else
                        y2 = y1
                }
                connector.applySettings({points: [x1, y1, x2, y2]})
            },
            getTooltipFormatObject: function(tooltip) {
                var minValue = tooltip.formatValueTooltip.call({value: this.originalMinValue}, tooltip.options),
                    value = tooltip.formatValueTooltip.call({value: this.originalValue}, tooltip.options);
                return {
                        argument: this.originalArgument,
                        valueText: minValue + ' - ' + value,
                        rangeValue1Text: minValue,
                        rangeValue2Text: value,
                        rangeValue1: this.originalMinValue,
                        rangeValue2: this.originalValue,
                        seriesName: this.options.seriesName,
                        point: this
                    }
            },
            hasValue: function() {
                return this.originalValue !== null && this.originalMinValue !== null
            }
        });
    series.RangeBarPoint = RangeBarPoint
})(jQuery, DevExpress);

// Module viz, file pointFactory.js

(function($, DX) {
    var series = DX.viz.charts.series;
    series.pointFactory = {createPoint: function(seriesType, pointOptions) {
            seriesType = (seriesType || '').toLowerCase();
            switch (seriesType) {
                case'line':
                    return new series.BasePoint(pointOptions);
                case'stackedline':
                    return new series.BasePoint(pointOptions);
                case'fullstackedline':
                    return new series.BasePoint(pointOptions);
                case'area':
                    return new series.BasePoint(pointOptions);
                case'stackedarea':
                    return new series.BasePoint(pointOptions);
                case'fullstackedarea':
                    return new series.BasePoint(pointOptions);
                case'bar':
                    return new series.BarPoint(pointOptions);
                case'stackedbar':
                    return new series.BarPoint(pointOptions);
                case'fullstackedbar':
                    return new series.BarPoint(pointOptions);
                case'spline':
                    return new series.BasePoint(pointOptions);
                case'splinearea':
                    return new series.BasePoint(pointOptions);
                case'scatter':
                    return new series.BasePoint(pointOptions);
                case'candlestick':
                    return new series.OhlcPoint(pointOptions);
                case'stock':
                    return new series.StockPoint(pointOptions);
                case'rangearea':
                    return new series.RangePoint(pointOptions);
                case'rangesplinearea':
                    return new series.RangePoint(pointOptions);
                case'rangebar':
                    return new series.RangeBarPoint(pointOptions);
                case'pie':
                    return new series.PiePoint(pointOptions);
                case'doughnut':
                    return new series.PiePoint(pointOptions);
                case'stepline':
                    return new series.BasePoint(pointOptions);
                case'steparea':
                    return new series.BasePoint(pointOptions);
                default:
                    return null
            }
        }}
})(jQuery, DevExpress);

// Module viz, file baseSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        eventsConsts = series.consts.events,
        statesConsts = series.consts.states,
        utils = DX.utils,
        Class = DX.Class,
        ParseUtils = DX.viz.core.ParseUtils,
        SERIES_VALUE_MARGIN_PRIORITY = 20,
        FULLSTACKED_SERIES_VALUE_MARGIN_PRIORITY = 15,
        SERIES_LABEL_VALUE_MARGIN = 0.3,
        ALL_SERIES_POINTS_MODE = 'allseriespoints',
        INCLUDE_POINTS_MODE = 'includepoints',
        HOVER_CHECK = 0,
        SELECTION_CHECK = 1;
    var BaseSeries = Class.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                this.type = options.specificType || 'unknown';
                this.isRangeSeries = isRangeSeries;
                this.renderer = renderer;
                this._rawData = data || [];
                this._parseOptions(options);
                this._parseInputData(this._rawData);
                this.userOptions = options;
                this.tag = options.tag
            },
            _checkValue: function(params) {
                if (!utils.isDefined(params.value)) {
                    this._validationResult.error = this._errorMessages.missingFieldMessage(params.field);
                    this.options.incidentOccured.call(null, this._errorMessages.missingFieldMessage(params.field));
                    return false
                }
                if (utils.isString(params.value)) {
                    params.axisType = 'discrete';
                    params.type = 'string'
                }
                else if (utils.isDate(params.value)) {
                    params.axisType = params.axisType || 'continuous';
                    params.type = 'datetime'
                }
                else if (utils.isNumber(params.value)) {
                    params.axisType = params.axisType || 'continuous';
                    params.type = 'numeric'
                }
                else {
                    this._validationResult.error = this._errorMessages.unsupportedFieldMessage(params.field);
                    this.options.incidentOccured.call(null, this._errorMessages.unsupportedFieldMessage(params.field));
                    return false
                }
                return true
            },
            _correctAxisType: function(axisType, categories) {
                return axisType && (axisType === 'discrete' || axisType === 'continuous') ? axisType : categories && categories.length ? 'discrete' : ''
            },
            reinitData: function(data) {
                this._parseInputData(data)
            },
            _errorMessages: {
                missingFieldMessage: function(field) {
                    return "Data source does not contain the '" + field + "' field."
                },
                unsupportedFieldMessage: function(field) {
                    return "The '" + field + "' field contains data of unsupported type."
                },
                incorrectDataMessage: function() {
                    return "Data source contains unsupported data."
                },
                incompatibleTypesDataMessage: function(unit) {
                    if (unit === 'argument')
                        return "The agrument type and argument axis type are incompatible.";
                    return "The value type and value axis type are incompatible."
                },
                dataItemMissingMessage: function(entity) {
                    if (entity === 'argument')
                        return "An argument is missed in the specified data.";
                    return "A value is missed in the specified data."
                },
                numericParsingMessage: function(entity) {
                    return "A point's " + entity + " cannot be parsed to a correct numeric value."
                },
                dateParsingMessage: function(entity) {
                    return "A point's " + entity + " cannot be parsed to a correct date."
                }
            },
            getRangeData: function(visibleRange) {
                if (this._validationResult.error)
                    return {};
                var self = this,
                    options = self.options,
                    argumentCategories = options.argumentCategories,
                    discreteArgumentAxis = options.argumentAxisType === 'discrete',
                    argumentType = options.argumentType,
                    valueCategories = options.valueCategories,
                    discreteValueAxis = options.valueAxisType === 'discrete',
                    valueType = options.valueType,
                    rangeData = {
                        visibleValCategories: [],
                        categoriesVal: [],
                        categoriesArg: []
                    },
                    points = self.points,
                    pointsLength = points && points.length,
                    lastVisibleIndex,
                    intervalVal,
                    intervalArg;
                function addToVisibleVal(val) {
                    if (discreteValueAxis) {
                        if ($.inArray(val, rangeData.visibleValCategories) === -1)
                            rangeData.visibleValCategories.push(val)
                    }
                    else {
                        if (val < rangeData.minVisibleVal || !utils.isDefined(rangeData.minVisibleVal))
                            rangeData.minVisibleVal = val;
                        if (val > rangeData.maxVisibleVal || !utils.isDefined(rangeData.maxVisibleVal))
                            rangeData.maxVisibleVal = val
                    }
                }
                var processArgument = function(arg, prevArg) {
                        var interval;
                        if (arg < rangeData.minArg || !utils.isDefined(rangeData.minArg))
                            rangeData.minArg = arg;
                        if (arg > rangeData.maxArg || !utils.isDefined(rangeData.maxArg))
                            rangeData.maxArg = arg;
                        if (utils.isDefined(prevArg))
                            interval = Math.abs(arg - prevArg);
                        if (utils.isDefined(interval) && (interval < rangeData.minIntervalArg || !utils.isDefined(rangeData.minIntervalArg)))
                            rangeData.minIntervalArg = interval
                    };
                var processValue = function(val, minVal, prevVal, prevMinVal) {
                        var interval;
                        if (val < rangeData.minVal || !utils.isDefined(rangeData.minVal))
                            rangeData.minVal = val;
                        if (val > rangeData.maxVal || !utils.isDefined(rangeData.maxVal))
                            rangeData.maxVal = val;
                        if (self.isRangeSeries) {
                            if (minVal < rangeData.minVal || !utils.isDefined(rangeData.minVal))
                                rangeData.minVal = minVal;
                            if (minVal > rangeData.maxVal || !utils.isDefined(rangeData.maxVal))
                                rangeData.maxVal = minVal
                        }
                        if (utils.isDefined(prevVal))
                            interval = Math.abs(val - prevVal);
                        if (self.isRangeSeries && utils.isDefined(prevMinVal))
                            interval = Math.min(interval, Math.abs(minVal - prevMinVal));
                        if (utils.isDefined(interval) && (interval < rangeData.minIntervalVal || !utils.isDefined(rangeData.minIntervalVal)))
                            rangeData.minIntervalVal = interval
                    };
                function unique(array, field) {
                    var values = {};
                    return $.map(array, function(item) {
                            var value = item[field];
                            var result = !values[value] ? value : null;
                            values[value] = true;
                            return result
                        })
                }
                if (discreteArgumentAxis) {
                    rangeData.categoriesArg = unique(points, 'argument');
                    processArgument = $.noop
                }
                if (discreteValueAxis) {
                    rangeData.categoriesVal = unique(points, 'value');
                    processValue = $.noop
                }
                if (pointsLength) {
                    $.each(points, function(i, point) {
                        var prevPoint,
                            val = point.value,
                            minVal = point.minValue,
                            arg = point.argument,
                            prevVal,
                            prevMinVal,
                            prevArg;
                        if (i !== 0) {
                            prevPoint = points[i - 1];
                            prevVal = prevPoint.value;
                            prevMinVal = prevPoint.minValue;
                            prevArg = prevPoint.argument
                        }
                        if (point.hasValue())
                            processValue(val, minVal, prevVal, prevMinVal);
                        processArgument(arg, prevArg);
                        if (discreteArgumentAxis || !visibleRange || arg < visibleRange.minArg || arg > visibleRange.maxArg)
                            return;
                        if (!utils.isDefined(rangeData.minVisibleVal) && i)
                            if (prevPoint.hasValue()) {
                                addToVisibleVal(prevVal);
                                if (self.isRangeSeries)
                                    addToVisibleVal(prevMinVal)
                            }
                        if (point.hasValue()) {
                            lastVisibleIndex = i;
                            addToVisibleVal(val);
                            if (self.isRangeSeries)
                                addToVisibleVal(minVal)
                        }
                    });
                    if (utils.isDefined(lastVisibleIndex) && lastVisibleIndex < pointsLength - 1)
                        if (points[lastVisibleIndex + 1].hasValue()) {
                            addToVisibleVal(points[lastVisibleIndex + 1].value);
                            if (self.isRangeSeries)
                                addToVisibleVal(points[lastVisibleIndex + 1].minValue)
                        }
                    if (!self.options.rotated) {
                        if (utils.isDefined(rangeData.minVal)) {
                            rangeData.minY = rangeData.minVal;
                            rangeData.maxY = rangeData.maxVal;
                            rangeData.intervalY = undefined
                        }
                        if (utils.isDefined(rangeData.minArg)) {
                            rangeData.minX = rangeData.minArg;
                            rangeData.maxX = rangeData.maxArg;
                            rangeData.intervalX = rangeData.minIntervalArg
                        }
                        if (rangeData.categoriesArg.length)
                            rangeData.categoriesX = rangeData.categoriesArg.slice(0);
                        if (rangeData.categoriesVal.length)
                            rangeData.categoriesY = rangeData.categoriesVal.slice(0);
                        if (rangeData.visibleValCategories.length)
                            rangeData.visibleCategoriesY = rangeData.visibleValCategories.slice(0);
                        rangeData.minVisibleY = rangeData.minVisibleVal;
                        rangeData.maxVisibleY = rangeData.maxVisibleVal
                    }
                    else {
                        if (utils.isDefined(rangeData.minVal)) {
                            rangeData.minX = rangeData.minVal;
                            rangeData.maxX = rangeData.maxVal;
                            rangeData.intervalX = undefined
                        }
                        if (utils.isDefined(rangeData.minArg)) {
                            rangeData.minY = rangeData.minArg;
                            rangeData.maxY = rangeData.maxArg;
                            rangeData.intervalY = rangeData.minIntervalArg
                        }
                        if (rangeData.categoriesArg.length)
                            rangeData.categoriesY = rangeData.categoriesArg.slice(0);
                        if (rangeData.categoriesVal.length)
                            rangeData.categoriesX = rangeData.categoriesVal.slice(0);
                        if (rangeData.visibleValCategories.length)
                            rangeData.visibleCategoriesX = rangeData.visibleValCategories.slice(0);
                        rangeData.minVisibleX = rangeData.minVisibleVal;
                        rangeData.maxVisibleX = rangeData.maxVisibleVal
                    }
                }
                delete rangeData.minArg;
                delete rangeData.maxArg;
                delete rangeData.minVal;
                delete rangeData.maxVal;
                delete rangeData.minIntervalArg;
                delete rangeData.minIntervalVal;
                delete rangeData.minVisibleVal;
                delete rangeData.maxVisibleVal;
                delete rangeData.visibleValCategories;
                delete rangeData.categoriesArg;
                delete rangeData.categoriesVal;
                rangeData = this.addLabelPaddingsToRange(rangeData);
                rangeData = this.processRangeForFullStackedSeries(rangeData);
                this.rangeData = rangeData;
                return rangeData
            },
            setPadding: function(range, prefix, val, priority) {
                range[prefix] = val;
                range[prefix + 'Priority'] = priority
            },
            addLabelPaddingsToRange: function(rangeData) {
                var series = this;
                if (series.areLabelsVisible() && series.styles.point.label.position !== 'inside')
                    if (!series.options.rotated) {
                        this.setPadding(rangeData, 'maxValueMarginY', SERIES_LABEL_VALUE_MARGIN, SERIES_VALUE_MARGIN_PRIORITY);
                        if (series.isRangeSeries)
                            this.setPadding(rangeData, 'minValueMarginY', SERIES_LABEL_VALUE_MARGIN, SERIES_VALUE_MARGIN_PRIORITY)
                    }
                    else {
                        this.setPadding(rangeData, 'maxValueMarginX', SERIES_LABEL_VALUE_MARGIN, SERIES_VALUE_MARGIN_PRIORITY);
                        if (series.isRangeSeries)
                            this.setPadding(rangeData, 'minValueMarginX', SERIES_LABEL_VALUE_MARGIN, SERIES_VALUE_MARGIN_PRIORITY)
                    }
                return rangeData
            },
            isFullStackedSeries: function() {
                return this.type.indexOf('fullstacked') === 0
            },
            processRangeForFullStackedSeries: function(rangeData) {
                var self = this,
                    indentName,
                    isRangeEmpty = $.isEmptyObject(rangeData);
                if (self.isFullStackedSeries())
                    if (!self.options.rotated) {
                        self.setPadding(rangeData, 'minValueMarginY', 0, FULLSTACKED_SERIES_VALUE_MARGIN_PRIORITY);
                        self.setPadding(rangeData, 'maxValueMarginY', 0, FULLSTACKED_SERIES_VALUE_MARGIN_PRIORITY);
                        !isRangeEmpty && (rangeData.minY = 0)
                    }
                    else {
                        self.setPadding(rangeData, 'minValueMarginX', 0, FULLSTACKED_SERIES_VALUE_MARGIN_PRIORITY);
                        self.setPadding(rangeData, 'maxValueMarginX', 0, FULLSTACKED_SERIES_VALUE_MARGIN_PRIORITY);
                        !isRangeEmpty && (rangeData.minX = 0)
                    }
                return rangeData
            },
            draw: function(translator) {
                var seriesGroupOptions = {'class': 'series'},
                    labelsGroupOptions = {'class': 'labels'},
                    seriesGroup,
                    labelsGroup;
                if (!translator) {
                    throw new Error('Translator was not initialized before call Series Draw()');
                    return
                }
                this.translator = translator;
                this._translateCoors();
                if (this.clipRectID) {
                    seriesGroupOptions.clipId = this.clipRectID;
                    labelsGroupOptions.clipId = this.clipRectID
                }
                seriesGroup = this.renderer.createGroup(seriesGroupOptions).append(this.options.seriesGroup);
                labelsGroup = this.renderer.createGroup(labelsGroupOptions).append(this.options.seriesLabelsGroup);
                if (!this.hoverPatternColor) {
                    this.hoverPatternColor = this.styles.states.hover.fill;
                    this.selectedPatternColor = this.styles.states.selected.fill
                }
                this.hoverPatternId = this.createPattern(this.hoverPatternColor, this.styles.states.hover.hatching);
                this.selectedPatternId = this.createPattern(this.selectedPatternColor, this.styles.states.selected.hatching);
                this.drawSeriesData(seriesGroup, labelsGroup);
                switch (this.state) {
                    case statesConsts.selected:
                        this.setSelectedState(this.lastSelectionMode);
                        break;
                    case statesConsts.hover:
                        this.setHoverState(this.lastHoverdMode);
                        break;
                    default:
                        this.state = statesConsts.normal;
                        this.fullState = statesConsts.normalMark
                }
                return this
            },
            createPattern: function(color, hatching) {
                var pattern = this.renderer.createPattern(color, hatching);
                if (pattern.id)
                    return pattern.id;
                else
                    return pattern
            },
            drawSeriesData: function(seriesGroup, labelsGroup) {
                if (this.hoverPatternId) {
                    this.styles.states.hover.fill = this.hoverPatternId;
                    this.styles.states.selected.fill = this.selectedPatternId
                }
                this.drawPoints(seriesGroup, labelsGroup);
                return this
            },
            drawPoints: function(group, labelsGroup) {
                var series = this,
                    pointVisible = series.styles.point.visible,
                    labelVisible = series.areLabelsVisible(),
                    trackersVisible = !series._suppressTrackers;
                $.each(series.points, function drawMarkerAndTracker(i, point) {
                    point.adjustSeriesLabels = series.adjustSeriesLabels;
                    pointVisible && point.drawMarker(series.renderer, group);
                    trackersVisible && point.drawTrackerMarker(series.renderer, series.options.markerTrackerGroup);
                    labelVisible && point.drawLabel(series.renderer, labelsGroup)
                })
            },
            areLabelsVisible: function() {
                var series = this;
                return series.styles.point.label.visible && (!utils.isDefined(series.styles.maxLabelCount) || series.points.length <= series.styles.maxLabelCount)
            },
            getPoints: function() {
                return this.points
            },
            initEventTriggering: function(svgElement, mode) {
                var series = this,
                    $series = $(series),
                    eventParameters = [series, mode];
                svgElement.on({
                    mouseover: function(event) {
                        $series.trigger(event, eventParameters)
                    },
                    mouseout: function(event) {
                        $series.trigger(event, series)
                    },
                    mousemove: function(event) {
                        $series.trigger(event, series)
                    },
                    click: function(event) {
                        $series.trigger(event, series)
                    }
                })
            },
            select: function() {
                $(this).trigger(new $.Event(eventsConsts.selectSeries), this.options.selectionMode)
            },
            clearSelection: function clearSelection() {
                $(this).trigger(new $.Event(eventsConsts.deselectSeries), this.options.selectionMode)
            },
            selectPoint: function(point) {
                $(this).trigger(new $.Event(eventsConsts.selectPoint), point)
            },
            deselectPoint: function(point) {
                $(this).trigger(new $.Event(eventsConsts.deselectPoint), point)
            },
            getAllPoints: function() {
                return this.points.slice()
            },
            getPointByPos: function(pos) {
                return this.points && this.points[pos]
            },
            getPointByArg: function(arg) {
                return this.pointsByArgument[arg] || null
            },
            animate: function() {
                if (this.styles.point.visible)
                    $.each(this.segments, function(_, segment) {
                        $.each(segment, function(_, pt) {
                            pt.animate()
                        })
                    })
            },
            on: function(events, data, handler) {
                $(this).on(events, data, handler);
                return this
            },
            off: function(events) {
                $(this).off(events);
                return this
            },
            applyNormalStyle: function(mode) {
                if (mode === ALL_SERIES_POINTS_MODE || mode === INCLUDE_POINTS_MODE)
                    $.each(this.segments, function(_, segment) {
                        $.each(segment, function(_, pt) {
                            if (!(pt.fullState & statesConsts.selectedMark))
                                pt.applyNormalStyle()
                        })
                    })
            },
            applyHoverStyle: function(mode) {
                if (mode === ALL_SERIES_POINTS_MODE || mode === INCLUDE_POINTS_MODE)
                    $.each(this.segments, function(_, segment) {
                        $.each(segment, function(_, pt) {
                            if (!(pt.fullState & statesConsts.selectedMark))
                                pt.applyHoverStyle()
                        })
                    })
            },
            applySelectionStyle: function(mode) {
                if (mode === ALL_SERIES_POINTS_MODE || mode === INCLUDE_POINTS_MODE)
                    $.each(this.segments, function(_, segment) {
                        $.each(segment, function(_, pt) {
                            if (!(pt.fullState & statesConsts.selectedMark))
                                pt.applySelectionStyle()
                        })
                    })
            },
            setHoverState: function(mode) {
                this.fullState = this.fullState | statesConsts.hoverMark;
                mode = mode || this.options.hoverMode;
                this.lastHoverMode = mode;
                if (!this._checkBehavior(mode, HOVER_CHECK))
                    return;
                this.state = statesConsts.hover;
                this.applyHoverStyle(mode)
            },
            releaseHoverState: function() {
                var mode = this.lastHoverMode || this.options.hoverMode;
                this.fullState = this.fullState & ~statesConsts.hoverMark;
                delete this.lastHoverMode;
                if (!this._checkBehavior(mode, HOVER_CHECK))
                    return;
                this.state = statesConsts.normal;
                this.applyNormalStyle(mode)
            },
            setSelectedState: function(mode) {
                this.state = statesConsts.selected;
                this.fullState = this.fullState | statesConsts.selectedMark;
                this.lastSelectionMode = mode;
                if (!this._checkBehavior(mode, SELECTION_CHECK))
                    return;
                if (this.lastHoverMode === ALL_SERIES_POINTS_MODE || this.lastHoverMode === INCLUDE_POINTS_MODE)
                    this.applyNormalStyle(INCLUDE_POINTS_MODE);
                mode = mode || this.options.selectionMode;
                this.applySelectionStyle(mode)
            },
            releaseSelectedState: function() {
                var mode = this.lastSelectionMode || this.options.selectionMode;
                this.fullState = this.fullState & ~statesConsts.selectedMark;
                if (!this._checkBehavior(mode, SELECTION_CHECK))
                    return;
                if (this.fullState & statesConsts.hoverMark && (this.lastHoverMode === ALL_SERIES_POINTS_MODE || this.lastHoverMode === INCLUDE_POINTS_MODE)) {
                    this.state = statesConsts.hover;
                    this.applyHoverStyle(this.lastHoverMode)
                }
                else {
                    this.state = statesConsts.normal;
                    this.applyNormalStyle(mode)
                }
                delete this.lastSelectionMode
            },
            _checkBehavior: function(mode, behavior) {
                if (mode === 'none')
                    return false;
                switch (behavior) {
                    case HOVER_CHECK:
                        if (!(this.fullState & statesConsts.selectedMark) || this.options.selectionMode === 'none')
                            return true;
                        return false;
                    case SELECTION_CHECK:
                        return true
                }
                return false
            },
            setPointHoverState: function(point) {
                point.fullState = point.fullState | statesConsts.hoverMark;
                if (!(this.fullState & statesConsts.selectedMark && (this.lastSelectionMode === ALL_SERIES_POINTS_MODE || this.lastSelectionMode === INCLUDE_POINTS_MODE)) && !(point.fullState & statesConsts.selectedMark)) {
                    point.state = statesConsts.hover;
                    point.applyHoverStyle()
                }
            },
            releasePointHoverState: function(point) {
                point.fullState = point.fullState & ~statesConsts.hoverMark;
                if (!(this.fullState & statesConsts.selectedMark && (this.lastSelectionMode === ALL_SERIES_POINTS_MODE || this.lastSelectionMode === INCLUDE_POINTS_MODE)) && !(point.fullState & statesConsts.selectedMark)) {
                    point.state = statesConsts.normal;
                    if (!(this.fullState & statesConsts.hoverMark && (this.lastSelectionMode === ALL_SERIES_POINTS_MODE || this.lastSelectionMode === INCLUDE_POINTS_MODE)))
                        point.applyNormalStyle()
                }
            },
            setPointSelectedState: function(point) {
                point.state = statesConsts.selected;
                point.fullState = point.fullState | statesConsts.selectedMark;
                point.applySelectionStyle()
            },
            releasePointSelectedState: function(point) {
                point.state = statesConsts.normal;
                point.fullState = point.fullState & ~statesConsts.selectedMark;
                if (this.fullState & statesConsts.hoverMark && (this.lastHoverMode === ALL_SERIES_POINTS_MODE || this.lastHoverMode === INCLUDE_POINTS_MODE) || point.fullState & statesConsts.hoverMark) {
                    point.applyHoverStyle();
                    if (point.fullState & statesConsts.hoverMark)
                        point.state = statesConsts.hover
                }
                else if (this.fullState & statesConsts.selectedMark && (this.lastSelectionMode === ALL_SERIES_POINTS_MODE || this.lastSelectionMode === INCLUDE_POINTS_MODE))
                    point.applySelectionStyle();
                else
                    point.applyNormalStyle()
            },
            _translateCoors: function() {
                var series = this;
                var tr = series.translator;
                $.each(series.points, function(i, p) {
                    p.translate(tr)
                })
            },
            _checkAndPrepareInputData: function(data, argumentField, valueFields) {
                this._checkInputData(data, argumentField, valueFields);
                return this._validationResult.error ? null : this._prepareInputData(data, argumentField, valueFields)
            },
            _checkInputData: function(data, argumentField, valueFields) {
                this._validationResult = {error: null};
                this._parseUtils = new ParseUtils({incidentOccured: this.options.incidentOccured});
                var self = this,
                    dataLen = data.length,
                    i,
                    argFound,
                    valFound,
                    val1Found,
                    val2Found,
                    curPoint,
                    firstItem = data[0],
                    checkParams = {};
                if (!dataLen)
                    return;
                if (!utils.isDefined(firstItem) || !$.isPlainObject(firstItem)) {
                    self._validationResult.error = self._errorMessages.incorrectDataMessage();
                    self.options.incidentOccured.call(null, self._errorMessages.incorrectDataMessage());
                    return
                }
                self._checkArgumentAxisParams(data, argumentField);
                if (self._validationResult.error)
                    return;
                self._checkValueAxisParams(data, valueFields)
            },
            _checkArgumentAxisParams: function(data, argumentField) {
                var self = this,
                    options = self.options,
                    argumentCategories = options.argumentCategories,
                    argumentAxisType = self._correctAxisType(options.argumentAxisType, options.argumentCategories),
                    argumentType = self._parseUtils.correctValueType(options.argumentType),
                    i,
                    argFound,
                    curPoint,
                    checkParams = {};
                argumentField = argumentField || options.argumentField || 'arg';
                switch (argumentType.toLowerCase()) {
                    case'numeric':
                    case'datetime':
                        if (!argumentAxisType) {
                            options.argumentAxisType = argumentAxisType = 'continuous';
                            options.argumentType = argumentType
                        }
                        else {
                            options.argumentAxisType = argumentAxisType;
                            options.argumentType = argumentType
                        }
                        return;
                    case'string':
                        if (argumentAxisType && argumentAxisType !== 'discrete') {
                            self._validationResult.error = self._errorMessages.incompatibleTypesDataMessage('argument');
                            self.options.incidentOccured.call(null, self._errorMessages.incompatibleTypesDataMessage('argument'))
                        }
                        options.argumentAxisType = argumentAxisType = 'discrete';
                        options.argumentType = argumentType;
                        return;
                    default:
                        break
                }
                for (i = 0; i < data.length; i++) {
                    curPoint = data[i];
                    if (utils.isDefined(curPoint[argumentField])) {
                        argFound = curPoint[argumentField];
                        break
                    }
                }
                checkParams.value = argFound;
                checkParams.field = argumentField;
                checkParams.axisType = argumentAxisType;
                checkParams.type = argumentType;
                if (self._checkValue(checkParams)) {
                    options.argumentAxisType = checkParams.axisType;
                    options.argumentType = checkParams.type
                }
                else
                    return
            },
            _checkValueAxisParams: function(data, valueFields) {
                var self = this,
                    options = self.options,
                    valueField = options.valueField || 'val',
                    rangeValue1Field = options.rangeValue1Field || 'val1',
                    rangeValue2Field = options.rangeValue2Field || 'val2',
                    valueCategories = options.valueCategories,
                    valueAxisType = self._correctAxisType(options.valueAxisType, options.valueCategories),
                    valueType = self._parseUtils.correctValueType(options.valueType),
                    i,
                    j,
                    valFound = {},
                    val1Found,
                    val2Found,
                    curPoint,
                    checkParams = {},
                    foundedValueFields;
                valueFields = valueFields || [];
                if (!valueFields.length)
                    valueFields = self.isRangeSeries ? [rangeValue1Field, rangeValue2Field] : [valueField];
                switch (valueType.toLowerCase()) {
                    case'numeric':
                    case'datetime':
                        if (!valueAxisType) {
                            options.valueAxisType = valueAxisType = 'continuous';
                            options.valueType = valueType
                        }
                        else {
                            options.valueAxisType = valueAxisType;
                            options.valueType = valueType
                        }
                        return;
                    case'string':
                        if (valueAxisType && valueAxisType !== 'discrete') {
                            self._validationResult.error = self._errorMessages.incompatibleTypesDataMessage('value');
                            self.options.incidentOccured.call(null, self._errorMessages.incompatibleTypesDataMessage('value'))
                        }
                        options.valueAxisType = valueAxisType = 'discrete';
                        options.valueType = valueType;
                        return;
                    default:
                        break
                }
                checkParams.axisType = valueAxisType;
                checkParams.type = valueType;
                for (i = 0; i < data.length; i++) {
                    var allFieldsFound = true;
                    curPoint = data[i];
                    for (j = 0; j < valueFields.length; j++)
                        if (utils.isDefined(curPoint[valueFields[j]]))
                            valFound[valueFields[j]] = curPoint[valueFields[j]];
                    $.each(valueFields, function(i, field) {
                        return allFieldsFound = field in valFound
                    });
                    if (allFieldsFound)
                        break
                }
                for (i = 0; i < valueFields.length; i++) {
                    checkParams.value = valFound[valueFields[i]];
                    checkParams.field = valueFields[i];
                    if (!self._checkValue(checkParams))
                        return
                }
                options.valueAxisType = checkParams.axisType;
                options.valueType = checkParams.type
            },
            _prepareInputData: function(data, argumentField, valueFields) {
                var self = this,
                    options = self.options,
                    argumentCategories = options.argumentCategories,
                    argumentAxisType = options.argumentAxisType,
                    argumentType = options.argumentType,
                    errorMessages = self._errorMessages,
                    incidentOccured = self.options.incidentOccured,
                    valueField = options.valueField || 'val',
                    rangeValue1Field = options.rangeValue1Field || 'val1',
                    rangeValue2Field = options.rangeValue2Field || 'val2',
                    valueCategories = options.valueCategories,
                    valueAxisType = options.valueAxisType,
                    valueType = options.valueType,
                    tagField = options.tagField || 'tag',
                    query = DX.data.query,
                    argumentParser = $.noop,
                    valueParser = $.noop,
                    prepData = [];
                argumentField = argumentField || options.argumentField || 'arg';
                valueFields = valueFields || [];
                if (!valueFields.length)
                    valueFields = self.isRangeSeries ? [rangeValue1Field, rangeValue2Field] : [valueField];
                if (!data.length)
                    return prepData;
                function categorySort() {
                    var length = argumentCategories.length,
                        oIdx = length,
                        i,
                        sortHash = {};
                    for (i = 0; i < length; i++)
                        sortHash[argumentCategories[i]] = i;
                    return function(a, b) {
                            var argA = a[argumentField],
                                argB = b[argumentField],
                                aRank = sortHash[argA],
                                bRank = sortHash[argB];
                            if (!utils.isDefined(aRank))
                                aRank = oIdx;
                            if (!utils.isDefined(bRank))
                                bRank = oIdx;
                            return aRank - bRank
                        }
                }
                function argumentSort(a, b) {
                    return a[argumentField] - b[argumentField]
                }
                var getParser = function(entity, valueType, nullsNotAllowed) {
                        var parser = self._parseUtils.getParser(valueType.toLowerCase(), entity + 'Axis'),
                            parsingMessage;
                        switch (valueType.toLowerCase()) {
                            case'numeric':
                                parsingMessage = errorMessages.numericParsingMessage;
                                break;
                            case'datetime':
                                parsingMessage = errorMessages.dateParsingMessage;
                                break;
                            default:
                                parsingMessage = $.noop
                        }
                        return function(val) {
                                var parsedVal;
                                if (nullsNotAllowed && !utils.isDefined(val) || val === undefined) {
                                    incidentOccured.call(null, errorMessages.dataItemMissingMessage(entity));
                                    return undefined
                                }
                                if (val === null)
                                    return null;
                                parsedVal = parser(val);
                                if (!utils.isDefined(parsedVal))
                                    incidentOccured.call(null, parsingMessage(entity));
                                return parsedVal
                            }
                    };
                var parseArgument = getParser('argument', argumentType, true);
                var parseValue = getParser('value', valueType);
                prepData = $.map(data, function(src) {
                    var arg = parseArgument(src[argumentField]),
                        resultDataItem = {tag: src[tagField]},
                        val,
                        i;
                    if (!utils.isDefined(arg))
                        return null;
                    resultDataItem[argumentField] = arg;
                    for (i = 0; i < valueFields.length; i++) {
                        val = parseValue(src[valueFields[i]]);
                        if (val === undefined)
                            return null;
                        resultDataItem[valueFields[i]] = val
                    }
                    return resultDataItem
                });
                if (argumentAxisType === 'discrete' && argumentCategories && argumentCategories.length)
                    prepData.sort(categorySort());
                else if (argumentAxisType !== 'discrete')
                    prepData.sort(argumentSort);
                return prepData
            },
            _parseInputData: function(data) {
                var self = this,
                    createPoint = series.pointFactory.createPoint,
                    rotated = self.options.rotated,
                    pointStyles = self.styles.point,
                    prepData,
                    i = 0,
                    curPoint,
                    point,
                    valueField,
                    rangeValue1Field,
                    rangeValue2Field,
                    options = self.options,
                    argumentField = argumentField || options.argumentField || 'arg',
                    tagField = options.tagField || 'tag';
                self.points = [];
                self.pointsByArgument = {};
                self.segments = [];
                prepData = self._checkAndPrepareInputData(data);
                if (!prepData || self._validationResult.error)
                    return;
                if (!self.isRangeSeries) {
                    valueField = options.valueField || 'val';
                    for (; i < prepData.length; i++) {
                        curPoint = prepData[i];
                        point = createPoint(self.type, {
                            value: curPoint[valueField],
                            argument: curPoint[argumentField],
                            rotated: rotated,
                            options: pointStyles,
                            tag: curPoint.tag,
                            series: self
                        });
                        self.points.push(point);
                        self.pointsByArgument[point.argument] = self.pointsByArgument[point.argument] || point
                    }
                }
                else {
                    rangeValue1Field = options.rangeValue1Field || 'val1';
                    rangeValue2Field = options.rangeValue2Field || 'val2';
                    for (; i < prepData.length; i++) {
                        curPoint = prepData[i];
                        point = createPoint(self.type, {
                            minValue: curPoint[rangeValue1Field],
                            value: curPoint[rangeValue2Field],
                            argument: curPoint[argumentField],
                            rotated: rotated,
                            options: pointStyles,
                            tag: curPoint.tag,
                            series: self
                        });
                        self.pointsByArgument[point.argument] = self.pointsByArgument[point.argument] || point;
                        self.points.push(point)
                    }
                }
                this._segmenting()
            },
            _segmenting: function() {
                var self = this,
                    segment = [];
                $.each(this.points, function(_, point) {
                    if (point.hasValue())
                        segment.push(point);
                    else if (segment.length !== 0) {
                        self.segments.push(segment);
                        segment = []
                    }
                });
                if (segment.length)
                    this.segments.push(segment)
            },
            _parseOptions: function(options) {
                this.options = {
                    incidentOccured: options.incidentOccured,
                    rotated: !!options.rotated,
                    seriesGroup: options.seriesGroup,
                    seriesLabelsGroup: options.seriesLabelsGroup,
                    seriesTrackerGroup: options.seriesTrackerGroup,
                    markerTrackerGroup: options.markerTrackerGroup,
                    argumentCategories: options.argumentCategories,
                    argumentAxisType: options.argumentAxisType,
                    argumentType: options.argumentType,
                    argumentField: options.argumentField,
                    valueCategories: options.valueCategories,
                    valueAxisType: options.valueAxisType,
                    valueType: options.valueType,
                    valueField: options.valueField,
                    rangeValue1Field: options.rangeValue1Field,
                    rangeValue2Field: options.rangeValue2Field,
                    tagField: options.tagField,
                    selectionMode: (options.selectionMode || '').toLowerCase(),
                    hoverMode: (options.hoverMode || '').toLowerCase(),
                    showInLegend: options.showInLegend !== undefined ? options.showInLegend : true
                };
                if (!$.isFunction(this.options.incidentOccured))
                    this.options.incidentOccured = $.noop;
                this.name = options.name;
                this.styles = this.parseStyleOptions(options);
                if (this.adjustOptions)
                    this.adjustOptions()
            },
            parseStyleOptions: function(options) {
                var combinedOptions = $.extend(true, {}, this.getDefaultStyleOptions(), options);
                var normalState = {
                        strokeWidth: combinedOptions.border.visible ? combinedOptions.border.width || 0 : 0,
                        stroke: combinedOptions.border.visible && combinedOptions.border.width ? combinedOptions.border.color : 'none',
                        fill: combinedOptions.color,
                        dashStyle: combinedOptions.dashStyle,
                        lineWidth: combinedOptions.width,
                        r: combinedOptions.cornerRadius
                    };
                var hoverState = {
                        strokeWidth: combinedOptions.hoverStyle.border.visible ? combinedOptions.hoverStyle.border.width || 0 : 0,
                        stroke: combinedOptions.hoverStyle.border.visible && combinedOptions.hoverStyle.border.width ? combinedOptions.hoverStyle.border.color : 'none',
                        fill: combinedOptions.hoverStyle.color,
                        dashStyle: combinedOptions.hoverStyle.dashStyle || combinedOptions.dashStyle,
                        lineWidth: combinedOptions.hoverStyle.width,
                        hatching: combinedOptions.hoverStyle.hatching
                    };
                var selectedState = {
                        strokeWidth: combinedOptions.selectionStyle.border.visible ? combinedOptions.selectionStyle.border.width || 0 : 0,
                        stroke: combinedOptions.selectionStyle.border.visible && combinedOptions.selectionStyle.border.width ? combinedOptions.selectionStyle.border.color : 'none',
                        fill: combinedOptions.selectionStyle.color,
                        dashStyle: combinedOptions.selectionStyle.dashStyle || combinedOptions.dashStyle,
                        lineWidth: combinedOptions.selectionStyle.width,
                        hatching: combinedOptions.selectionStyle.hatching
                    };
                var attr = {};
                $.each(['align', 'translateX', 'translateY', 'rotate', 'linejoin', 'linecap', 'opacity', 'style'], function(i, val) {
                    if (combinedOptions[val])
                        attr[val] = combinedOptions[val]
                });
                var attributes = $.extend(true, {}, normalState, attr);
                var pointNormalState = {
                        strokeWidth: combinedOptions.point.border.visible ? combinedOptions.point.border.width || 0 : 0,
                        stroke: combinedOptions.point.border.visible && combinedOptions.point.border.width ? combinedOptions.point.border.color : 'none',
                        fill: combinedOptions.point.color,
                        r: combinedOptions.point.size + (combinedOptions.point.border.visible && combinedOptions.point.size !== 0 ? ~~(combinedOptions.point.border.width / 2) || 0 : 0)
                    };
                var pointHoverState = {
                        strokeWidth: combinedOptions.point.hoverStyle.border.visible ? combinedOptions.point.hoverStyle.border.width || 0 : 0,
                        stroke: combinedOptions.point.hoverStyle.border.visible && combinedOptions.point.hoverStyle.border.width ? combinedOptions.point.hoverStyle.border.color : 'none',
                        fill: combinedOptions.point.hoverStyle.color,
                        r: combinedOptions.point.hoverStyle.size + (combinedOptions.point.hoverStyle.border.visible && combinedOptions.point.hoverStyle.size !== 0 ? ~~(combinedOptions.point.hoverStyle.border.width / 2) || 0 : 0)
                    };
                var pointSelectedState = {
                        strokeWidth: combinedOptions.point.selectionStyle.border.visible ? combinedOptions.point.selectionStyle.border.width || 0 : 0,
                        stroke: combinedOptions.point.selectionStyle.border.visible && combinedOptions.point.selectionStyle.border.width ? combinedOptions.point.selectionStyle.border.color : 'none',
                        fill: combinedOptions.point.selectionStyle.color,
                        r: combinedOptions.point.selectionStyle.size + (combinedOptions.point.selectionStyle.border.visible && combinedOptions.point.selectionStyle.size !== 0 ? ~~(combinedOptions.point.selectionStyle.border.width / 2) || 0 : 0)
                    };
                var pointAttr = {};
                $.each(['align', 'translateX', 'translateY', 'rotate', 'linejoin', 'linecap', 'style'], function(i, val) {
                    if (val in combinedOptions.point)
                        pointAttr[val] = combinedOptions.point[val]
                });
                var pointAttributes = $.extend(true, {}, pointNormalState, pointAttr);
                var labelAttributes = {
                        align: combinedOptions.label.alignment,
                        font: {
                            color: combinedOptions.label.backgroundColor === 'none' && combinedOptions.label.font.color.toLowerCase() === '#ffffff' && combinedOptions.label.position !== 'inside' ? combinedOptions.color : combinedOptions.label.font.color,
                            family: combinedOptions.label.font.family,
                            weight: combinedOptions.label.font.weight,
                            size: combinedOptions.label.font.size
                        },
                        style: combinedOptions.label.style
                    };
                var backgroundAttr = {
                        fill: combinedOptions.label.backgroundColor || combinedOptions.color,
                        strokeWidth: combinedOptions.label.border.visible ? combinedOptions.label.border.width || 0 : 0,
                        stroke: combinedOptions.label.border.visible && combinedOptions.label.border.width ? combinedOptions.label.border.color : 'none',
                        dashStyle: combinedOptions.label.border.dashStyle
                    };
                var connectorAttr = {
                        stroke: combinedOptions.label.connector.visible && combinedOptions.label.connector.width ? combinedOptions.label.connector.color || combinedOptions.color : 'none',
                        strokeWidth: combinedOptions.label.connector.visible ? combinedOptions.label.connector.width || 0 : 0
                    };
                return {
                        themeColor: combinedOptions.color,
                        attributes: attributes,
                        maxLabelCount: combinedOptions.maxLabelCount,
                        reduction: {
                            color: combinedOptions.reduction.color,
                            level: combinedOptions.reduction.level,
                            innerColor: combinedOptions.innerColor
                        },
                        states: {
                            normal: normalState,
                            hover: hoverState,
                            selected: selectedState
                        },
                        point: {
                            visible: combinedOptions.point.visible,
                            symbol: combinedOptions.point.symbol,
                            attributes: pointAttributes,
                            seriesName: combinedOptions.point.seriesName,
                            selectionMode: (combinedOptions.point.selectionMode || '').toLowerCase(),
                            hoverMode: (combinedOptions.point.hoverMode || '').toLowerCase(),
                            states: {
                                normal: pointNormalState,
                                hover: pointHoverState,
                                selected: pointSelectedState
                            },
                            label: {
                                format: combinedOptions.label.format,
                                argumentFormat: combinedOptions.label.argumentFormat,
                                precision: combinedOptions.label.precision,
                                argumentPrecision: combinedOptions.label.argumentPrecision,
                                percentPrecision: combinedOptions.label.percentPrecision,
                                customizeText: $.isFunction(combinedOptions.label.customizeText) ? combinedOptions.label.customizeText : undefined,
                                attributes: labelAttributes,
                                visible: combinedOptions.label.font.size !== 0 ? combinedOptions.label.visible : false,
                                showForZeroValues: combinedOptions.label.showForZeroValues,
                                horizontalOffset: combinedOptions.label.horizontalOffset,
                                verticalOffset: combinedOptions.label.verticalOffset,
                                radialOffset: combinedOptions.label.radialOffset,
                                background: backgroundAttr,
                                position: combinedOptions.label.position,
                                connector: connectorAttr,
                                rotationAngle: combinedOptions.label.rotationAngle
                            }
                        }
                    }
            },
            getDefaultStyleOptions: function() {
                return {
                        color: '#000000',
                        border: {
                            visible: false,
                            width: 1,
                            color: '#000000'
                        },
                        width: 2,
                        dashStyle: 'solid',
                        cornerRadius: 0,
                        innerColor: '#ffffff',
                        reduction: {color: '#000000'},
                        maxLabelCount: undefined,
                        point: {
                            visible: true,
                            symbol: 'circle',
                            color: '#000000',
                            size: 6,
                            seriesName: this.name,
                            border: {
                                visible: false,
                                width: 1,
                                color: '#000000'
                            },
                            hoverStyle: {
                                color: '#000000',
                                border: {
                                    visible: true,
                                    width: 2,
                                    color: '#ffffff'
                                },
                                size: 6
                            },
                            selectionStyle: {
                                color: '#000000',
                                border: {
                                    visible: true,
                                    width: 2,
                                    color: '#ffffff'
                                },
                                size: 6
                            }
                        },
                        label: {
                            visible: false,
                            showForZeroValues: true,
                            alignment: 'center',
                            font: {
                                family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                                weight: 400,
                                color: '#ffffff',
                                size: 14
                            },
                            rotationAngle: 0,
                            horizontalOffset: 0,
                            verticalOffset: 0,
                            radialOffset: 0,
                            format: '',
                            argumentFormat: '',
                            precision: 0,
                            argumentPrecision: 0,
                            position: 'outside',
                            connector: {
                                visible: false,
                                width: 1
                            },
                            border: {
                                visible: false,
                                width: 1,
                                color: '#808080',
                                dashStyle: 'solid'
                            }
                        },
                        hoverStyle: {
                            hatching: 'none',
                            color: '#000000',
                            border: {
                                visible: false,
                                width: 1,
                                color: '#000000'
                            },
                            width: 3
                        },
                        selectionStyle: {
                            hatching: 'right',
                            color: '#000000',
                            border: {
                                visible: false,
                                width: 1,
                                color: '#000000'
                            },
                            width: 3
                        }
                    }
            }
        });
    series.BaseSeries = BaseSeries
})(jQuery, DevExpress);

// Module viz, file lineSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        eventsConsts = series.consts.events,
        BaseSeries = series.BaseSeries;
    var LineSeries = BaseSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                options.specificType = options.specificType || 'line';
                this.callBase(renderer, data, options, isRangeSeries);
                this.paths = this.paths || []
            },
            drawSegment: function(segment, attributes) {
                return this.renderer.createPath(segment, attributes)
            },
            drawSeriesData: function(seriesGroup, labelsGroup) {
                var self = this;
                self.preparedSegments = [];
                if (!self.points.length)
                    return;
                self.paths = [];
                $.each(this.segments, function(index) {
                    self.prepareSegments(index)
                });
                if (self.styles.attributes.strokeWidth > 0) {
                    $.each(self.preparedSegments, function(_, segment) {
                        self.paths.push(self.drawSegment(segment, self.styles.attributes).append(seriesGroup))
                    });
                    self.drawPathTracker()
                }
                self.callBase(seriesGroup, labelsGroup)
            },
            prepareSegments: function(index) {
                this.preparedSegments = this.preparedSegments || [];
                this.preparedSegments[index] = this.segments[index]
            },
            drawPathTracker: function() {
                var self = this,
                    styles = this.styles,
                    strokeWidth;
                if (!self.preparedSegments) {
                    self.preparedSegments = [];
                    $.each(self.segments, function(index) {
                        self.prepareSegments(index)
                    })
                }
                if (this._suppressTrackers)
                    return;
                strokeWidth = styles.attributes.strokeWidth < 20 ? 20 : styles.attributes.strokeWidth;
                $.each(this.preparedSegments, function(_, segment) {
                    var tracker = self.drawSegment(segment, {
                            strokeWidth: strokeWidth,
                            stroke: 'grey',
                            opacity: 0.0001
                        }).append(self.options.seriesTrackerGroup);
                    self.initEventTriggering(tracker)
                });
                return this
            },
            applyNormalStyle: function(mode) {
                var self = this;
                if (this.paths) {
                    $.each(this.paths, function(_, path) {
                        path.applySettings(self.styles.states.normal)
                    });
                    return self.callBase(mode)
                }
            },
            applyHoverStyle: function(mode) {
                var self = this;
                if (this.paths) {
                    $.each(this.paths, function(_, path) {
                        path.applySettings(self.styles.states.hover)
                    });
                    return self.callBase(mode)
                }
            },
            applySelectionStyle: function(mode) {
                var self = this;
                if (this.paths) {
                    $.each(this.paths, function(_, path) {
                        if (path)
                            path.applySettings(self.styles.states.selected)
                    });
                    return self.callBase(mode)
                }
            },
            animate: function() {
                this.callBase();
                this.animatePath()
            },
            animatePath: function() {
                var self = this,
                    segments = self.preparedSegments;
                if (segments)
                    $.each(self.paths, function(i, path) {
                        var fromPoints = self.getZeroPathPoints(i);
                        path.applySettings({points: fromPoints});
                        path.animate({points: segments[i]})
                    })
            },
            getZeroPathPoints: function(i) {
                return $.map(this.preparedSegments[i], function(pt) {
                        return pt.getDefaultCoords()
                    })
            },
            adjustOptions: function() {
                var styles = this.styles,
                    attributes = styles.attributes,
                    hover = styles.states.hover,
                    selected = styles.states.selected,
                    normal = styles.states.normal;
                attributes.stroke = attributes.fill;
                attributes.fill = 'none';
                attributes.strokeWidth = attributes.lineWidth;
                normal.stroke = normal.fill;
                normal.fill = 'none';
                normal.strokeWidth = normal.lineWidth;
                hover.stroke = hover.fill;
                hover.fill = 'none';
                hover.strokeWidth = hover.lineWidth;
                selected.stroke = selected.fill;
                selected.fill = 'none';
                selected.strokeWidth = selected.lineWidth
            }
        });
    series.LineSeries = LineSeries
})(jQuery, DevExpress);

// Module viz, file areaSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        LineSeries = series.LineSeries;
    var AreaSeries = LineSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                this.type = options.specificType = options.specificType || 'area';
                this.callBase(renderer, data, options, isRangeSeries);
                this.areas = this.areas || [];
                this.areaSegments = this.areaSegments || []
            },
            drawSeriesData: function(seriesGroup, labelsGroup) {
                var self = this;
                self.resetLineColors();
                self.areas = [];
                if (!self.points.length)
                    return;
                self.paths = [];
                $.each(this.segments, function(index) {
                    self.prepareSegments(index)
                });
                $.each(self.preparedSegments, function(index, segment) {
                    self.prepareAreaPoints(index);
                    self.areas.push(self.renderer.createArea(self.areaSegments[index], self.styles.area).append(seriesGroup))
                });
                self.drawAreaTracker();
                if (self.styles.attributes.strokeWidth > 0)
                    $.each(self.preparedSegments, function(_, segment) {
                        self.paths.push(self.drawSegment(segment, self.styles.attributes).append(seriesGroup))
                    });
                self.drawPoints(seriesGroup, labelsGroup);
                if (self.hoverPatternId) {
                    self.styles.area.states.hover.fill = self.hoverPatternId;
                    self.styles.area.states.selected.fill = self.selectedPatternId;
                    self.styles.states.hover.fill = 'none';
                    self.styles.states.selected.fill = 'none'
                }
                return self
            },
            resetLineColors: function() {
                var styles = this.styles,
                    attributes = styles.attributes,
                    states = styles.states,
                    hover = states.hover,
                    selected = states.selected,
                    normal = states.normal;
                attributes.fill = 'none';
                delete attributes.lineWidth;
                normal.fill = 'none';
                delete normal.lineWidth;
                hover.fill = 'none';
                delete hover.lineWidth;
                selected.fill = 'none';
                delete selected.lineWidth
            },
            drawAreaTracker: function() {
                var self = this;
                if (this._suppressTrackers)
                    return;
                $.each(this.areaSegments, function(_, segment) {
                    var tracker = self.renderer.createArea(segment, {
                            strokeWidth: 0,
                            fill: 'grey',
                            opacity: 0.0001
                        }).append(self.options.seriesTrackerGroup);
                    self.initEventTriggering(tracker)
                });
                return series
            },
            prepareAreaPoints: function(index) {
                var segments = this.preparedSegments;
                var fwPoints = $.map(segments[index], function(pt) {
                        return pt.getCoords()
                    });
                var bwPoints = $.map(segments[index].slice().reverse(), function(pt) {
                        return pt.getCoords(true)
                    });
                this.areaSegments[index] = fwPoints.concat(bwPoints)
            },
            applyNormalStyle: function(mode) {
                var self = this;
                if (this.areas)
                    $.each(this.areas, function(_, area) {
                        area.applySettings(self.styles.area.states.normal)
                    });
                return this.callBase(mode)
            },
            applyHoverStyle: function(mode) {
                var self = this;
                if (this.areas)
                    $.each(this.areas, function(_, area) {
                        area.applySettings(self.styles.area.states.hover)
                    });
                return this.callBase(mode)
            },
            applySelectionStyle: function(mode) {
                var self = this;
                if (this.areas)
                    $.each(this.areas, function(_, area) {
                        area.applySettings(self.styles.area.states.selected)
                    });
                return this.callBase(mode)
            },
            animate: function() {
                var self = this;
                this.callBase();
                if (this.preparedSegments)
                    $.each(this.areas, function(i, area) {
                        var fromPoints = self.getZeroAreaPoints(i);
                        area.applySettings({points: fromPoints});
                        area.animate({points: self.areaSegments[i]})
                    })
            },
            getZeroAreaPoints: function(i) {
                var fwPoints,
                    bwPoints,
                    segments = this.preparedSegments;
                fwPoints = $.map(segments[i], function(pt) {
                    return pt.getDefaultCoords()
                });
                bwPoints = $.map(segments[i].slice().reverse(), function(pt) {
                    return pt.getDefaultCoords()
                });
                return fwPoints.concat(bwPoints)
            },
            adjustOptions: function() {
                var styles = this.styles,
                    attributes = styles.attributes,
                    states = styles.states,
                    hover = states.hover,
                    selected = states.selected,
                    normal = states.normal,
                    areaNormal = {},
                    areaHover = {},
                    areaSelected = {},
                    opacity;
                opacity = 'opacity' in attributes ? attributes.opacity : 0.5;
                areaNormal = {
                    fill: normal.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity
                };
                areaHover = {
                    fill: hover.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity
                };
                areaSelected = {
                    fill: selected.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity
                };
                styles.area = {
                    fill: attributes.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity,
                    states: {
                        normal: areaNormal,
                        hover: areaHover,
                        selected: areaSelected
                    }
                }
            }
        });
    series.AreaSeries = AreaSeries
})(jQuery, DevExpress);

// Module viz, file barSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        BaseSeries = series.BaseSeries;
    var BAR_ZERO_VALUE_MARGIN_PRIORITY = 20;
    var BarSeries = BaseSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                options.specificType = options.specificType || 'bar';
                this.callBase(renderer, data, options, isRangeSeries);
                this.stackName = options.stack || 'default';
                this.rects = []
            },
            getStackName: function() {
                if (this.type === 'stackedbar' || this.type === 'fullstackedbar')
                    return this.stackName;
                return null
            },
            setBarZeroPadding: function(range, val, prefix) {
                if (val === 0)
                    this.setPadding(range, prefix, 0, BAR_ZERO_VALUE_MARGIN_PRIORITY)
            },
            getRangeData: function() {
                var range = this.callBase();
                if (!range)
                    return range;
                if (this.isRangeSeries)
                    return range;
                if (!this.options.rotated)
                    range.keepValueMarginsX = true;
                else
                    range.keepValueMarginsY = true;
                if (range.minY !== undefined && !this.options.rotated) {
                    range.minY = range.minY > 0 ? 0 : range.minY;
                    this.setBarZeroPadding(range, range.minY, 'minValueMarginY');
                    range.maxY = range.maxY < 0 ? 0 : range.maxY;
                    if (range.maxY === 0 || range.maxY > 0 && range.minY < 0) {
                        range.minValueMarginY = range.maxValueMarginY;
                        range.minValueMarginYPriority = range.maxValueMarginYPriority
                    }
                    this.setBarZeroPadding(range, range.maxY, 'maxValueMarginY')
                }
                else if (range.minX !== undefined && this.options.rotated) {
                    range.minX = range.minX > 0 ? 0 : range.minX;
                    this.setBarZeroPadding(range, range.minX, 'minValueMarginX');
                    range.maxX = range.maxX < 0 ? 0 : range.maxX;
                    if (range.maxX === 0 || range.maxX > 0 && range.minX < 0) {
                        range.minValueMarginX = range.maxValueMarginX;
                        range.minValueMarginXPriority = range.maxValueMarginXPriority
                    }
                    this.setBarZeroPadding(range, range.maxX, 'maxValueMarginX')
                }
                return range
            },
            drawSeriesData: function(seriesGroup, labelsGroup) {
                var series = this;
                if (series.points.length && series.hoverPatternId) {
                    series.styles.point.states.hover.fill = series.hoverPatternId;
                    series.styles.point.states.selected.fill = series.selectedPatternId
                }
                return this.callBase(seriesGroup, labelsGroup)
            },
            adjustOptions: function() {
                var styles = this.styles,
                    attributes = styles.attributes,
                    hover = styles.states.hover,
                    selected = styles.states.selected,
                    normal = styles.states.normal,
                    pointAttributes = styles.point.attributes,
                    pointHover = styles.point.states.hover,
                    pointSelected = styles.point.states.selected,
                    pointNormal = styles.point.states.normal;
                $.extend(true, pointAttributes, attributes);
                $.extend(true, pointHover, hover);
                $.extend(true, pointSelected, selected);
                $.extend(true, pointNormal, normal);
                pointHover.r = pointSelected.r = pointNormal.r = pointAttributes.r;
                styles.point.visible = true
            }
        });
    series.BarSeries = BarSeries
})(jQuery, DevExpress);

// Module viz, file candleStickSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        isDefined = DX.utils.isDefined,
        BaseSeries = series.BaseSeries;
    var CandleStickSeries = BaseSeries.inherit({
            ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'candlestick';
                this.callBase(renderer, data, options)
            },
            getRangeData: function() {
                var self = this,
                    options = self.options,
                    rotated = options.rotated,
                    valAxis = rotated ? 'X' : 'Y',
                    argAxis = rotated ? 'Y' : 'X',
                    vals = [],
                    args = [];
                var compareNumeric = function(a, b) {
                        return a - b
                    };
                $.each(this.points, function(i, val) {
                    isDefined(val.argument) && args.push(val.argument);
                    if (val.hasValue()) {
                        vals.push(val.highValue);
                        vals.push(val.lowValue)
                    }
                });
                self.rangeData = {};
                if (vals.length) {
                    vals.sort(compareNumeric);
                    self.rangeData['max' + valAxis] = vals[vals.length - 1];
                    self.rangeData['min' + valAxis] = vals[0]
                }
                if (args.length && !(options.argumentAxisType === 'discrete')) {
                    args.sort(compareNumeric);
                    self.rangeData['min' + argAxis] = args[0];
                    self.rangeData['max' + argAxis] = args[args.length - 1]
                }
                else
                    self.rangeData['categories' + argAxis] = args;
                return this.rangeData
            },
            _parseInputData: function(data) {
                var self = this,
                    level,
                    pointFactory = series.pointFactory,
                    argumentField = this.options.argumentField || 'date',
                    openValueField = this.options.openValueField || 'open',
                    highValueField = this.options.highValueField || 'high',
                    lowValueField = this.options.lowValueField || 'low',
                    closeValueField = this.options.closeValueField || 'close',
                    tagField = this.options.tagField || 'tag',
                    pointStyles = this.styles.point,
                    reductionColor = this.styles.reduction.color,
                    innerColor = this.styles.reduction.innerColor,
                    prepData,
                    prevLevelValue;
                this.points = [];
                this.segments = [];
                if (!data.length)
                    return;
                prepData = self._checkAndPrepareInputData(data, argumentField, [openValueField, highValueField, lowValueField, closeValueField]);
                self._validationResult = {
                    inputNotations: 0,
                    error: null
                };
                switch ((this.styles.reduction.level || '').toLowerCase()) {
                    case'open':
                        level = openValueField;
                        break;
                    case'high':
                        level = highValueField;
                        break;
                    case'low':
                        level = lowValueField;
                        break;
                    default:
                        level = closeValueField;
                        break
                }
                this.points = $.map(prepData, function(val, i) {
                    var pointStylesReduct = $.extend(true, {}, pointStyles || {});
                    if (val[openValueField] !== null && val[highValueField] !== null && val[lowValueField] !== null & val[closeValueField] !== null) {
                        if (i != 0)
                            if (prevLevelValue != null && val[level] < prevLevelValue) {
                                pointStylesReduct.attributes.fill = pointStylesReduct.states.normal.fill = pointStylesReduct.states.hover.fill = reductionColor;
                                pointStylesReduct.attributes.stroke = pointStylesReduct.states.normal.stroke = pointStylesReduct.states.hover.stroke = reductionColor
                            }
                        prevLevelValue = val[level];
                        if (val[openValueField] < val[closeValueField])
                            pointStylesReduct.attributes.fill = pointStylesReduct.states.normal.fill = pointStylesReduct.states.hover.fill = innerColor
                    }
                    return pointFactory.createPoint(self.type, {
                            openValue: val[openValueField],
                            highValue: val[highValueField],
                            lowValue: val[lowValueField],
                            closeValue: val[closeValueField],
                            argument: val[argumentField],
                            options: pointStylesReduct,
                            tag: val.tag,
                            reductionValue: val[level],
                            series: self
                        })
                });
                this._segmenting()
            },
            _parseOptions: function(options) {
                this.callBase(options);
                $.extend(true, this.options, {
                    openValueField: options.openValueField,
                    closeValueField: options.closeValueField,
                    highValueField: options.highValueField,
                    lowValueField: options.lowValueField
                })
            },
            drawSeriesData: function(seriesGroup, labelsGroup) {
                var series = this;
                $.each(series.points, function(i, point) {
                    var pId = series.getPointSpecificPatternId(series.hoverPatternColor, series.styles.states.hover.hatching);
                    if (pId)
                        point.options.states.hover.fill = pId;
                    pId = series.getPointSpecificPatternId(series.selectedPatternColor, series.styles.states.selected.hatching);
                    if (pId)
                        point.options.states.selected.fill = pId
                });
                this.callBase(seriesGroup, labelsGroup);
                return this
            },
            createPattern: function(){},
            getPointSpecificPatternId: function(color, hatching) {
                var pattern = this.renderer.createPattern(color, hatching);
                return pattern.id
            },
            adjustOptions: function() {
                var styles = this.styles,
                    attributes = styles.attributes,
                    hover = styles.states.hover,
                    selected = styles.states.selected,
                    normal = styles.states.normal,
                    pointAttributes = styles.point.attributes,
                    pointHover = styles.point.states.hover,
                    pointSelected = styles.point.states.selected,
                    pointNormal = styles.point.states.normal;
                attributes.stroke = attributes.fill;
                attributes.strokeWidth = attributes.lineWidth;
                normal.stroke = normal.fill;
                normal.strokeWidth = normal.lineWidth;
                hover.stroke = hover.fill;
                hover.strokeWidth = hover.lineWidth;
                selected.stroke = selected.fill;
                selected.strokeWidth = selected.lineWidth;
                $.extend(true, pointAttributes, attributes);
                $.extend(true, pointHover, hover);
                $.extend(true, pointSelected, selected);
                $.extend(true, pointNormal, normal);
                pointHover.r = pointSelected.r = pointNormal.r = pointAttributes.r = 0;
                styles.point.visible = true
            }
        });
    series.CandleStickSeries = CandleStickSeries
})(jQuery, DevExpress);

// Module viz, file stockSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        CandleStickSeries = series.CandleStickSeries;
    var StockSeries = CandleStickSeries.inherit({ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'stock';
                this.callBase(renderer, data, options)
            }});
    series.StockSeries = StockSeries
})(jQuery, DevExpress);

// Module viz, file splineSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        utils = DX.utils,
        LineSeries = series.LineSeries;
    var SplineSeries = LineSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                options.specificType = options.specificType || 'spline';
                this.callBase(renderer, data, options, isRangeSeries)
            },
            drawSegment: function(segment, attributes) {
                return this.renderer.createBezierPath(segment, attributes)
            },
            prepareSegments: function(index) {
                var self = this,
                    bezierPoints = [],
                    pointsCopy = self.segments[index];
                self.preparedSegments = self.preparedSegments || [];
                var checkExtr = function(otherPointCoord, pointCoord, controlCoord) {
                        return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord
                    };
                var clonePoint = function(point, newX, newY) {
                        var p = utils.clone(point);
                        p.x = newX;
                        p.y = newY;
                        return p
                    };
                if (pointsCopy.length !== 1)
                    $.each(pointsCopy, function(i, curPoint) {
                        var leftControlX,
                            leftControlY,
                            rightControlX,
                            rightControlY,
                            prevPoint,
                            nextPoint,
                            xCur,
                            yCur,
                            x1,
                            x2,
                            y1,
                            y2,
                            delta,
                            lambda = 0.5,
                            curIsExtremum,
                            leftPoint,
                            rightPoint,
                            a,
                            b,
                            c,
                            xc,
                            yc,
                            shift;
                        if (!i) {
                            bezierPoints.push(curPoint);
                            bezierPoints.push(curPoint);
                            return
                        }
                        prevPoint = pointsCopy[i - 1];
                        if (i < pointsCopy.length - 1) {
                            nextPoint = pointsCopy[i + 1];
                            xCur = curPoint.x;
                            yCur = curPoint.y;
                            x1 = prevPoint.x;
                            x2 = nextPoint.x;
                            y1 = prevPoint.y;
                            y2 = nextPoint.y;
                            curIsExtremum = !!(!self.options.rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || self.options.rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));
                            if (curIsExtremum)
                                if (!self.options.rotated) {
                                    rightControlY = leftControlY = yCur;
                                    rightControlX = (xCur + nextPoint.x) / 2;
                                    leftControlX = (xCur + prevPoint.x) / 2
                                }
                                else {
                                    rightControlX = leftControlX = xCur;
                                    rightControlY = (yCur + nextPoint.y) / 2;
                                    leftControlY = (yCur + prevPoint.y) / 2
                                }
                            else {
                                a = y2 - y1;
                                b = x1 - x2;
                                c = y1 * x2 - x1 * y2;
                                if (!self.options.rotated) {
                                    xc = xCur;
                                    yc = -1 * (a * xc + c) / b;
                                    shift = yc - yCur || 0;
                                    y1 -= shift;
                                    y2 -= shift
                                }
                                else {
                                    yc = yCur;
                                    xc = -1 * (b * yc + c) / a;
                                    shift = xc - xCur || 0;
                                    x1 -= shift;
                                    x2 -= shift
                                }
                                rightControlX = (xCur + lambda * x2) / (1 + lambda);
                                rightControlY = (yCur + lambda * y2) / (1 + lambda);
                                leftControlX = (xCur + lambda * x1) / (1 + lambda);
                                leftControlY = (yCur + lambda * y1) / (1 + lambda)
                            }
                            if (!self.options.rotated) {
                                leftControlY = checkExtr(prevPoint.y, yCur, leftControlY);
                                rightControlY = checkExtr(nextPoint.y, yCur, rightControlY)
                            }
                            else {
                                leftControlX = checkExtr(prevPoint.x, xCur, leftControlX);
                                rightControlX = checkExtr(nextPoint.x, xCur, rightControlX)
                            }
                            leftPoint = clonePoint(curPoint, leftControlX, leftControlY);
                            rightPoint = clonePoint(curPoint, rightControlX, rightControlY);
                            bezierPoints.push(leftPoint, curPoint, rightPoint)
                        }
                        else {
                            bezierPoints.push(curPoint, curPoint);
                            return
                        }
                    });
                else
                    bezierPoints.push(pointsCopy[0]);
                self.preparedSegments[index] = bezierPoints
            }
        });
    series.SplineSeries = SplineSeries
})(jQuery, DevExpress);

// Module viz, file splineAreaSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        SplineSeries = series.SplineSeries;
    var SplineAreaSeries = SplineSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                options.specificType = options.specificType || 'splinearea';
                this.callBase(renderer, data, options, isRangeSeries);
                this.areas = this.areas || [];
                this.areaSegments = this.areaSegments || []
            },
            drawSeriesData: function(seriesGroup, labelsGroup) {
                if (!this.points.length)
                    return;
                var self = this;
                if (!this.points.length)
                    return;
                this.resetLineColors();
                $.each(this.segments, function(index) {
                    self.prepareSegments(index)
                });
                this.areas = [];
                $.each(self.preparedSegments, function(index, segment) {
                    self.prepareBezierAreaPoints(index);
                    self.areas.push(self.renderer.createBezierArea(self.areaSegments[index], self.styles.area).append(seriesGroup))
                });
                self.drawAreaTracker();
                if (self.styles.attributes.strokeWidth > 0)
                    $.each(self.preparedSegments, function(_, segment) {
                        self.paths.push(self.drawSegment(segment, self.styles.attributes).append(seriesGroup))
                    });
                self.drawPoints(seriesGroup, labelsGroup);
                if (self.hoverPatternId) {
                    self.styles.area.states.hover.fill = self.hoverPatternId;
                    self.styles.area.states.selected.fill = self.selectedPatternId;
                    self.styles.states.hover.fill = 'none';
                    self.styles.states.selected.fill = 'none';
                    self.styles.states.hover.stroke = self.hoverPatternColor;
                    self.styles.states.selected.stroke = self.selectedPatternColor
                }
                return self
            },
            resetLineColors: function() {
                var styles = this.styles,
                    attributes = styles.attributes,
                    states = styles.states,
                    hover = states.hover,
                    selected = states.selected,
                    normal = states.normal;
                attributes.fill = 'none';
                delete attributes.lineWidth;
                normal.fill = 'none';
                delete normal.lineWidth;
                hover.fill = 'none';
                delete hover.lineWidth;
                selected.fill = 'none';
                delete selected.lineWidth
            },
            drawAreaTracker: function() {
                var self = this;
                if (this._suppressTrackers)
                    return;
                $.each(this.areaSegments, function(_, segment) {
                    var tracker = self.renderer.createBezierArea(segment, {
                            strokeWidth: 0,
                            fill: 'grey',
                            opacity: 0.0001
                        }).append(self.options.seriesTrackerGroup);
                    self.initEventTriggering(tracker)
                });
                return series
            },
            prepareBezierAreaPoints: function(index) {
                var segments = this.preparedSegments;
                var fwPoints = $.map(segments[index], function(pt) {
                        return pt.getCoords()
                    });
                var bwPoints = $.map(segments[index].slice().reverse(), function(pt) {
                        return pt.getCoords(true)
                    });
                var lastFwPoint = fwPoints[fwPoints.length - 1];
                var firstBwPoint = bwPoints[0];
                this.areaSegments[index] = fwPoints.concat({
                    x: lastFwPoint.x,
                    y: lastFwPoint.y
                }, {
                    x: firstBwPoint.x,
                    y: firstBwPoint.y
                }, bwPoints)
            },
            applyNormalStyle: function(mode) {
                var self = this;
                if (this.areas)
                    $.each(this.areas, function(_, area) {
                        area.applySettings(self.styles.area.states.normal)
                    });
                return this.callBase(mode)
            },
            applyHoverStyle: function(mode) {
                var self = this;
                if (this.areas)
                    $.each(this.areas, function(_, area) {
                        area.applySettings(self.styles.area.states.hover)
                    });
                return this.callBase(mode)
            },
            applySelectionStyle: function(mode) {
                var self = this;
                if (this.areas)
                    $.each(this.areas, function(_, area) {
                        area.applySettings(self.styles.area.states.selected)
                    });
                return this.callBase(mode)
            },
            animate: function() {
                var self = this;
                this.callBase();
                if (this.preparedSegments)
                    $.each(this.areas, function(i, area) {
                        var fromPoints = self.getZeroAreaPoints(i);
                        area.applySettings({points: fromPoints});
                        area.animate({points: self.areaSegments[i]})
                    })
            },
            getZeroAreaPoints: function(i) {
                var fwPoints = $.map(this.preparedSegments[i], function(pt) {
                        return pt.getDefaultCoords()
                    });
                var bwPoints = $.map(this.preparedSegments[i].slice().reverse(), function(pt) {
                        return pt.getDefaultCoords()
                    });
                var lastFwPoint = fwPoints[fwPoints.length - 1];
                var firstBwPoint = bwPoints[0];
                return fwPoints.concat({
                        x: lastFwPoint.x,
                        y: lastFwPoint.y
                    }, {
                        x: firstBwPoint.x,
                        y: firstBwPoint.y
                    }, bwPoints)
            },
            adjustOptions: function() {
                var styles = this.styles,
                    attributes = styles.attributes,
                    states = styles.states,
                    hover = states.hover,
                    selected = states.selected,
                    normal = states.normal,
                    areaNormal = {},
                    areaHover = {},
                    areaSelected = {},
                    opacity;
                opacity = 'opacity' in attributes ? attributes.opacity : 0.5;
                areaNormal = {
                    fill: normal.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity
                };
                areaHover = {
                    fill: hover.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity
                };
                areaSelected = {
                    fill: selected.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity
                };
                styles.area = {
                    fill: attributes.fill,
                    stroke: 'none',
                    strokeWidth: 0,
                    opacity: opacity,
                    states: {
                        normal: areaNormal,
                        hover: areaHover,
                        selected: areaSelected
                    }
                }
            }
        });
    series.SplineAreaSeries = SplineAreaSeries
})(jQuery, DevExpress);

// Module viz, file scatterSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        BaseSeries = series.BaseSeries;
    var ScatterSeries = BaseSeries.inherit({ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'scatter';
                this.callBase(renderer, data, options)
            }});
    series.ScatterSeries = ScatterSeries
})(jQuery, DevExpress);

// Module viz, file rangeAreaSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        AreaSeries = series.AreaSeries;
    var RangeAreaSeries = AreaSeries.inherit({ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'rangearea';
                this.callBase(renderer, data, options, true)
            }});
    series.RangeAreaSeries = RangeAreaSeries
})(jQuery, DevExpress);

// Module viz, file rangeSplineAreaSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        SplineAreaSeries = series.SplineAreaSeries;
    var RangeSplineAreaSeries = SplineAreaSeries.inherit({ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'rangesplinearea';
                this.callBase(renderer, data, options, true)
            }});
    series.RangeSplineAreaSeries = RangeSplineAreaSeries
})(jQuery, DevExpress);

// Module viz, file rangeBarSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        BarSeries = series.BarSeries;
    var RangeBarSeries = BarSeries.inherit({ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'rangebar';
                this.callBase(renderer, data, options, true)
            }});
    series.RangeBarSeries = RangeBarSeries
})(jQuery, DevExpress);

// Module viz, file piePoint.js

(function($, DX) {
    var series = DX.viz.charts.series,
        core = DX.viz.core,
        BasePoint = series.BasePoint,
        round = Math.round;
    var PiePoint = BasePoint.inherit({
            ctor: function(data) {
                this.centerX = 300;
                this.centerY = 150;
                this.radiusOuter = 120;
                this.radiusInner = 0;
                this.INDENT_FROM_PIE = 30;
                this.CONNECTOR_LENGTH = 20;
                this.setLabelEllipsis = false;
                this.callBase(data);
                this.minValue = 0;
                this.tag = data.tag
            },
            translate: function(translator) {
                var self = this;
                self.translator = translator = translator || self.translator;
                if (!self.translator)
                    return;
                self.fromAngle = translator.translate(self.minValue);
                self.toAngle = translator.translate(self.value);
                self.middleAngle = translator.translate((self.value - self.minValue) / 2 + self.minValue)
            },
            correctValue: function(correction, percent) {
                var self = this;
                self.value += correction;
                self.minValue += correction;
                self.percent = percent;
                self.labelFormatObject.percent = percent
            },
            getTooltipCoords: function() {
                var angleFunctions = DX.utils.getCosAndSin(this.middleAngle);
                return {
                        x: this.centerX + (this.radiusInner + (this.radiusOuter - this.radiusInner) / 2) * angleFunctions.cos,
                        y: this.centerY - (this.radiusInner + (this.radiusOuter - this.radiusInner) / 2) * angleFunctions.sin,
                        offset: 0
                    }
            },
            correctPosition: function(correction) {
                var self = this;
                self.radiusInner = correction.radiusInner;
                self.radiusOuter = correction.radiusOuter;
                self.centerX = correction.centerX;
                self.centerY = correction.centerY
            },
            drawMarker: function(renderer, group) {
                var arc = renderer.createArc(this.centerX, this.centerY, this.radiusOuter, this.radiusInner, this.toAngle, this.fromAngle, this.options.attributes);
                arc.append(group);
                this.graphic = arc
            },
            drawTrackerMarker: function(renderer, trackerGroup) {
                var point = this;
                var options = point.options;
                var trackerArc = renderer.createArc(this.centerX, this.centerY, this.radiusOuter, this.radiusInner, this.toAngle, this.fromAngle, {
                        stroke: 'none',
                        fill: 'grey',
                        opacity: 0.0001
                    });
                trackerArc.append(trackerGroup);
                this.initEventTriggering(trackerArc)
            },
            correctLabel: function() {
                this.correctLabelPosition();
                this.checkEllipsis();
                this.correctBackgroundPosition();
                this.rotateLabel();
                this.checkLabelPosition()
            },
            correctLabelPosition: function() {
                var bbox = this.label.getBBox(),
                    labelOptions = this.options.label,
                    angleFunctions = DX.utils.getCosAndSin(this.middleAngle),
                    align = 'center',
                    rad = this.radiusOuter + labelOptions.radialOffset,
                    x,
                    y;
                switch (labelOptions.position) {
                    case'outside':
                        rad += this.INDENT_FROM_PIE;
                        if (angleFunctions.cos > 0.1)
                            align = 'left';
                        else if (angleFunctions.cos < -0.1)
                            align = 'right';
                        x = this.centerX + rad * angleFunctions.cos;
                        break;
                    case'inside':
                        rad -= this.INDENT_FROM_PIE;
                        x = this.centerX + rad * angleFunctions.cos;
                        break;
                    case'columns':
                        rad += this.CONNECTOR_LENGTH;
                        if (angleFunctions.cos > 0) {
                            align = 'right';
                            x = this.series.canvas.width - this.series.canvas.right
                        }
                        else if (angleFunctions.cos < 0) {
                            align = 'left';
                            x = this.series.canvas.left
                        }
                        break
                }
                y = round(this.label.settings.y + this.centerY - rad * angleFunctions.sin - bbox.y - bbox.height / 2);
                this.label.applySettings({
                    x: x,
                    y: y,
                    align: align
                })
            },
            correctConnectorPosition: function() {
                if (this.options.label.position === 'inside')
                    return;
                if (!this.connector)
                    return;
                var angleFunctions = DX.utils.getCosAndSin(round(this.middleAngle)),
                    attributes = this.series.styles.attributes,
                    borderWidth = this.series.userOptions.containerBackgroundColor === attributes.stroke ? ~~(attributes.strokeWidth / 2) : ~~(-attributes.strokeWidth / 2),
                    rad = this.radiusOuter,
                    x1 = round(this.centerX + (rad - borderWidth) * angleFunctions.cos),
                    y1 = round(this.centerY - (rad - borderWidth) * angleFunctions.sin),
                    x2,
                    y2,
                    x3,
                    y3,
                    box,
                    labelOptions = this.options.label,
                    connector;
                x2 = round(this.centerX + (rad + labelOptions.radialOffset + this.CONNECTOR_LENGTH) * angleFunctions.cos);
                if (labelOptions.position === 'outside') {
                    y2 = round(this.centerY - (rad + labelOptions.radialOffset + this.CONNECTOR_LENGTH) * angleFunctions.sin);
                    this.connector.applySettings({points: [x1, y1, x2, y2]})
                }
                if (labelOptions.position === 'columns') {
                    box = this.insideLabelGroup.getBBox();
                    box.x = box.x + (this.insideLabelGroup.settings.translateX || 0);
                    box.y = box.y + (this.insideLabelGroup.settings.translateY || 0);
                    y2 = box.y + box.height / 2;
                    if (this.labelBackground)
                        x3 = box.x + box.width / 2;
                    else if (angleFunctions.cos < 0)
                        x3 = box.x + box.width;
                    else if (angleFunctions.cos > 0)
                        x3 = box.x;
                    y3 = y2;
                    this.connector.applySettings({points: [{
                                x: x1,
                                y: y1
                            }, {
                                x: x2,
                                y: y2
                            }, {
                                x: x3,
                                y: y3
                            }]})
                }
            },
            rotateLabel: function() {
                var labelOptions = this.options.label,
                    rad = this.radiusOuter + labelOptions.radialOffset,
                    angleFunctions = DX.utils.getCosAndSin(this.middleAngle),
                    x,
                    y,
                    box = this.insideLabelGroup.getBBox();
                switch (labelOptions.position) {
                    case'outside':
                        x = this.centerX + (rad + labelOptions.radialOffset + this.CONNECTOR_LENGTH) * angleFunctions.cos;
                        y = this.centerY - (rad + labelOptions.radialOffset + this.CONNECTOR_LENGTH) * angleFunctions.sin;
                        break;
                    case'inside':
                        x = box.x + box.width / 2;
                        y = box.y + box.height / 2;
                        break;
                    case'columns':
                        x = box.x + box.width / 2;
                        y = box.y + box.height / 2;
                        break
                }
                this.insideLabelGroup.applySettings({
                    x: x,
                    y: y,
                    rotate: labelOptions.rotationAngle
                })
            },
            checkEllipsis: function() {
                var self = this,
                    i,
                    LABEL_OFFSET = 10,
                    labelBox,
                    text,
                    textLength = 0,
                    linesLength = [],
                    numLastSpan = [],
                    maxLength,
                    numSpan,
                    index,
                    x,
                    y,
                    width,
                    rotationAngleFunction = DX.utils.getCosAndSin(self.options.label.rotationAngle),
                    canvas = self.series.canvas,
                    labelOptions = this.options.label,
                    angleFunctions = DX.utils.getCosAndSin(this.middleAngle),
                    borderX = this.centerX + (this.radiusOuter + this.CONNECTOR_LENGTH) * angleFunctions.cos;
                if (!self.label.tspans || !self.setLabelEllipsis)
                    return;
                labelBox = self.label.getBBox();
                x = labelBox.x + labelBox.width < self.centerX ? labelBox.x + labelBox.width : labelBox.x;
                y = labelBox.y + labelBox.height / 2;
                width = labelBox.x + labelBox.width < self.centerX ? -labelBox.width : labelBox.width;
                if (y + width * rotationAngleFunction.sin > canvas.height - canvas.bottom + LABEL_OFFSET || y + width * rotationAngleFunction.sin < canvas.top - LABEL_OFFSET || x + width * rotationAngleFunction.cos < canvas.left - LABEL_OFFSET || x + width * rotationAngleFunction.cos > canvas.width - canvas.right + LABEL_OFFSET || labelOptions.position === 'columns' && (angleFunctions.cos < 0 && borderX < x || angleFunctions.cos > 0 && borderX > x))
                    for (i = 0; i < self.label.tspans.length; i++) {
                        textLength += self.label.tspans[i].element.getNumberOfChars();
                        if (!self.label.tspans[i + 1] || self.label.tspans[i + 1].settings.dy > 0) {
                            linesLength.push(textLength);
                            numLastSpan.push(i);
                            textLength = 0
                        }
                    }
                while (y + width * rotationAngleFunction.sin > canvas.height - canvas.bottom + LABEL_OFFSET || y + width * rotationAngleFunction.sin < canvas.top - LABEL_OFFSET || x + width * rotationAngleFunction.cos < canvas.left - LABEL_OFFSET || x + width * rotationAngleFunction.cos > canvas.width - canvas.right + LABEL_OFFSET || labelOptions.position === 'columns' && (angleFunctions.cos < 0 && borderX < x || angleFunctions.cos > 0 && borderX > x)) {
                    maxLength = Math.max.apply(null, linesLength);
                    if (maxLength === 0)
                        break;
                    index = $.inArray(maxLength, linesLength);
                    numSpan = numLastSpan[index];
                    if (self.label.tspans[numSpan].element.textContent === "...") {
                        if (self.label.tspans[numSpan].settings.dy > 0 || !self.label.tspans[numSpan - 1])
                            linesLength[index] = 0;
                        else if (self.label.tspans[numSpan - 1]) {
                            self.label.tspans[numSpan].element.textContent = '';
                            numLastSpan[index] -= 1;
                            self.label.tspans[numSpan - 1].element.textContent += "..."
                        }
                    }
                    else {
                        text = self.label.tspans[numSpan].element.textContent;
                        text = text.substr(0, text.length - 1 - 3) + "...";
                        self.label.tspans[numSpan].element.textContent = text;
                        linesLength[index] -= 1
                    }
                    labelBox = self.label.getBBox();
                    x = labelBox.x + labelBox.width < self.centerX ? labelBox.x + labelBox.width : labelBox.x;
                    y = labelBox.y + labelBox.height / 2;
                    width = labelBox.x + labelBox.width < self.centerX ? -labelBox.width : labelBox.width
                }
            },
            checkLabelPosition: function() {
                var self = this,
                    groupBox = self.insideLabelGroup.getBBox(),
                    canvas = self.series.canvas;
                if (groupBox.y + groupBox.height > canvas.height - canvas.bottom)
                    self.insideLabelGroup.move(0, canvas.height - groupBox.y - groupBox.height - canvas.bottom);
                else if (groupBox.y < canvas.top)
                    self.insideLabelGroup.move(0, canvas.top - groupBox.y);
                if (groupBox.x + groupBox.width > canvas.width - canvas.right)
                    self.insideLabelGroup.move(canvas.width - canvas.right - groupBox.x - groupBox.width, 0);
                else if (groupBox.x < canvas.left)
                    self.insideLabelGroup.move(canvas.left - groupBox.x, 0)
            },
            animate: function() {
                var self = this;
                self._hideLabel();
                self._showLabel(true)
            }
        });
    series.PiePoint = PiePoint
})(jQuery, DevExpress);

// Module viz, file pieSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        BaseSeries = series.BaseSeries,
        HOVERING_SPACING = 20,
        LABEL_SPACING = 80;
    var PieSeries = BaseSeries.inherit({
            ctor: function(renderer, data, options) {
                options.specificType = options.specificType || 'pie';
                this.callBase(renderer, data, options);
                this.labelSpace = this.styles.point.label.visible ? LABEL_SPACING : 0;
                this.hoverSpace = 0 && this.styles.point.states.enableHover ? HOVERING_SPACING : 0;
                this.innerRadius = this.type === 'pie' ? 0 : options.innerRadius;
                this.outerRadius = options.radius;
                this.redraw = false
            },
            arrangePoints: function() {
                var series = this,
                    points,
                    pointsLength,
                    correction = 0,
                    translator = this.translator,
                    total = 0,
                    percent,
                    i,
                    isClockWise = series.options.segmentsDirection !== 'anticlockwise';
                series.points = $.map(series.points, function(point) {
                    if (point.value === null || point.value === 0 || point.value < 0)
                        return null;
                    return point
                });
                points = series.points;
                pointsLength = points.length;
                for (i = 0; i < pointsLength; i++)
                    total += points[i].value;
                $.each(isClockWise ? points : points.concat([]).reverse(), function(i, point) {
                    var val = point.value;
                    percent = val / total;
                    point.correctValue(correction, percent);
                    correction = correction + val
                })
            },
            drawSeriesData: function(seriesGroup, labelsGroup) {
                var series = this,
                    labelSpace,
                    bbox,
                    paneSpaceHeight,
                    paneSpaceWidth,
                    min;
                $.each(series.points, function(i, point) {
                    var pId;
                    if (!point.hoverPatternColor) {
                        point.hoverPatternColor = point.options.states.hover.fill;
                        point.selectedPatternColor = point.options.states.selected.fill
                    }
                    pId = series.getPointSpecificPatternId(point.hoverPatternColor, point.options.states.hover.hatching);
                    if (pId)
                        point.options.states.hover.fill = pId;
                    pId = series.getPointSpecificPatternId(point.selectedPatternColor, point.options.states.selected.hatching);
                    if (pId)
                        point.options.states.selected.fill = pId
                });
                this.callBase(seriesGroup, labelsGroup);
                if (series.styles.point.label.visible) {
                    labelSpace = 0;
                    if (series.styles.point.label.position === 'columns') {
                        $.each(series.points, function(i, point) {
                            point.setLabelEllipsis = true;
                            bbox = point.insideLabelGroup.getBBox();
                            labelSpace = Math.max(bbox.width + point.INDENT_FROM_PIE + point.options.label.radialOffset, labelSpace)
                        });
                        series.redraw = true;
                        paneSpaceHeight = series.canvas.height - series.canvas.top - series.canvas.bottom;
                        paneSpaceWidth = series.canvas.width - series.canvas.left - series.canvas.right;
                        min = paneSpaceWidth < paneSpaceHeight ? paneSpaceWidth : paneSpaceHeight;
                        if (labelSpace > min / 2 - labelSpace)
                            series.labelSpace = min / 2;
                        else
                            series.labelSpace = 2 * labelSpace
                    }
                    else
                        $.each(series.points, function(i, point) {
                            point.setLabelEllipsis = true;
                            point.correctLabel()
                        })
                }
                return this
            },
            createPattern: function(){},
            getPointSpecificPatternId: function(color, hatching) {
                var pattern = this.renderer.createPattern(color, hatching);
                return pattern.id
            },
            correctPosition: function(correction) {
                var debug = DX.utils.debug;
                debug.assert(correction, 'correction was not passed');
                debug.assertParam(correction.centerX, 'correction.centerX was not passed');
                debug.assertParam(correction.centerY, 'correction.centerY was not passed');
                debug.assertParam(correction.radiusInner, 'correction.radiusInner was not passed');
                debug.assertParam(correction.radiusOuter, 'correction.radiusOuter was not passed');
                $.each(this.points, function(_, point) {
                    point.correctPosition(correction)
                })
            },
            getRangeData: function() {
                var range = this.callBase();
                if (!range)
                    return range;
                if (range.minY !== undefined) {
                    range.minY = range.minY > 0 ? 0 : range.minY;
                    range.maxY = range.maxY < 0 ? 0 : range.maxY
                }
                return range
            },
            parseStyleOptions: function(options) {
                if (options.label && options.label.position && options.label.position !== 'outside' && options.label.position !== 'inside' && options.label.position !== 'columns')
                    options.label.position = 'outside';
                if (options.label.position && options.label.position === 'columns')
                    options.label.connector.visible = true;
                this.options.segmentsDirection = options.segmentsDirection || 'clockwise';
                this.styles = this.callBase(options);
                this.adjustOptions();
                return this.styles
            },
            adjustOptions: function() {
                var styles = this.styles,
                    attributes = styles.attributes,
                    hover = styles.states.hover,
                    selected = styles.states.selected,
                    normal = styles.states.normal,
                    pointAttributes = styles.point.attributes,
                    pointHover = styles.point.states.hover,
                    pointSelected = styles.point.states.selected,
                    pointNormal = styles.point.states.normal;
                $.extend(true, pointAttributes, attributes);
                $.extend(true, pointHover, hover);
                $.extend(true, pointSelected, selected);
                $.extend(true, pointNormal, normal);
                pointHover.r = pointSelected.r = pointNormal.r = pointAttributes.r;
                styles.point.visible = true
            }
        });
    series.PieSeries = PieSeries
})(jQuery, DevExpress);

// Module viz, file stepLineSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        utils = DX.utils,
        LineSeries = series.LineSeries;
    var StepLineSeries = LineSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                this.type = options.specificType = options.specificType || 'stepline';
                this.callBase(renderer, data, options, isRangeSeries)
            },
            prepareSegments: function(index) {
                var self = this,
                    segmentPoint = [];
                self.preparedSegments = self.preparedSegments || [];
                $.each(self.segments[index], function(i, pt) {
                    var stepY;
                    if (!i) {
                        segmentPoint.push(pt);
                        return
                    }
                    stepY = segmentPoint[segmentPoint.length - 1].y;
                    if (stepY !== pt.y) {
                        var point = utils.clone(pt);
                        point.y = stepY;
                        segmentPoint.push(point)
                    }
                    segmentPoint.push(pt)
                });
                self.preparedSegments[index] = segmentPoint
            }
        });
    series.StepLineSeries = StepLineSeries
})(jQuery, DevExpress);

// Module viz, file stepAreaSeries.js

(function($, DX) {
    var series = DX.viz.charts.series,
        utils = DX.utils,
        AreaSeries = series.AreaSeries;
    var StepAreaSeries = AreaSeries.inherit({
            ctor: function(renderer, data, options, isRangeSeries) {
                this.type = options.specificType = options.specificType || 'steparea';
                this.callBase(renderer, data, options, isRangeSeries)
            },
            prepareSegments: function(index) {
                var self = this,
                    segmentPoint = [];
                self.preparedSegments = self.preparedSegments || [];
                $.each(self.segments[index], function(i, pt) {
                    var stepY;
                    if (!i) {
                        segmentPoint.push(pt);
                        return
                    }
                    stepY = segmentPoint[segmentPoint.length - 1].y;
                    if (stepY !== pt.y) {
                        var point = utils.clone(pt);
                        point.y = stepY;
                        segmentPoint.push(point)
                    }
                    segmentPoint.push(pt)
                });
                self.preparedSegments[index] = segmentPoint
            }
        });
    series.StepAreaSeries = StepAreaSeries
})(jQuery, DevExpress);

// Module viz, file seriesFamily.js

(function($, DX, undefined) {
    var Class = DX.Class,
        series = DX.viz.charts.series,
        utils = DX.utils;
    series.SeriesFamily = Class.inherit(function() {
        var ctor = function(options) {
                var debug = DX.utils.debug;
                debug.assert(options.type, 'type was not passed or empty');
                var self = this,
                    stubFunction = function(){};
                $.extend(self, options);
                self.type = self.type.toLowerCase();
                self.series = [];
                switch (self.type) {
                    case'bar':
                    case'rangebar':
                        self.adjustSeriesDimensions = adjustBarSeriesDimensions;
                        self.adjustSeriesValues = stubFunction;
                        break;
                    case'fullstackedbar':
                        self.fullStacked = true;
                        self.adjustSeriesDimensions = adjustStackedBarSeriesDimensions;
                        self.adjustSeriesValues = adjustStackedSeriesValues;
                        break;
                    case'stackedbar':
                        self.adjustSeriesDimensions = adjustStackedBarSeriesDimensions;
                        self.adjustSeriesValues = adjustStackedSeriesValues;
                        break;
                    case'fullstackedarea':
                    case'fullstackedline':
                        self.fullStacked = true;
                        self.adjustSeriesDimensions = stubFunction;
                        self.adjustSeriesValues = adjustStackedSeriesValues;
                        break;
                    case'stackedarea':
                    case'stackedline':
                        self.adjustSeriesDimensions = stubFunction;
                        self.adjustSeriesValues = adjustStackedSeriesValues;
                        break;
                    default:
                        self.adjustSeriesDimensions = stubFunction;
                        self.adjustSeriesValues = stubFunction;
                        break
                }
            };
        var add = function(series) {
                var self = this,
                    singleSeries,
                    i;
                if (!$.isArray(series))
                    series = [series];
                for (i = 0; i < series.length; i++) {
                    singleSeries = series[i];
                    if (singleSeries.type.toLowerCase() === self.type)
                        self.series.push(singleSeries)
                }
            };
        var adjustBarSeriesDimensionsCore = function(series, interval, stackCount, equalBarWidth, seriesStackIndexCallback) {
                var spacing,
                    width,
                    middleIndex,
                    stackIndex,
                    i,
                    point,
                    points,
                    seriesOffset,
                    stackName,
                    argumentsKeeper = {},
                    stackKeepers = {},
                    stacksWithArgument,
                    count,
                    round = Math.round;
                if (equalBarWidth) {
                    width = equalBarWidth.width && equalBarWidth.width < 0 ? 0 : equalBarWidth.width;
                    spacing = equalBarWidth.spacing && equalBarWidth.spacing < 0 ? 0 : equalBarWidth.spacing;
                    if (width && !spacing) {
                        spacing = round((interval * 0.7 - width * stackCount) / (stackCount - 1));
                        if (spacing < 1)
                            spacing = 1
                    }
                    else if (spacing && !width) {
                        width = round((interval * 0.7 - spacing * (stackCount - 1)) / stackCount);
                        if (width < 2)
                            width = 2
                    }
                    else if (!spacing && !width) {
                        spacing = round(interval * 0.7 / stackCount * 0.2);
                        if (spacing < 1)
                            spacing = 1;
                        width = round((interval * 0.7 - spacing * (stackCount - 1)) / stackCount);
                        if (width < 2)
                            width = 2
                    }
                    middleIndex = stackCount / 2;
                    for (i = 0; i < series.length; i++) {
                        stackIndex = seriesStackIndexCallback(i);
                        points = series[i].getPoints();
                        seriesOffset = (stackIndex - middleIndex + 0.5) * width - (middleIndex - stackIndex - 0.5) * spacing;
                        $.each(points, function(_, point) {
                            point.correctCoordinates({
                                width: width,
                                offset: seriesOffset
                            })
                        })
                    }
                }
                else {
                    $.each(series, function(i, singleSeries) {
                        stackName = singleSeries.getStackName && singleSeries.getStackName();
                        stackName = stackName || i.toString();
                        if (!stackKeepers[stackName])
                            stackKeepers[stackName] = [];
                        stackKeepers[stackName].push(singleSeries)
                    });
                    $.each(series, function(i, singleSeries) {
                        $.each(singleSeries.getPoints(), function(_, point) {
                            var argument = point.argument;
                            if (!argumentsKeeper.hasOwnProperty(argument))
                                argumentsKeeper[argument] = 1
                        })
                    });
                    for (var argument in argumentsKeeper) {
                        if (!argumentsKeeper.hasOwnProperty(argument))
                            continue;
                        stacksWithArgument = [];
                        $.each(stackKeepers, function(stackName, seriesInStack) {
                            $.each(seriesInStack, function(i, singleSeries) {
                                point = singleSeries.getPointByArg(argument);
                                if (point && point.value) {
                                    stacksWithArgument.push(stackName);
                                    return false
                                }
                            })
                        });
                        count = stacksWithArgument.length;
                        spacing = round(interval * 0.7 / count * 0.2);
                        if (spacing < 1)
                            spacing = 1;
                        width = round((interval * 0.7 - spacing * (count - 1)) / count);
                        if (width < 2)
                            width = 2;
                        middleIndex = count / 2;
                        $.each(stackKeepers, function(stackName, seriesInStack) {
                            stackIndex = $.inArray(stackName, stacksWithArgument);
                            if (stackIndex === -1)
                                return;
                            seriesOffset = (stackIndex - middleIndex + 0.5) * width - (middleIndex - stackIndex - 0.5) * spacing;
                            $.each(seriesInStack, function(i, singleSeries) {
                                var point = singleSeries.getPointByArg(argument);
                                if (point && point.value)
                                    point.correctCoordinates({
                                        width: width,
                                        offset: seriesOffset
                                    })
                            })
                        })
                    }
                }
            };
        var adjustBarSeriesDimensions = function(translator) {
                var debug = DX.utils.debug;
                debug.assert(translator, 'translator was not passed or empty');
                var self = this,
                    series = self.series,
                    equalBarWidth = self.equalBarWidth,
                    interval;
                self.translator = translator;
                interval = setInterval(self);
                adjustBarSeriesDimensionsCore(series, interval, series.length, equalBarWidth, function(seriesIndex) {
                    return seriesIndex
                })
            };
        var adjustStackedBarSeriesDimensions = function(translator) {
                var debug = DX.utils.debug;
                debug.assert(translator, 'translator was not passed or empty');
                var self = this,
                    interval,
                    series = self.series,
                    stackIndexes = {},
                    stackCount = 0,
                    equalBarWidth = self.equalBarWidth;
                $.each(series, function() {
                    var stackName = this.getStackName();
                    if (!stackIndexes.hasOwnProperty(stackName))
                        stackIndexes[stackName] = stackCount++
                });
                self.translator = translator;
                interval = setInterval(self);
                adjustBarSeriesDimensionsCore(series, interval, stackCount, equalBarWidth, function(seriesIndex) {
                    return stackIndexes[series[seriesIndex].getStackName()]
                })
            };
        var adjustStackedSeriesValues = function() {
                var self = this,
                    series = self.series,
                    stackKeepers = {
                        positive: {},
                        negative: {}
                    };
                $.each(series, function(_, singleSeries) {
                    var points = singleSeries.getPoints();
                    $.each(points, function(index, point) {
                        var value = point.value,
                            argument = point.argument,
                            stackName = singleSeries.getStackName ? singleSeries.getStackName() : 'default',
                            valueType = value >= 0 ? 'positive' : 'negative',
                            currentStack;
                        stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
                        currentStack = stackKeepers[valueType][stackName];
                        if (currentStack[argument]) {
                            points[index].correctValue(currentStack[argument]);
                            currentStack[argument] += value
                        }
                        else
                            currentStack[argument] = value
                    })
                });
                if (self.fullStacked)
                    adjustFullStackedSeriesValues(series, stackKeepers)
            };
        var adjustFullStackedSeriesValues = function(series, stackKeepers) {
                $.each(series, function(_, singleSeries) {
                    var points = singleSeries.getPoints();
                    $.each(points, function(index, point) {
                        var value = point.value,
                            stackName = singleSeries.getStackName ? singleSeries.getStackName() : 'default',
                            valueType = value >= 0 ? 'positive' : 'negative',
                            currentStack;
                        stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
                        currentStack = stackKeepers[valueType][stackName];
                        points[index].normalizeValue(currentStack[point.argument])
                    })
                })
            };
        var setInterval = function(self) {
                if (!self.rotated)
                    self.interval = self.translator.getIntervalX();
                else
                    self.interval = self.translator.getIntervalY();
                return self.interval
            };
        return {
                ctor: ctor,
                add: add
            }
    }())
})(jQuery, DevExpress);

// Module viz, file factory.js

(function($, DX) {
    var charts = DX.viz.charts,
        series = charts.series,
        renderers = DX.viz.renderers;
    charts.factory = function() {
        var createSeries = function(seriesType, renderer, data, options) {
                options = options || {};
                options.specificType = null;
                seriesType = (seriesType || '').toLowerCase();
                switch (seriesType.toLowerCase()) {
                    case'line':
                        return new series.LineSeries(renderer, data, options);
                    case'fullstackedline':
                        options.specificType = 'fullstackedline';
                        return new series.LineSeries(renderer, data, options);
                    case'stackedline':
                        options.specificType = 'stackedline';
                        return new series.LineSeries(renderer, data, options);
                    case'area':
                        return new series.AreaSeries(renderer, data, options);
                    case'fullstackedarea':
                        options.specificType = 'fullstackedarea';
                        return new series.AreaSeries(renderer, data, options);
                    case'stackedarea':
                        options.specificType = 'stackedarea';
                        return new series.AreaSeries(renderer, data, options);
                    case'bar':
                        return new series.BarSeries(renderer, data, options);
                    case'fullstackedbar':
                        options.specificType = 'fullstackedbar';
                        return new series.BarSeries(renderer, data, options);
                    case'stackedbar':
                        options.specificType = 'stackedbar';
                        return new series.BarSeries(renderer, data, options);
                    case'spline':
                        return new series.SplineSeries(renderer, data, options);
                    case'splinearea':
                        return new series.SplineAreaSeries(renderer, data, options);
                    case'scatter':
                        return new series.ScatterSeries(renderer, data, options);
                    case'candlestick':
                        return new series.CandleStickSeries(renderer, data, options);
                    case'stock':
                        return new series.StockSeries(renderer, data, options);
                    case'rangearea':
                        return new series.RangeAreaSeries(renderer, data, options);
                    case'rangebar':
                        return new series.RangeBarSeries(renderer, data, options);
                    case'pie':
                        return new series.PieSeries(renderer, data, options);
                    case'doughnut':
                    case'donut':
                        options.specificType = 'doughnut';
                        return new series.PieSeries(renderer, data, options);
                    case'stepline':
                        return new series.StepLineSeries(renderer, data, options);
                    case'steparea':
                        return new series.StepAreaSeries(renderer, data, options);
                    default:
                        return null
                }
            };
        var createSeriesFamily = function(options) {
                return new series.SeriesFamily(options)
            };
        var createAxis = function(renderer, options) {
                return new charts.Axis(renderer, options)
            };
        var createRenderer = function(options) {
                return new renderers.Renderer(options)
            };
        var createThemeManager = function(options, groupName) {
                return new charts.ThemeManager(options, groupName)
            };
        var createLegend = function(options) {
                return new charts.Legend(options)
            };
        var createTooltip = function(options) {
                return new charts.Tooltip(options)
            };
        var createChartLayoutManager = function(chart) {
                return new charts.LayoutManager(chart)
            };
        var getAxisTickProvider = function() {
                return DX.viz.core.tickProvider
            };
        return {
                createSeries: createSeries,
                createSeriesFamily: createSeriesFamily,
                createAxis: createAxis,
                getAxisTickProvider: getAxisTickProvider,
                createRenderer: createRenderer,
                createThemeManager: createThemeManager,
                createLegend: createLegend,
                createTooltip: createTooltip,
                createChartLayoutManager: createChartLayoutManager
            }
    }()
})(jQuery, DevExpress);

// Module viz, file tracker.js

(function($, DX) {
    var charts = DX.viz.charts,
        eventsConsts = charts.series.consts.events,
        utils = DX.utils,
        Class = DX.Class,
        MULTIPLE_MODE = 'multiple',
        SINGLE_MODE = 'single',
        ALL_ARGUMENTS_POINTS_MODE = 'allargumentpoints',
        ALL_SERIES_POINTS_MODE = 'allseriespoints',
        NONE_MODE = 'none';
    var Tracker = Class.inherit({
            ctor: function(options) {
                options.events = options.events || {};
                this.container = options.container;
                this.storedSeries = options.series || [];
                this.argumentAxis = options.argumentAxis || [];
                this.pointSelectionMode = this._prepareMode(options.pointSelectionMode);
                this.seriesSelectionMode = this._prepareMode(options.seriesSelectionMode);
                this.selectedPoint;
                this.selectedSeries;
                this.hoveredSeries;
                this.hoveredPoint;
                this.hoverStartDelay = 100;
                this.hoverHoldDelay = 200;
                this.sensitivity = 7;
                if (this.pointSelectionMode === MULTIPLE_MODE) {
                    this._releaseSelectedPoint = this._releaseSelectedPointMultiMode;
                    this.selectedPoint = []
                }
                else
                    this._releaseSelectedPoint = this._releaseSelectedPointSingleMode;
                if (this.seriesSelectionMode === MULTIPLE_MODE) {
                    this._releaseSelectedSeries = this._releaseSelectedSeriesMultiMode;
                    this.selectedSeries = []
                }
                else
                    this._releaseSelectedSeries = this._releaseSelectedSeriesSingleMode;
                this.seriesClick = options.events.seriesClick;
                this.pointClick = options.events.pointClick;
                this.argumentAxisClick = options.events.argumentAxisClick;
                this.seriesHover = options.events.seriesHover;
                this.seriesSelected = options.events.seriesSelected;
                this.pointHover = options.events.pointHover;
                this.pointSelected = options.events.pointSelected;
                this._prepareHandlers()
            },
            _prepareMode: function(mode) {
                mode = (mode || '').toLowerCase();
                return mode = mode !== SINGLE_MODE && mode !== MULTIPLE_MODE ? SINGLE_MODE : mode
            },
            _prepareHandlers: function() {
                this._prepareSeriesHandlers();
                this._prepareArgumentAxisHandlers()
            },
            _prepareSeriesHandlers: function() {
                var self = this;
                $.each(self.storedSeries, function(i, series) {
                    self._preparePointsHandlers(series);
                    series.on(eventsConsts.mouseover, {tracker: self}, self._seriesMouseOver);
                    series.on(eventsConsts.mouseout, {tracker: self}, self._seriesMouseOut);
                    series.on(eventsConsts.click, {tracker: self}, self._seriesClick);
                    series.on(eventsConsts.selectSeries, {tracker: self}, self._selectSeries);
                    series.on(eventsConsts.deselectSeries, {tracker: self}, self._deselectSeries);
                    series.on(eventsConsts.selectPoint, {tracker: self}, self._selectPoint);
                    series.on(eventsConsts.deselectPoint, {tracker: self}, self._deselectPoint)
                })
            },
            _preparePointsHandlers: function(series) {
                var self = this;
                var points = series.getPoints();
                $.each(points, function(i, point) {
                    point.on(eventsConsts.mouseover, {
                        tracker: self,
                        series: series
                    }, self._pointMouseOver);
                    point.on(eventsConsts.mouseout, {
                        tracker: self,
                        series: series
                    }, self._pointMouseOut);
                    point.on(eventsConsts.click, {tracker: self}, self._pointClick)
                })
            },
            _prepareArgumentAxisHandlers: function() {
                var self = this;
                $.each(self.argumentAxis, function(i, axis) {
                    axis.on(eventsConsts.click, {tracker: self}, self._argumentAxisClick);
                    axis.on(eventsConsts.mouseover, {tracker: self}, self._argumentAxisMouseOver);
                    axis.on(eventsConsts.mouseout, {tracker: self}, self._argumentAxisMouseOut)
                })
            },
            _seriesClick: function(event, series) {
                var tracker = event.data.tracker;
                tracker.seriesClick && tracker.seriesClick.call && tracker.seriesClick.call(series, series)
            },
            _pointClick: function(event, point) {
                var tracker = event.data.tracker,
                    series = point.series;
                if (tracker.pointClick && tracker.pointClick.call && tracker.pointClick != $.noop) {
                    tracker.pointClick.call(point, point);
                    return
                }
                tracker.seriesClick && tracker.seriesClick.call && tracker.seriesClick.call(series, series);
                return
            },
            _argumentAxisClick: function(event, axis, argument) {
                var tracker = event.data.tracker;
                tracker.argumentAxisClick && tracker.argumentAxisClick.call && tracker.argumentAxisClick.call(axis, axis, argument)
            },
            _argumentAxisMouseOver: function(event, axis, argument, hoverMode) {
                var self = event.data.tracker;
                self._releaseHoveredSeries();
                self._releaseHoveredPoint();
                var func = function() {
                        if (self.hoveredArgument !== argument) {
                            $.each(self.storedSeries, function(_, series) {
                                var neighborPoint = series.getPointByArg(argument);
                                if (neighborPoint)
                                    series.setPointHoverState(neighborPoint)
                            });
                            self.hoveredArgument = argument
                        }
                        $(axis).trigger('testmouseover')
                    };
                var getCurCoords = function(event) {
                        event.data.tracker.cX = event.pageX;
                        event.data.tracker.cY = event.pageY
                    };
                self.pX = event.pageX;
                self.pY = event.pageY;
                if (hoverMode === ALL_ARGUMENTS_POINTS_MODE) {
                    axis.on(eventsConsts.mousemove, {tracker: self}, getCurCoords);
                    self.hoverStartTimeOut = setTimeout(function() {
                        self._compareCoords(event, axis, self, func)
                    }, self.hoverStartDelay)
                }
            },
            _argumentAxisMouseOut: function(event, axis, argument, hoverMode) {
                var self = event.data.tracker;
                if (hoverMode === ALL_ARGUMENTS_POINTS_MODE)
                    $.each(self.storedSeries, function(_, series) {
                        var neighborPoint = series.getPointByArg(argument);
                        if (neighborPoint)
                            series.releasePointHoverState(neighborPoint)
                    });
                self.hoverStartTimeOut = clearTimeout(self.hoverStartTimeOut);
                self.hoveredArgument = null;
                axis.off(eventsConsts.mousemove);
                $(axis).trigger('testmouseout')
            },
            _seriesMouseOver: function(event, series, mode) {
                var tracker = event.data.tracker,
                    mode = mode || series.options.hoverMode;
                var getCurCoords = function(event) {
                        event.data.tracker.cX = event.pageX;
                        event.data.tracker.cY = event.pageY
                    };
                var func = function(event, point) {
                        tracker._setHoveredSeries(series, mode);
                        $(series).trigger('testmousemove')
                    };
                tracker._releaseHoveredPoint();
                tracker.hoverHoldTimeOut = clearTimeout(tracker.hoverHoldTimeOut);
                if (mode !== NONE_MODE && tracker.hoveredSeries !== series) {
                    tracker._releaseHoveredSeries();
                    tracker.pX = event.pageX;
                    tracker.pY = event.pageY;
                    series.on(eventsConsts.mousemove, {tracker: tracker}, getCurCoords);
                    tracker.hoverStartTimeOut = setTimeout(function() {
                        tracker._compareCoords(event, series, tracker, func)
                    }, tracker.hoverStartDelay)
                }
            },
            _selectSeries: function(event, mode) {
                var tracker = event.data.tracker,
                    series = event.target;
                tracker._setSelectedSeries(series, mode)
            },
            _deselectSeries: function(event, mode) {
                var tracker = event.data.tracker,
                    series = event.target;
                tracker._releaseSelectedSeries(series, mode)
            },
            _selectPoint: function(event, point) {
                var tracker = event.data.tracker,
                    series = event.target;
                tracker._setSelectedPoint(point)
            },
            _deselectPoint: function(event, point) {
                var tracker = event.data.tracker,
                    series = event.target;
                tracker._releaseSelectedPoint(point)
            },
            _seriesMouseOut: function(event, series, mode) {
                var tracker = event.data.tracker,
                    mode = mode || series.options.hoverMode;
                tracker.hoverStartTimeOut = clearTimeout(tracker.hoverStartTimeOut);
                tracker.hoverHoldTimeOut = setTimeout(function() {
                    series.off(eventsConsts.mousemove);
                    tracker._releaseHoveredSeries();
                    $(series).trigger('testmouseout')
                }, tracker.hoverHoldDelay)
            },
            _pointMouseOver: function(event, point, mode) {
                var tracker = event.data.tracker,
                    hoverStateHold = false,
                    mode = mode || point.options.hoverMode;
                var getCurCoords = function(event) {
                        event.data.tracker.cX = event.pageX;
                        event.data.tracker.cY = event.pageY
                    };
                if (mode === ALL_ARGUMENTS_POINTS_MODE && tracker.hoveredPoint && tracker.hoveredPoint.argument === point.argument) {
                    tracker.hoverHoldTimeOut = clearTimeout(tracker.hoverHoldTimeOut);
                    tracker._setHoveredPoint(point);
                    hoverStateHold = true;
                    $(point).trigger('testHoverHoldTimeOutCleared')
                }
                var func = function(event, point) {
                        tracker._releaseHoveredSeries();
                        if (tracker.tooltip)
                            tracker._showTooltip(event, point);
                        if (mode !== 'none' && !hoverStateHold)
                            tracker._setHoveredPoint(point);
                        $(point).trigger('testmousemove')
                    };
                if (tracker.tooltip || mode !== 'none') {
                    tracker.pX = event.pageX;
                    tracker.pY = event.pageY;
                    point.on(eventsConsts.mousemove, {tracker: tracker}, getCurCoords);
                    tracker.hoverStartTimeOut = setTimeout(function() {
                        tracker._compareCoords(event, point, tracker, func)
                    }, tracker.hoverStartDelay)
                }
            },
            _compareCoords: function(ev, point, tracker, func) {
                tracker.hoverStartTimeOut = clearTimeout(tracker.hoverStartTimeOut);
                if (Math.abs(tracker.pX - tracker.cX) + Math.abs(tracker.pY - tracker.cY) < tracker.sensitivity) {
                    point.off(eventsConsts.mousemove);
                    tracker.hoverStartTimeOut = setTimeout(function() {
                        func(ev, point)
                    }, tracker.hoverStartDelay)
                }
                else {
                    tracker.pX = tracker.cX;
                    tracker.pY = tracker.cY;
                    tracker.hoverStartTimeOut = setTimeout(function() {
                        tracker._compareCoords(ev, point, tracker, func)
                    }, tracker.hoverStartDelay)
                }
            },
            _showTooltip: function(event, point) {
                var tooltip = event.data.tracker.tooltip,
                    tooltipFormatObject = point.getTooltipFormatObject(tooltip);
                if (!utils.isDefined(tooltipFormatObject.valueText))
                    return;
                var tooltipCoords = point.getTooltipCoords();
                var tooltipText = tooltip.formatTooltip.call(tooltipFormatObject, tooltip.options);
                if (!utils.isDefined(tooltipText))
                    return;
                tooltip.show();
                tooltip.move(~~tooltipCoords.x, ~~tooltipCoords.y, tooltipCoords.offset, tooltipText, point.getColor())
            },
            _pointMouseOut: function(event, point) {
                var tracker = event.data.tracker,
                    tooltip = tracker && tracker.tooltip,
                    series = event.data.series,
                    hoverMode = point.options.hoverMode;
                point.off(eventsConsts.mousemove);
                tracker.hoverStartTimeOut = clearTimeout(tracker.hoverStartTimeOut);
                if (tooltip)
                    tooltip.hide();
                tracker.hoverHoldTimeOut = setTimeout(function() {
                    if (tracker.hoveredPoint)
                        tracker._releaseHoveredPoint();
                    $(point).trigger('testmouseout')
                }, tracker.hoverHoldDelay)
            },
            _setHoveredSeries: function(series, mode) {
                var self = this;
                if (self.hoveredSeries !== series || series.lastHoverMode !== mode) {
                    this._releaseHoveredSeries();
                    self.hoveredSeries = series;
                    series.setHoverState(mode);
                    self.seriesHover && self.seriesHover.call && self.seriesHover.call(series, series)
                }
            },
            _setSelectedSeries: function(series, mode) {
                var self = this,
                    seriesContain = false;
                if (this.seriesSelectionMode === MULTIPLE_MODE)
                    $.each(self.selectedSeries, function(_, sr) {
                        if (sr == series) {
                            seriesContain = true;
                            return false
                        }
                    });
                else if (self.selectedSeries == series)
                    seriesContain = true;
                if (!seriesContain || series.lastSelectionMode !== mode) {
                    if (self.seriesSelectionMode === SINGLE_MODE) {
                        this._releaseSelectedSeries();
                        self.selectedSeries = series
                    }
                    else
                        self.selectedSeries.push(series);
                    series.setSelectedState(mode);
                    self.seriesSelected && self.seriesSelected.call && self.seriesSelected.call(series, series)
                }
            },
            _setHoveredPoint: function(point) {
                var self = this;
                if (self.hoveredPoint !== point) {
                    this._releaseHoveredSeries();
                    this._releaseHoveredPoint();
                    self.hoveredPoint = point;
                    var debug = DX.utils.debug;
                    debug.assert(point.series, 'series was not assigned to point or empty');
                    if (point.series && point.options.hoverMode === ALL_SERIES_POINTS_MODE)
                        $.each(point.series.points, function(_, point) {
                            point.series.setPointHoverState(point)
                        });
                    else if (point.options.hoverMode === ALL_ARGUMENTS_POINTS_MODE)
                        $.each(self.storedSeries, function(_, series) {
                            var neighborPoint = series.getPointByArg(point.argument);
                            if (neighborPoint)
                                series.setPointHoverState(neighborPoint)
                        });
                    else
                        point.setHoverState();
                    self.pointHover && self.pointHover.call && self.pointHover.call(point, point)
                }
            },
            _setSelectedPoint: function(point) {
                var self = this,
                    pointContain = false;
                if (this.pointSelectionMode === MULTIPLE_MODE) {
                    $.each(self.selectedPoint, function(_, pt) {
                        if (pt == point) {
                            pointContain = true;
                            return false
                        }
                    });
                    !pointContain && self.selectedPoint.push(point)
                }
                else if (self.selectedPoint !== point) {
                    this._releaseSelectedPoint();
                    self.selectedPoint = point
                }
                else
                    pointContain = true;
                if (!pointContain) {
                    switch (point.options.selectionMode) {
                        case ALL_ARGUMENTS_POINTS_MODE:
                            $.each(self.storedSeries, function(_, series) {
                                var neighborPoint = series.getPointByArg(point.argument);
                                if (neighborPoint)
                                    series.setPointSelectedState(neighborPoint)
                            });
                            break;
                        case ALL_SERIES_POINTS_MODE:
                            $.each(point.series.points, function(_, point) {
                                point.series.setPointSelectedState(point)
                            });
                            break;
                        case NONE_MODE:
                            break;
                        default:
                            point.setSelectedState()
                    }
                    self.pointSelected && self.pointSelected.call && self.pointSelected.call(point, point)
                }
            },
            _releaseHoveredSeries: function() {
                if (!this.hoveredSeries)
                    return;
                this.hoveredSeries.releaseHoverState();
                this.hoveredSeries = null
            },
            _releaseSelectedSeriesMultiMode: function(series) {
                if (!this.selectedSeries)
                    return;
                series.releaseSelectedState();
                this.selectedSeries = $.map(this.selectedSeries, function(sr) {
                    if (sr !== series)
                        return sr
                })
            },
            _releaseSelectedSeriesSingleMode: function() {
                if (!this.selectedSeries)
                    return;
                this.selectedSeries.releaseSelectedState();
                this.selectedSeries = null
            },
            _releaseHoveredPoint: function() {
                var self = this,
                    point = self.hoveredPoint;
                if (!point)
                    return;
                if (point.options.hoverMode === ALL_SERIES_POINTS_MODE)
                    $.each(point.series.points, function(_, point) {
                        point.series.releasePointHoverState(point)
                    });
                else if (point.options.hoverMode === ALL_ARGUMENTS_POINTS_MODE)
                    $.each(self.storedSeries, function(_, series) {
                        var neighborPoint = series.getPointByArg(point.argument);
                        if (neighborPoint)
                            series.releasePointHoverState(neighborPoint)
                    });
                else
                    point.releaseHoverState();
                self.hoveredPoint = null
            },
            _releaseSelectedPointMultiMode: function(point) {
                var self = this,
                    points = self.selectedPoint;
                if (!points)
                    return;
                switch (point.options.selectionMode) {
                    case ALL_ARGUMENTS_POINTS_MODE:
                        $.each(self.storedSeries, function(_, series) {
                            var neighborPoint = series.getPointByArg(point.argument);
                            if (neighborPoint)
                                series.releasePointSelectedState(neighborPoint)
                        });
                        break;
                    case ALL_SERIES_POINTS_MODE:
                        $.each(point.series.points, function(_, pt) {
                            pt.series.releasePointSelectedState(pt)
                        });
                        break;
                    case NONE_MODE:
                        break;
                    default:
                        point.releaseSelectedState();
                        break
                }
                this.selectedPoint = $.map(this.selectedPoint, function(pt) {
                    if (pt !== point)
                        return pt
                })
            },
            _releaseSelectedPointSingleMode: function() {
                var self = this,
                    point = self.selectedPoint;
                if (!point)
                    return;
                switch (point.options.selectionMode) {
                    case ALL_ARGUMENTS_POINTS_MODE:
                        $.each(self.storedSeries, function(_, series) {
                            var neighborPoint = series.getPointByArg(point.argument);
                            if (neighborPoint)
                                series.releasePointSelectedState(neighborPoint)
                        });
                        break;
                    case ALL_SERIES_POINTS_MODE:
                        $.each(point.series.points, function(_, point) {
                            point.series.releasePointSelectedState(point)
                        });
                        break;
                    case NONE_MODE:
                        break;
                    default:
                        point.releaseSelectedState();
                        break
                }
                this.selectedPoint = null
            },
            clearSelection: function() {
                var self = this;
                if (this.pointSelectionMode === SINGLE_MODE)
                    this._releaseSelectedPoint();
                else
                    $.each(this.selectedPoint, function(_, point) {
                        self._releaseSelectedPoint(point)
                    });
                if (this.seriesSelectionMode === SINGLE_MODE)
                    this._releaseSelectedSeries();
                else
                    $.each(this.selectedSeries, function(_, series) {
                        self._releaseSelectedSeries(series)
                    })
            }
        });
    charts.Tracker = Tracker
})(jQuery, DevExpress);

// Module viz, file namespaces.js

(function(DX) {
    DX.viz.gauges = {__internals: {
            circularNeedles: {},
            circularMarkers: {},
            linearNeedles: {},
            linearMarkers: {}
        }};
    DX.viz.gauges.__tests = {}
})(DevExpress);

// Module viz, file factory.js

(function(DX, undefined) {
    var gauges = DX.viz.gauges,
        renderers = DX.viz.renderers,
        internals = gauges.__internals,
        circularNeedles = internals.circularNeedles,
        circularMarkers = internals.circularMarkers,
        linearNeedles = internals.linearNeedles,
        linearMarkers = internals.linearMarkers;
    var isString = DX.utils.isString;
    gauges.__factory = {
        createTranslator: function(fromAngle, toAngle, fromValue, toValue) {
            return new DX.viz.core.Translator1D(fromValue, toValue, fromAngle, toAngle)
        },
        createRenderer: function(options) {
            return new renderers.Renderer(options)
        },
        createCircularNeedle: function(type) {
            if (isString(type))
                switch (type.toLowerCase()) {
                    case'rectangle':
                        return new circularNeedles.RectangleNeedle;
                    case'twocolorrectangle':
                        return new circularNeedles.TwoColorRectangleNeedle;
                    case'triangle':
                        return new circularNeedles.TriangleNeedle
                }
            return undefined
        },
        createLinearNeedle: function(type) {
            if (isString(type))
                switch (type.toLowerCase()) {
                    case'rectangle':
                        return new linearNeedles.RectangleNeedle;
                    case'rhombus':
                        return new linearNeedles.RhombusNeedle;
                    case'circle':
                        return new linearNeedles.CircleNeedle
                }
            return undefined
        },
        createCircularMarker: function(type) {
            if (isString(type))
                switch (type.toLowerCase()) {
                    case'triangle':
                        return new circularMarkers.TriangleMarker;
                    case'textcloud':
                        return new circularMarkers.TextCloudMarker
                }
            return undefined
        },
        createLinearMarker: function(type) {
            if (isString(type))
                switch (type.toLowerCase()) {
                    case'triangle':
                        return new linearMarkers.TriangleMarker;
                    case'textcloud':
                        return new linearMarkers.TextCloudMarker
                }
            return undefined
        },
        createCircularRangeBar: function() {
            return new internals.CircularRangeBar
        },
        createLinearRangeBar: function() {
            return new internals.LinearRangeBar
        },
        createCircularScale: function() {
            return new internals.CircularScale
        },
        createLinearScale: function() {
            return new internals.LinearScale
        },
        createCircularRangeContainer: function() {
            return new internals.CircularRangeContainer
        },
        createLinearRangeContainer: function() {
            return new internals.LinearRangeContainer
        },
        createCircularSpindle: function() {
            return new internals.CircularSpindle
        },
        createTitle: function() {
            return new internals.Title
        },
        createIndicator: function() {
            return internals.Indicator && new internals.Indicator || null
        },
        createTooltip: function() {
            return new internals.Tooltip
        },
        createLayoutManager: function() {
            return new internals.LayoutManager
        },
        createThemeManager: function(theme) {
            return new internals.ThemeManager(theme)
        },
        createPresetManager: function() {
            return new internals.PresetManager
        },
        createTracker: function() {
            return new internals.Tracker
        }
    }
})(DevExpress);

// Module viz, file baseGaugeItem.js

(function(DX, $, undefined) {
    var $extend = $.extend;
    DX.viz.gauges.__internals.BaseGaugeItem = DX.Class.inherit({
        ctor: function() {
            this._options = {}
        },
        _getDefaultOptions: function() {
            return {}
        },
        create: function(options) {
            var self = this;
            self._renderer = options.renderer;
            self._rootElement = self._renderer.createGroup().append(options.ownerElement);
            $extend(true, self._options, self._getDefaultOptions(), options);
            self._create(options);
            return self
        },
        update: function(options) {
            var self = this;
            $extend(true, self._options, options);
            self._update(options);
            return self
        },
        showTooltip: function(element, coord, text) {
            if (element && element.$element)
                element.$element.trigger('showToolTip', [coord, text])
        },
        hideTooltip: function(element) {
            if (element && element.$element)
                element.$element.trigger('hideToolTip')
        },
        destroy: function() {
            this._rootElement.remove();
            return this
        }
    })
})(DevExpress, jQuery);

// Module viz, file scale.js

(function(DX, $, undefined) {
    var formatHelper = DX.formatHelper;
    var getCosAndSin = DX.utils.getCosAndSin,
        normalizeAngle = DX.utils.normalizeAngle,
        convertAngleToRendererSpace = DX.utils.convertAngleToRendererSpace,
        isDefined = DX.utils.isDefined,
        isString = DX.utils.isString,
        isFunction = DX.utils.isFunction,
        isArray = DX.utils.isArray,
        isNaN = window.isNaN,
        Number = window.Number,
        max = Math.max,
        min = Math.min,
        abs = Math.abs,
        atan = Math.atan,
        acos = Math.acos,
        ceil = Math.ceil,
        $extend = $.extend,
        $map = $.map;
    var PI = Math.PI;
    var tickProvider = DX.viz.core.tickProvider;
    function binarySearch(x, list) {
        var a = 0,
            b = list.length - 1,
            flag = list[a] - list[b] < 0,
            c,
            k = -1;
        if (list[a] === x)
            k = a;
        if (list[b] === x)
            k = b;
        while (k < 0 && a <= b) {
            c = ~~((a + b) / 2);
            if (list[c] === x)
                k = c;
            else if (list[c] - x < 0 === flag)
                a = c + 1;
            else
                b = c - 1
        }
        return k
    }
    DX.viz.gauges.__internals.BaseScale = DX.Class.inherit({
        setup: function(parameters) {
            var self = this;
            DX.utils.debug.assertParam(parameters.renderer, '"renderer" was not passed');
            DX.utils.debug.assertParam(parameters.owner, '"owner" was not passed');
            DX.utils.debug.assertParam(parameters.incidentOccured, '"incidentOccured" was not passed');
            self._renderer = parameters.renderer;
            self._owner = parameters.owner;
            self._incidentOccured = parameters.incidentOccured;
            return self
        },
        init: function(options) {
            var self = this;
            self._options = $extend(true, self._options || {}, options);
            self._options.majorTick || (self._options.majorTick = {});
            self._options.minorTick || (self._options.minorTick = {});
            if (options && options.majorTick && isDefined(options.majorTick.customTickValues))
                self._options.majorTick.customTickValues = isArray(options.majorTick.customTickValues) ? options.majorTick.customTickValues.slice(0) : null;
            if (options && options.minorTick && isDefined(options.minorTick.customTickValues))
                self._options.minorTick.customTickValues = isArray(options.minorTick.customTickValues) ? options.minorTick.customTickValues.slice(0) : null;
            delete self._processed;
            return self
        },
        _getCustomValues: function(values, compare) {
            var translator = this._options.translator,
                result = [];
            if (isArray(values)) {
                result = $map(values, function(x) {
                    return !isNaN(translator.translate(x)) ? Number(x) : null
                }).sort(compare);
                result = $map(result, function(x, i) {
                    return x !== result[i - 1] ? x : null
                })
            }
            return result
        },
        _getTicks: function() {
            var self = this,
                options = self._options,
                translator = options.translator,
                startValue = translator.getDomainStart(),
                endValue = translator.getDomainEnd(),
                compare = startValue < endValue ? function(x, y) {
                    return x - y
                } : function(x, y) {
                    return y - x
                },
                gridSpacingFactor = self._getGridSpacingFactor(),
                info,
                majorValues,
                minorValues,
                customMajorValues,
                customMinorValues,
                list,
                ticks = {};
            info = tickProvider.getFullTicks(startValue, endValue, self._getScreenDelta(), {
                tickInterval: options.majorTick.tickInterval > 0 ? Number(options.majorTick.tickInterval) : undefined,
                gridSpacingFactor: gridSpacingFactor.majorTicks,
                numberMultipliers: [1, 2, 5]
            }, {
                tickInterval: options.minorTick.tickInterval > 0 ? Number(options.minorTick.tickInterval) : undefined,
                gridSpacingFactor: gridSpacingFactor.minorTicks,
                numberMultipliers: [1, 2, 5]
            });
            if (options.majorTick.showCalculatedTicks) {
                majorValues = info.majorTicks;
                if (options.majorTick.useTicksAutoArrangement)
                    majorValues = self._cutTicks(majorValues)
            }
            else
                majorValues = [];
            customMajorValues = self._getCustomValues(options.majorTick.customTickValues, compare);
            customMajorValues = $map(customMajorValues, function(value) {
                return binarySearch(value, majorValues) === -1 ? value : null
            });
            if (options.minorTick.showCalculatedTicks)
                minorValues = info.minorTicks;
            else
                minorValues = [];
            minorValues = $map(minorValues, function(value) {
                return binarySearch(value, customMajorValues) === -1 ? value : null
            });
            customMinorValues = self._getCustomValues(options.minorTick.customTickValues, compare);
            list = majorValues.concat(minorValues, customMajorValues).sort(compare);
            customMinorValues = $map(customMinorValues, function(value) {
                return binarySearch(value, list) === -1 ? value : null
            });
            ticks.major = $map(majorValues.concat(customMajorValues), function(value) {
                return {
                        value: value,
                        position: translator.translate(value)
                    }
            });
            ticks.minor = $map(minorValues.concat(customMinorValues), function(value) {
                return {
                        value: value,
                        position: translator.translate(value)
                    }
            });
            return ticks
        },
        _cutTicks: function(values) {
            var self = this,
                factor = self._getCuttingFactor(values.length, {
                    width: self._textWidth,
                    height: self._textHeight
                }),
                cutValues = [],
                i = 0,
                ii = values.length;
            for (; i < ii; i += factor)
                cutValues.push(values[i]);
            return cutValues
        },
        _renderContent: function(ticks) {
            var self = this,
                options = self._options,
                i,
                ii,
                item,
                points,
                element,
                majorTickColor,
                minorTickColor,
                textPosition,
                textValue;
            if (self._majorTickLength && self._majorTickWidth) {
                majorTickColor = isString(options.majorTick.color) ? options.majorTick.color : 'none';
                points = self._getTickPoints(self._majorTickLength, self._majorTickWidth);
                i = 0;
                ii = ticks.major.length;
                options.hideFirstTick === true && ++i;
                options.hideLastTick === true && --ii;
                for (; i < ii; ++i) {
                    item = ticks.major[i];
                    element = self._renderer.createArea(points, {
                        fill: majorTickColor,
                        stroke: 'none',
                        strokeWidth: 0
                    });
                    self._moveTick(element, item);
                    element.append(self._majorTicks)
                }
            }
            if (self._minorTickLength && self._minorTickWidth) {
                minorTickColor = isString(options.minorTick.color) ? options.minorTick.color : 'none';
                points = self._getTickPoints(self._minorTickLength, self._minorTickWidth);
                for (i = 0, ii = ticks.minor.length; i < ii; ++i) {
                    item = ticks.minor[i];
                    element = self._renderer.createArea(points, {
                        fill: minorTickColor,
                        stroke: 'none',
                        strokeWidth: 0
                    });
                    self._moveTick(element, item);
                    element.append(self._minorTicks)
                }
            }
            if (self._textIndent) {
                textPosition = self._getLabelPosition(self._majorTickLength || 0, self._textIndent);
                i = 0;
                ii = ticks.major.length;
                options.hideFirstLabel === true && ++i;
                options.hideLastLabel === true && --ii;
                for (; i < ii; ++i) {
                    item = ticks.major[i];
                    textValue = self._formatValue(item.value);
                    points = self._getLabelOptions(textValue, textPosition, self._textIndent, item);
                    self._renderer.createText(textValue, points.x, points.y + self._textVerticalOffset, {
                        align: points.align,
                        font: options.label.font
                    }).append(self._labels)
                }
            }
        },
        _processOptions: function() {
            var self = this,
                options = self._options;
            if (self._processed)
                return;
            self._processed = true;
            self._setupOrientation();
            if (options.majorTick.visible) {
                if (options.majorTick.length > 0)
                    self._majorTickLength = Number(options.majorTick.length);
                else
                    self._incidentOccured('Major ticks are not rendered because the value of "majorTick.length" option is not valid');
                if (options.majorTick.width > 0)
                    self._majorTickWidth = Number(options.majorTick.width);
                else
                    self._incidentOccured('Major ticks are not rendered because the value of "majorTick.width" option is not valid')
            }
            if (options.minorTick.visible) {
                if (options.minorTick.length > 0)
                    self._minorTickLength = Number(options.minorTick.length);
                else
                    self._incidentOccured('Minor ticks are not rendered because the value of "minorTick.length" option is not valid');
                if (options.minorTick.width > 0)
                    self._minorTickWidth = Number(options.minorTick.width);
                else
                    self._incidentOccured('Minor ticks are not rendered because the value of "minorTick.width" option is not valid')
            }
            if (options.label.visible)
                if (Number(options.label.indentFromTick) !== 0) {
                    self._textIndent = Number(options.label.indentFromTick);
                    self._measureText()
                }
                else
                    self._incidentOccured('Labels are not rendered because the value of the "label.indentFromTick" option is not valid')
        },
        render: function() {
            var self = this,
                ticks;
            if (!self._rootElement) {
                self._rootElement = self._renderer.createGroup({'class': 'scale'});
                self._majorTicks = self._renderer.createGroup({'class': 'major-ticks'}).append(self._rootElement);
                self._minorTicks = self._renderer.createGroup({'class': 'minor-ticks'}).append(self._rootElement);
                self._labels = self._renderer.createGroup({'class': 'labels'}).append(self._rootElement)
            }
            self._rootElement.append(self._owner);
            self._majorTicks.clear();
            self._minorTicks.clear();
            self._labels.clear();
            self._processOptions();
            if (self._isVisible()) {
                ticks = self._getTicks();
                self._renderContent(ticks)
            }
            else if (self._rootElement) {
                self._rootElement.remove();
                delete self._rootElement;
                delete self._majorTicks;
                delete self._minorTicks;
                delete self._labels
            }
            return self
        },
        _formatValue: function(value) {
            var labelOptions = this._options.label,
                result = formatHelper.format(value, labelOptions.format, labelOptions.precision);
            if (isFunction(labelOptions.customizeText)) {
                result = {
                    value: value,
                    valueText: result
                };
                return labelOptions.customizeText.call(result, result)
            }
            return result
        },
        _getSampleText: function() {
            var self = this,
                text1 = self._formatValue(self._options.translator.getDomainStart()),
                text2 = self._formatValue(self._options.translator.getDomainEnd());
            return text1.length >= text2.length ? text1 : text2
        },
        _measureText: function() {
            var self = this,
                root = self._renderer.createGroup({'class': 'scale'}).append(self._rootElement),
                labels = self._renderer.createGroup({'class': 'labels'}).append(root),
                value = self._getSampleText(),
                text = self._renderer.createText(value, 0, 0, {
                    align: 'center',
                    font: self._options.label.font
                }).append(labels),
                bbox = text.getBBox();
            root.remove();
            self._textVerticalOffset = -bbox.y - bbox.height / 2;
            self._textWidth = bbox.width;
            self._textHeight = bbox.height;
            self._textLength = value.length
        }
    });
    function getBasedAngle(startAngle, endAngle) {
        var startDelta,
            endDelta,
            tmp;
        if (startAngle > endAngle) {
            tmp = endAngle;
            endAngle = startAngle;
            startAngle = tmp
        }
        startDelta = 0 <= startAngle && startAngle <= 180 ? abs(90 - startAngle) : abs(270 - startAngle);
        startDelta = startAngle < 90 && 90 < endAngle || startAngle < 270 && 270 < endAngle ? 0 : startDelta;
        endDelta = 0 < endAngle && endAngle < 180 ? abs(90 - endAngle) : abs(270 - endAngle);
        return startDelta < endDelta ? startDelta : endDelta
    }
    DX.viz.gauges.__internals.CircularScale = DX.viz.gauges.__internals.BaseScale.inherit({
        _getGridSpacingFactor: function() {
            return {
                    majorTicks: 17,
                    minorTicks: 5
                }
        },
        _getScreenDelta: function() {
            var options = this._options;
            return (options.translator.getCodomainStart() - options.translator.getCodomainEnd()) * options.radius * PI / 180
        },
        _getCuttingFactor: function(ticksCount, maxLabelSize) {
            var self = this,
                options = self._options,
                startAngle = options.translator.getCodomainStart(),
                endAngle = options.translator.getCodomainEnd(),
                radius = self._getLabelPosition(self._majorTickLength || 0, self._textIndent),
                baseAngle = getBasedAngle(normalizeAngle(startAngle), normalizeAngle(endAngle)),
                baseAngleCosSin = getCosAndSin(baseAngle),
                degreesPerTick = (startAngle - endAngle) / ticksCount,
                minAngleBetweenTicks,
                widthBasedAngle,
                tanOfWidthBasedAngle,
                heightBasedAngle,
                cosOfHeightBasedAngle,
                cuttingBackFactor = 1;
            tanOfWidthBasedAngle = (baseAngleCosSin.sin * radius + maxLabelSize.width) / (baseAngleCosSin.cos * radius);
            widthBasedAngle = abs(baseAngle - atan(tanOfWidthBasedAngle) * 180 / PI);
            cosOfHeightBasedAngle = baseAngleCosSin.cos - maxLabelSize.height / radius;
            heightBasedAngle = -1 > cosOfHeightBasedAngle || cosOfHeightBasedAngle > 1 ? 90 : abs(baseAngle - acos(cosOfHeightBasedAngle) * 180 / PI);
            minAngleBetweenTicks = widthBasedAngle < heightBasedAngle ? widthBasedAngle : heightBasedAngle;
            if (degreesPerTick < minAngleBetweenTicks)
                cuttingBackFactor = ceil(minAngleBetweenTicks / degreesPerTick);
            return max(1, cuttingBackFactor)
        },
        _setupOrientation: function() {
            var self = this,
                inner = 0,
                outer = 0;
            switch (self._options.orientation) {
                case'inside':
                    inner = 1;
                    break;
                case'center':
                    inner = outer = 0.5;
                    break;
                default:
                    self._options.orientation !== 'outside' && self._incidentOccured('The value of the "orientation" option is not valid');
                    outer = 1;
                    break
            }
            self._inner = inner;
            self._outer = outer
        },
        _getTickPoints: function(length, width) {
            var options = this._options,
                x1 = options.x - width / 2,
                x2 = options.x + width / 2,
                y1 = options.y - options.radius - length * this._outer,
                y2 = options.y - options.radius + length * this._inner;
            return [x1, y1, x2, y1, x2, y2, x1, y2]
        },
        _moveTick: function(element, tick) {
            element.rotate(convertAngleToRendererSpace(tick.position), this._options.x, this._options.y)
        },
        _getLabelPosition: function(tickLength, textIndent) {
            return this._options.radius + tickLength * (textIndent >= 0 ? this._outer : -this._inner) + textIndent
        },
        _getLabelOptions: function(textValue, textPosition, textIndent, tick) {
            var self = this,
                options = self._options,
                cossin = getCosAndSin(tick.position),
                x = options.x + cossin.cos * textPosition,
                y = options.y - cossin.sin * textPosition,
                dx = cossin.cos * (textValue.length / self._textLength) * self._textWidth / 2,
                dy = cossin.sin * self._textHeight / 2;
            if (textIndent > 0) {
                x += dx;
                y -= dy
            }
            else {
                x -= dx;
                y += dy
            }
            return {
                    x: x,
                    y: y,
                    align: 'center'
                }
        },
        _isVisible: function() {
            var self = this,
                length = self._majorTickLength || 0,
                r = self._options.radius,
                inner = r - self._inner * length,
                outer = r + self._outer * length;
            return inner > 0 && outer > inner
        },
        measure: function() {
            var self = this,
                options = self._options,
                result = {
                    min: options.radius,
                    max: options.radius
                };
            self._processOptions();
            if (self._majorTickLength) {
                result.min -= self._inner * self._majorTickLength;
                result.max += self._outer * self._majorTickLength
            }
            if (self._textIndent) {
                if (self._textIndent >= 0) {
                    result.horizontalOffset = self._textIndent + self._textWidth;
                    result.verticalOffset = self._textIndent + self._textHeight
                }
                else {
                    result.horizontalOffset = 0;
                    result.verticalOffset = 0;
                    result.min += self._textIndent - max(self._textWidth, self._textHeight)
                }
                result.inverseHorizontalOffset = self._textWidth / 2;
                result.inverseVerticalOffset = self._textHeight / 2
            }
            return result
        }
    });
    DX.viz.gauges.__internals.LinearScale = DX.viz.gauges.__internals.BaseScale.inherit({
        _getGridSpacingFactor: function() {
            return {
                    majorTicks: 25,
                    minorTicks: 5
                }
        },
        _getScreenDelta: function() {
            return abs(this._options.translator.getCodomainEnd() - this._options.translator.getCodomainStart())
        },
        _getCuttingFactor: function(ticksCount, maxLabelSize) {
            var options = this._options,
                labelSize = this._vertical ? maxLabelSize.height : maxLabelSize.width,
                screenSize = abs(options.translator.getCodomainEnd() - options.translator.getCodomainStart());
            return max(1, ceil(ticksCount * labelSize / (screenSize + labelSize)))
        },
        _setupOrientation: function() {
            var self = this,
                inner = 0,
                outer = 0;
            self._vertical = self._options.orientation === 'vertical';
            if (self._vertical)
                switch (self._options.horizontalOrientation) {
                    case'left':
                        inner = 1;
                        break;
                    case'center':
                        inner = outer = 0.5;
                        break;
                    default:
                        self._options.horizontalOrientation !== 'right' && self._incidentOccured('The value of the "horizontalOrientation" option is not valid');
                        outer = 1;
                        break
                }
            else
                switch (self._options.verticalOrientation) {
                    case'top':
                        inner = 1;
                        break;
                    case'middle':
                        inner = outer = 0.5;
                        break;
                    default:
                        self._options.verticalOrientation !== 'bottom' && self._incidentOccured('The value of the "verticalOrientation" option is not valid');
                        outer = 1;
                        break
                }
            self._inner = inner;
            self._outer = outer
        },
        _getTickPoints: function(length, width) {
            var options = this._options,
                x1,
                x2,
                y1,
                y2;
            if (this._vertical) {
                x1 = options.x - length * this._inner;
                x2 = options.x + length * this._outer;
                y1 = -width / 2;
                y2 = width / 2
            }
            else {
                x1 = -width / 2;
                x2 = width / 2;
                y1 = options.y - length * this._inner;
                y2 = options.y + length * this._outer
            }
            return [x1, y1, x2, y1, x2, y2, x1, y2]
        },
        _moveTick: function(element, tick) {
            var options = this._options,
                x = 0,
                y = 0;
            if (this._vertical)
                y = tick.position;
            else
                x = tick.position;
            element.move(x, y)
        },
        _getLabelPosition: function(tickLength, textIndent) {
            var options = this._options,
                position = tickLength * (textIndent >= 0 ? this._outer : -this._inner) + textIndent;
            if (this._vertical)
                position += options.x;
            else
                position += options.y + (textIndent >= 0 ? 1 : -1) * this._textVerticalOffset;
            return position
        },
        _getLabelOptions: function(textValue, textPosition, textIndent, tick) {
            var x,
                y,
                align;
            if (this._vertical) {
                x = textPosition;
                y = tick.position;
                align = textIndent > 0 ? 'left' : 'right'
            }
            else {
                x = tick.position;
                y = textPosition;
                align = 'center'
            }
            return {
                    x: x,
                    y: y,
                    align: align
                }
        },
        _isVisible: function() {
            return true
        },
        measure: function() {
            var self = this,
                options = self._options,
                result;
            self._processOptions();
            if (self._vertical) {
                result = {
                    min: options.x,
                    max: options.x
                };
                if (self._majorTickLength) {
                    result.min -= self._inner * self._majorTickLength;
                    result.max += self._outer * self._majorTickLength
                }
                if (self._textIndent) {
                    if (self._textIndent >= 0)
                        result.max += self._textIndent + self._textWidth;
                    else
                        result.min += self._textIndent - self._textWidth;
                    result.indent = self._textHeight / 2
                }
            }
            else {
                result = {
                    min: options.y,
                    max: options.y
                };
                if (self._majorTickLength) {
                    result.min -= self._inner * self._majorTickLength;
                    result.max += self._outer * self._majorTickLength
                }
                if (self._textIndent) {
                    if (self._textIndent >= 0)
                        result.max += self._textIndent + self._textHeight;
                    else
                        result.min += self._textIndent - self._textHeight;
                    result.indent = self._textWidth / 2
                }
            }
            return result
        }
    })
})(DevExpress, jQuery);

// Module viz, file baseIndicator.js

(function(DX, $, undefined) {
    var formatHelper = DX.formatHelper;
    var isFunction = DX.utils.isFunction,
        isFinite = window.isFinite,
        Number = window.Number,
        $extend = $.extend;
    DX.viz.gauges.__internals.BaseIndicator = DX.viz.gauges.__internals.BaseGaugeItem.inherit({
        setup: function(parameters) {
            var self = this;
            self._renderer = parameters.renderer;
            self._owner = parameters.owner;
            self._trackerOwner = parameters.tracker;
            self._options = {};
            return self
        },
        init: function(options) {
            $extend(true, this._options, options || {});
            return this
        },
        render: function() {
            var self = this;
            self._actualValue = self._currentValue = Number(self._options.currentValue);
            self._isCurrentValueLocked = false;
            delete self._setCurrentValueNext;
            delete self._setCurrentValueHas;
            self._animateStep = self._animateStep || function(_, fx) {
                var target = self;
                target._updateActualValue(target._animateStart + target._animateDelta * fx.pos)
            };
            self._animateComplete = self._animateComplete || function() {
                var target = self;
                if (target._setCurrentValueHas) {
                    target._runAnimation(target._actualValue, target._setCurrentValueNext);
                    target._setCurrentValueHas = false
                }
                else {
                    target._isCurrentValueLocked = false;
                    delete target._animateStart;
                    delete target._animateDelta
                }
                target._setCurrentValueNext = undefined
            };
            return self
        },
        _formatValue: function(value) {
            var options = this._options.text,
                valueText = formatHelper.format(value, options.format, options.precision),
                obj = {
                    value: value,
                    valueText: valueText
                };
            return isFunction(options.customizeText) ? options.customizeText.call(obj, obj) : valueText
        },
        _getActualPosition: function() {
            return this._options.translator.translate(this._actualValue)
        },
        _getSampleText: function() {
            var self = this,
                options = self._options,
                text1,
                text2,
                text;
            if (options.text) {
                text1 = self._formatValue(options.translator.getDomainStart());
                text2 = self._formatValue(options.translator.getDomainEnd());
                text = text1.length >= text2.length ? text1 : text2
            }
            return text
        },
        _updateActualValue: function(value) {
            this._actualValue = value;
            this._updateActiveElements()
        },
        _runAnimation: function(fromValue, toValue) {
            var self = this;
            self._isCurrentValueLocked = true;
            self._animateStart = fromValue;
            self._animateDelta = toValue - fromValue;
            self._rootElement.animate({fake: true}, {
                duration: self._options.animationDuration,
                step: self._animateStep,
                complete: self._animateComplete
            })
        },
        getCurrentValue: function() {
            return this._currentValue
        },
        setCurrentValue: function(value) {
            var self = this,
                currentValue = self._currentValue,
                newValue = Number(value),
                rootElement;
            if (currentValue !== newValue && isFinite(self._options.translator.translate(newValue))) {
                currentValue = self._currentValue = newValue;
                if (self._rootElement)
                    if (self._options.animationEnabled)
                        if (!self._isCurrentValueLocked)
                            self._runAnimation(self._actualValue, currentValue);
                        else {
                            self._setCurrentValueNext = newValue;
                            self._setCurrentValueHas = true
                        }
                    else
                        self._updateActualValue(currentValue)
            }
            return currentValue
        }
    })
})(DevExpress, jQuery);

// Module viz, file baseMarker.js

(function(DX, $, undefined) {
    var $extend = $.extend;
    var TextCloud = DX.viz.core.TextCloud;
    DX.viz.gauges.__internals.BaseTextCloudMarker = DX.viz.gauges.__internals.BaseIndicator.inherit({
        _updateActiveElements: function() {
            var self = this,
                bbox,
                info = new TextCloud,
                textCloudOptions = self._getTextCloudOptions();
            self._text.applySettings({text: self._formatValue(self._actualValue)});
            bbox = self._text.getBBox();
            info.setup({
                x: textCloudOptions.x,
                y: textCloudOptions.y,
                textWidth: bbox.width,
                textHeight: bbox.height,
                horMargin: self._options.horizontalOffset,
                verMargin: self._options.verticalOffset,
                tailLength: self._options.arrowLength,
                type: textCloudOptions.type
            });
            self._text.applySettings({
                x: info.cx(),
                y: info.cy() + self._textVerticalOffset
            });
            self._cloud.applySettings({points: info.points()})
        },
        _measureText: function() {
            var self = this,
                bbox;
            self._rootElement = self._rootElement || self._renderer.createGroup({'class': 'marker'});
            self._rootElement.append(self._owner);
            self._cloud = self._cloud || self._renderer.createArea().append(self._rootElement);
            self._text = self._text || self._renderer.createText().append(self._rootElement);
            self._text.applySettings({
                x: 0,
                y: 0,
                align: 'center',
                font: self._options.text.font,
                text: self._getSampleText()
            });
            bbox = self._text.getBBox();
            self._textVerticalOffset = -bbox.y - bbox.height / 2;
            self._textWidth = bbox.width;
            self._textHeight = bbox.height;
            self._textFullWidth = self._textWidth + 2 * self._options.horizontalOffset;
            self._textFullHeight = self._textHeight + 2 * self._options.verticalOffset
        },
        render: function() {
            var self = this;
            self.callBase();
            if (self._isVisible()) {
                self._measureText();
                self._cloud.applySettings({
                    stroke: 'none',
                    strokeWidth: 0,
                    fill: self._options.color
                });
                self._updateActiveElements()
            }
            else
                self.clear();
            return self
        },
        clear: function() {
            var self = this;
            if (self._rootElement) {
                self._rootElement.remove();
                delete self._rootElement;
                delete self._cloud;
                delete self._text
            }
        }
    })
})(DevExpress, jQuery);

// Module viz, file baseRangeBar.js

(function(DX, $, undefined) {
    var $extend = $.extend;
    DX.viz.gauges.__internals.BaseRangeBar = DX.viz.gauges.__internals.BaseIndicator.inherit({
        _prepare: function() {
            var self = this,
                bbox;
            self._hasText = self._isTextVisible();
            if (self._hasText) {
                self._rootElement = self._rootElement || self._renderer.createGroup({'class': 'rangebar'}).append(self._owner);
                self._text = self._text || self._renderer.createText().append(self._rootElement);
                self._text.applySettings({
                    x: 0,
                    y: 0,
                    align: self._getTextAlign(),
                    font: self._getFontOptions(),
                    text: self._getSampleText()
                });
                bbox = self._text.getBBox();
                self._textVerticalOffset = -bbox.y - bbox.height / 2;
                self._textWidth = bbox.width;
                self._textHeight = bbox.height
            }
        },
        _updateActiveElements: function() {
            var self = this;
            self._updateBarItemsPositions();
            if (self._hasText) {
                self._text.applySettings({text: self._formatValue(self._actualValue)});
                self._updateTextPosition();
                self._updateLinePosition()
            }
        },
        _updateBarItems: function() {
            var self = this,
                options = self._options,
                backgroundColor,
                spaceColor;
            self._setBarSides();
            self._startPosition = options.translator.translate(options.translator.getDomainStart());
            self._endPosition = options.translator.translate(options.translator.getDomainEnd());
            self._basePosition = options.translator.translate(options.baseValue);
            self._space = self._getSpace();
            backgroundColor = options.backgroundColor || 'none';
            if (backgroundColor !== 'none' && self._space > 0)
                spaceColor = options.containerBackgroundColor || 'none';
            else {
                self._space = 0;
                spaceColor = 'none'
            }
            self._backItem1.applySettings({
                fill: backgroundColor,
                stroke: 'none',
                strokeWidth: 0
            });
            self._backItem2.applySettings({
                fill: backgroundColor,
                stroke: 'none',
                strokeWidth: 0
            });
            self._spaceItem1.applySettings({
                fill: spaceColor,
                stroke: 'none',
                strokeWidth: 0
            });
            self._spaceItem2.applySettings({
                fill: spaceColor,
                stroke: 'none',
                strokeWidth: 0
            });
            self._mainItem.applySettings({
                fill: options.color,
                stroke: 'none',
                strokeWidth: 0
            })
        },
        _getSpace: function() {
            return 0
        },
        _updateTextItems: function() {
            var self = this,
                options = self._options;
            if (self._isTextVisible()) {
                self._hasText = true;
                self._createTextItems();
                self._updateText();
                self._updateLine();
                self._setTextItemsSides()
            }
            else {
                delete self._hasText;
                self._destroyTextItems()
            }
        },
        _isTextVisible: function() {
            return false
        },
        _createTextItems: function() {
            var self = this;
            self._line || (self._line = self._renderer.createPath().append(self._rootElement));
            self._text || (self._text = self._renderer.createText().append(self._rootElement))
        },
        _destroyTextItems: function() {
            var self = this;
            self._line && self._line.remove() && delete self._line;
            self._text && self._text.remove() && delete self._text
        },
        _updateText: function() {
            var self = this,
                bbox;
            self._text.applySettings({
                x: 0,
                y: 0,
                align: self._getTextAlign(),
                font: self._getFontOptions(),
                text: self._getSampleText()
            });
            bbox = self._text.getBBox();
            self._textVerticalOffset = -bbox.y - bbox.height / 2;
            self._textWidth = bbox.width;
            self._textHeight = bbox.height
        },
        _getTextAlign: function() {
            return undefined
        },
        _getFontOptions: function() {
            var options = this._options,
                font = options.text.font;
            if (!font || !font.color)
                font = $extend({}, font, {color: options.color});
            return font
        },
        _updateLine: function() {
            var self = this;
            self._line.applySettings({
                fill: self._options.color,
                stroke: 'none',
                strokeWidth: 0
            })
        },
        _updateBarItemsPositions: function() {
            var self = this,
                positions = self._getPositions();
            self._backItem1.applySettings(self._buildItemSettings(positions.start, positions.back1));
            self._backItem2.applySettings(self._buildItemSettings(positions.back2, positions.end));
            self._spaceItem1.applySettings(self._buildItemSettings(positions.back1, positions.main1));
            self._spaceItem2.applySettings(self._buildItemSettings(positions.main2, positions.back2));
            self._mainItem.applySettings(self._buildItemSettings(positions.main1, positions.main2))
        },
        render: function() {
            var self = this;
            self.callBase();
            if (self._isVisible()) {
                self._prepare();
                self._rootElement = self._rootElement || self._renderer.createGroup({'class': 'rangebar'});
                self._rootElement.append(self._owner);
                self._backItem1 = self._backItem1 || self._createBarItem();
                self._backItem2 = self._backItem2 || self._createBarItem();
                self._spaceItem1 = self._spaceItem1 || self._createBarItem();
                self._spaceItem2 = self._spaceItem2 || self._createBarItem();
                self._mainItem = self._mainItem || self._createBarItem();
                self._updateBarItems();
                self._updateTextItems();
                self._updateActiveElements()
            }
            else
                self.clear();
            return self
        },
        clear: function() {
            var self = this;
            if (self._rootElement) {
                self._rootElement.remove();
                delete self._rootElement;
                delete self._backItem1;
                delete self._backItem2;
                delete self._spaceItem1;
                delete self._spaceItem2;
                delete self._mainItem;
                delete self._hasText;
                self._destroyTextItems()
            }
        }
    })
})(DevExpress, jQuery);

// Module viz, file circularNeedle.js

(function(DX, $, undefined) {
    var circularNeedles = DX.viz.gauges.__internals.circularNeedles;
    var convertAngleToRendererSpace = DX.utils.convertAngleToRendererSpace,
        $extend = $.extend;
    circularNeedles.SimpleIndicator = DX.viz.gauges.__internals.BaseIndicator.inherit({
        _updateActiveElements: function() {
            var self = this,
                options = self._options,
                actualAngle = self._getActualPosition(),
                angle = convertAngleToRendererSpace(actualAngle);
            self._rootElement.rotate(angle, options.x, options.y);
            self._tracker.rotate(angle, options.x, options.y)
        },
        _isVisible: function() {
            var options = this._options;
            return options.width > 0 && options.indentFromCenter >= 0 && options.radius - options.indentFromCenter > 0
        },
        _getClassName: function() {
            return 'needle'
        },
        _getTrackerPoints: function() {
            var options = this._options,
                y2 = options.y - options.radius,
                y1 = options.y - options.indentFromCenter || options.y,
                x1 = options.x - options.width / 2 || options.x,
                x2 = x1 + options.width || options.x;
            return [x1, y1, x1, y2, x2, y2, x2, y1]
        },
        _destroy: function() {
            delete this._element
        },
        render: function() {
            var self = this;
            self.callBase();
            if (self._isVisible()) {
                self._rootElement = self._rootElement || self._renderer.createGroup({'class': self._getClassName()});
                self._rootElement.append(self._owner);
                self._create();
                self._tracker = self._tracker || self._renderer.createArea().append(self._trackerOwner);
                self._tracker.applySettings({
                    points: self._getTrackerPoints(),
                    stroke: 'none',
                    strokeWidth: 0,
                    fill: '#000000',
                    opacity: 0.0001
                });
                self._updateActiveElements()
            }
            else if (self._rootElement) {
                self._rootElement.remove();
                delete self._rootElement;
                self._destroy();
                delete self._tracker
            }
            return self
        },
        measure: function() {
            var options = this._options,
                result = {max: options.radius};
            if (options.indentFromCenter < 0)
                result.inverseHorizontalOffset = result.inverseVerticalOffset = -options.indentFromCenter;
            return result
        },
        getTrackingElement: function() {
            return this._tracker
        },
        getTooltipParameters: function() {
            var options = this._options,
                cossin = DX.utils.getCosAndSin(this._getActualPosition()),
                r = (options.radius + options.indentFromCenter) / 2;
            return {
                    x: options.x + cossin.cos * r,
                    y: options.y - cossin.sin * r,
                    value: this._currentValue,
                    color: options.color,
                    offset: options.width / 2
                }
        }
    });
    circularNeedles.RectangleNeedle = circularNeedles.SimpleIndicator.inherit({_create: function() {
            var self = this,
                options = self._options,
                y2 = options.y - options.radius,
                y1 = options.y - options.indentFromCenter || options.y,
                x1 = options.x - options.width / 2 || options.x,
                x2 = x1 + options.width || options.x;
            self._element = self._element || self._renderer.createArea().append(self._rootElement);
            self._element.applySettings({
                points: [x1, y1, x1, y2, x2, y2, x2, y1],
                stroke: 'none',
                strokeWidth: 0,
                fill: options.color
            })
        }});
    circularNeedles.TriangleNeedle = circularNeedles.SimpleIndicator.inherit({_create: function() {
            var self = this,
                options = self._options,
                y2 = options.y - options.radius,
                y1 = options.y - options.indentFromCenter || options.y,
                x1 = options.x - options.width / 2 || options.x,
                x2 = options.x + options.width / 2 || options.x;
            self._element = self._element || self._renderer.createArea().append(self._rootElement);
            self._element.applySettings({
                points: [x1, y1, options.x, y2, x2, y1],
                stroke: 'none',
                strokeWidth: 0,
                fill: options.color
            })
        }});
    circularNeedles.TwoColorRectangleNeedle = circularNeedles.SimpleIndicator.inherit({
        _create: function() {
            var self = this,
                options = self._options,
                x1 = options.x - options.width / 2 || options.x,
                x2 = options.x + options.width / 2 || options.x,
                y4 = options.y - options.radius,
                y1 = options.y - options.indentFromCenter || options.y,
                y3 = y4 + (y1 - y4) * options.secondFraction || y4,
                y2 = y3 + options.space || y3;
            self._firstElement = self._firstElement || self._renderer.createArea().append(self._rootElement);
            self._spaceElement = self._spaceElement || self._renderer.createArea().append(self._rootElement);
            self._secondElement = self._secondElement || self._renderer.createArea().append(self._rootElement);
            self._firstElement.applySettings({
                points: [x1, y1, x1, y2, x2, y2, x2, y1],
                fill: options.color,
                stroke: 'none',
                strokeWidth: 0
            });
            self._spaceElement.applySettings({
                points: [x1, y2, x1, y3, x2, y3, x2, y2],
                fill: options.containerBackgroundColor,
                stroke: 'none',
                strokeWidth: 0
            });
            self._secondElement.applySettings({
                points: [x1, y3, x1, y4, x2, y4, x2, y3],
                fill: options.secondColor,
                stroke: 'none',
                strokeWidth: 0
            })
        },
        _destroy: function() {
            delete this._firstElement;
            delete this._secondElement;
            delete this._spaceElement
        }
    })
})(DevExpress, jQuery);

// Module viz, file linearNeedle.js

(function(DX, $, undefined) {
    var linearNeedles = DX.viz.gauges.__internals.linearNeedles;
    var $extend = $.extend;
    linearNeedles.SimpleIndicator = DX.viz.gauges.__internals.BaseIndicator.inherit({
        _updateActiveElements: function() {
            var self = this,
                delta = self._getActualPosition() - self._zeroPosition;
            self._rootElement.move(self._vertical ? 0 : delta, self._vertical ? delta : 0);
            self._tracker.move(self._vertical ? 0 : delta, self._vertical ? delta : 0)
        },
        _isVisible: function() {
            var options = this._options;
            return options.length > 0 && options.width > 0
        },
        _getClassName: function() {
            return 'needle'
        },
        _getTrackerPoints: function() {
            var options = this._options,
                x1,
                x2,
                y1,
                y2,
                p = this._zeroPosition;
            if (this._vertical) {
                x1 = options.x - options.length / 2 || options.x;
                x2 = options.x + options.length / 2 || options.x;
                y1 = p + options.width / 2 || p;
                y2 = p - options.width / 2 || p
            }
            else {
                x1 = p - options.width / 2 || p;
                x2 = p + options.width / 2 || p;
                y1 = options.y + options.length / 2 || options.y;
                y2 = options.y - options.length / 2 || options.y
            }
            return [x1, y1, x1, y2, x2, y2, x2, y1]
        },
        _destroy: function() {
            delete this._element
        },
        init: function(options) {
            var self = this;
            self.callBase(options);
            self._vertical = self._options.orientation === 'vertical';
            return self
        },
        render: function() {
            var self = this;
            self.callBase();
            if (self._isVisible()) {
                self._zeroPosition = self._options.translator.getCodomainStart();
                self._rootElement = self._rootElement || self._renderer.createGroup({'class': self._getClassName()});
                self._rootElement.append(self._owner);
                self._create();
                self._tracker = self._tracker || self._renderer.createArea().append(self._trackerOwner);
                self._tracker.applySettings({
                    points: self._getTrackerPoints(),
                    stroke: 'none',
                    strokeWidth: 0,
                    fill: '#000000',
                    opacity: 0.0001
                });
                self._updateActiveElements()
            }
            else if (self._rootElement) {
                self._rootElement.remove();
                delete self._rootElement;
                self._destroy();
                delete self._tracker
            }
            return self
        },
        measure: function() {
            var options = this._options,
                p = this._vertical ? options.x : options.y;
            return {
                    min: p - options.length / 2,
                    max: p + options.length / 2
                }
        },
        getTrackingElement: function() {
            return this._tracker
        },
        getTooltipParameters: function() {
            var self = this,
                options = self._options,
                p = self._getActualPosition(),
                parameters = {
                    x: p,
                    y: p,
                    value: self._currentValue,
                    color: options.color,
                    offset: options.width / 2
                };
            self._vertical ? parameters.x = options.x : parameters.y = options.y;
            return parameters
        }
    });
    linearNeedles.RectangleNeedle = linearNeedles.SimpleIndicator.inherit({_create: function() {
            var self = this,
                options = self._options,
                p = self._zeroPosition,
                x1,
                x2,
                y1,
                y2;
            if (self._vertical) {
                x1 = options.x - options.length / 2 || options.x;
                x2 = options.x + options.length / 2 || options.x;
                y1 = p + options.width / 2 || p;
                y2 = p - options.width / 2 || p
            }
            else {
                x1 = p - options.width / 2 || p;
                x2 = p + options.width / 2 || p;
                y1 = options.y + options.length / 2 || options.y;
                y2 = options.y - options.length / 2 || options.y
            }
            self._element = self._element || self._renderer.createArea().append(self._rootElement);
            self._element.applySettings({
                points: [x1, y1, x1, y2, x2, y2, x2, y1],
                stroke: 'none',
                strokeWidth: 0,
                fill: options.color
            })
        }});
    linearNeedles.RhombusNeedle = linearNeedles.SimpleIndicator.inherit({_create: function() {
            var self = this,
                options = self._options,
                x,
                y,
                dx,
                dy;
            if (self._vertical) {
                x = options.x;
                y = self._zeroPosition;
                dx = options.length / 2 || 0;
                dy = options.width / 2 || 0
            }
            else {
                x = self._zeroPosition;
                y = options.y;
                dx = options.width / 2 || 0;
                dy = options.length / 2 || 0
            }
            self._element = self._element || self._renderer.createArea().append(self._rootElement);
            self._element.applySettings({
                points: [x - dx, y, x, y - dy, x + dx, y, x, y + dy],
                stroke: 'none',
                strokeWidth: 0,
                fill: options.color
            })
        }});
    linearNeedles.CircleNeedle = linearNeedles.SimpleIndicator.inherit({_create: function() {
            var self = this,
                options = self._options,
                x,
                y,
                r;
            if (self._vertical) {
                x = options.x;
                y = self._zeroPosition
            }
            else {
                x = self._zeroPosition;
                y = options.y
            }
            r = options.length / 2 || 0;
            self._element = self._element || self._renderer.createCircle().append(self._rootElement);
            self._element.applySettings({
                cx: x,
                cy: y,
                r: r,
                stroke: 'none',
                strokeWidth: 0,
                fill: options.color
            })
        }})
})(DevExpress, jQuery);

// Module viz, file circularMarker.js

(function(DX, undefined) {
    var circularMarkers = DX.viz.gauges.__internals.circularMarkers;
    var normalizeAngle = DX.utils.normalizeAngle,
        convertAngleToRendererSpace = DX.utils.convertAngleToRendererSpace,
        getCosAndSin = DX.utils.getCosAndSin,
        min = Math.min;
    circularMarkers.TriangleMarker = DX.viz.gauges.__internals.circularNeedles.SimpleIndicator.inherit({
        _isVisible: function() {
            var options = this._options;
            return options.length > 0 && options.width > 0 && options.radius > 0
        },
        _getClassName: function() {
            return 'marker'
        },
        _create: function() {
            var self = this,
                options = self._options,
                x = options.x,
                y1 = options.y - options.radius,
                dx = options.width / 2 || 0,
                y2 = y1 - options.length || y1,
                settings;
            self._element = self._element || self._renderer.createArea().append(self._rootElement);
            settings = {
                points: [x, y1, x - dx, y2, x + dx, y2],
                stroke: 'none',
                strokeWidth: 0,
                fill: options.color
            };
            if (options.space > 0) {
                settings.strokeWidth = min(options.space, options.width / 4) || 0;
                settings.stroke = settings.strokeWidth > 0 ? options.containerBackgroundColor || 'none' : 'none'
            }
            self._element.applySettings(settings)
        },
        _getTrackerPoints: function() {
            var options = this._options,
                x1 = options.x - options.width / 2,
                x2 = options.x + options.width / 2,
                y1 = options.y - options.radius,
                y2 = y1 - options.length || y1;
            return [x1, y1, x1, y2, x2, y2, x2, y1]
        },
        measure: function() {
            var options = this._options;
            return {
                    min: options.radius,
                    max: options.radius + options.length || options.radius
                }
        },
        getTooltipParameters: function() {
            var options = this._options,
                cossin = DX.utils.getCosAndSin(this._getActualPosition()),
                r = options.radius + options.length / 2,
                parameters = this.callBase();
            parameters.x = options.x + cossin.cos * r;
            parameters.y = options.y - cossin.sin * r;
            parameters.offset = options.length / 2;
            return parameters
        }
    });
    circularMarkers.TextCloudMarker = DX.viz.gauges.__internals.BaseTextCloudMarker.inherit({
        _isVisible: function() {
            return this._options.radius > 0
        },
        _getTextCloudOptions: function() {
            var self = this,
                angle = self._getActualPosition(),
                cossin = getCosAndSin(angle),
                nangle = normalizeAngle(angle);
            return {
                    x: self._options.x + cossin.cos * self._options.radius,
                    y: self._options.y - cossin.sin * self._options.radius,
                    type: nangle > 270 ? 'left-top' : nangle > 180 ? 'top-right' : nangle > 90 ? 'right-bottom' : 'bottom-left'
                }
        },
        measure: function() {
            var self = this;
            self._measureText();
            return {
                    min: self._options.radius,
                    max: self._options.radius,
                    horizontalOffset: self._textFullWidth + self._options.arrowLength,
                    verticalOffset: self._textFullHeight + self._options.arrowLength
                }
        }
    })
})(DevExpress);

// Module viz, file linearMarker.js

(function(DX, $, undefined) {
    var linearMarkers = DX.viz.gauges.__internals.linearMarkers;
    var min = Math.min,
        $extend = $.extend;
    linearMarkers.TriangleMarker = DX.viz.gauges.__internals.linearNeedles.SimpleIndicator.inherit({
        _getClassName: function() {
            return 'marker'
        },
        _create: function() {
            var self = this,
                options = self._options,
                x1,
                x2,
                y1,
                y2,
                settings = {
                    stroke: 'none',
                    strokeWidth: 0,
                    fill: options.color
                };
            if (self._vertical) {
                x1 = options.x;
                y1 = self._zeroPosition;
                x2 = x1 + (self._inverted ? options.length : -options.length);
                settings.points = [x1, y1, x2, y1 - options.width / 2, x2, y1 + options.width / 2]
            }
            else {
                y1 = options.y;
                x1 = self._zeroPosition;
                y2 = y1 + (self._inverted ? options.length : -options.length);
                settings.points = [x1, y1, x1 - options.width / 2, y2, x1 + options.width / 2, y2]
            }
            if (options.space > 0) {
                settings.strokeWidth = min(options.space, options.width / 4) || 0;
                settings.stroke = settings.strokeWidth > 0 ? options.containerBackgroundColor || 'none' : 'none'
            }
            self._element = self._element || self._renderer.createArea().append(self._rootElement);
            self._element.applySettings(settings)
        },
        _getTrackerPoints: function() {
            var self = this,
                options = self._options,
                l = Number(options.length) || 0,
                w = options.width / 2 || 0,
                x1,
                x2,
                y1,
                y2,
                result;
            if (self._vertical) {
                x1 = x2 = options.x;
                x2 = x1 + (self._inverted ? options.length : -options.length);
                y1 = self._zeroPosition + options.width / 2;
                y2 = self._zeroPosition - options.width / 2;
                result = [x1, y1, x2, y1, x2, y2, x1, y2]
            }
            else {
                y1 = options.y;
                y2 = y1 + (self._inverted ? options.length : -options.length);
                x1 = self._zeroPosition - options.width / 2;
                x2 = self._zeroPosition + options.width / 2;
                result = [x1, y1, x1, y2, x2, y2, x2, y1]
            }
            return result
        },
        init: function(options) {
            var self = this;
            self.callBase(options);
            self._inverted = self._vertical ? self._options.horizontalOrientation === 'right' : self._options.verticalOrientation === 'bottom';
            return self
        },
        measure: function() {
            var self = this,
                options = self._options,
                minbound,
                maxbound,
                indent = options.width / 2 || 0;
            if (self._vertical) {
                minbound = maxbound = options.x;
                if (self._inverted)
                    maxbound = minbound + options.length || minbound;
                else
                    minbound = maxbound - options.length || maxbound
            }
            else {
                minbound = maxbound = options.y;
                if (self._inverted)
                    maxbound = minbound + options.length || minbound;
                else
                    minbound = maxbound - options.length || maxbound
            }
            return {
                    min: minbound,
                    max: maxbound,
                    indent: indent
                }
        },
        getTooltipParameters: function() {
            var self = this,
                options = self._options,
                s = (self._inverted ? options.length : -options.length) / 2,
                parameters = self.callBase();
            self._vertical ? parameters.x += s : parameters.y += s;
            parameters.offset = options.length / 2;
            return parameters
        }
    });
    linearMarkers.TextCloudMarker = DX.viz.gauges.__internals.BaseTextCloudMarker.inherit({
        _isVisible: function() {
            return true
        },
        _getTextCloudOptions: function() {
            var self = this,
                position = self._getActualPosition(),
                x = position,
                y = position,
                type;
            if (self._vertical) {
                x = self._options.x;
                type = self._inverted ? 'top-left' : 'top-right'
            }
            else {
                y = self._options.y;
                type = self._inverted ? 'right-top' : 'right-bottom'
            }
            return {
                    x: x,
                    y: y,
                    type: type
                }
        },
        init: function(options) {
            var self = this;
            self.callBase(options);
            self._vertical = self._options.orientation === 'vertical';
            self._inverted = self._vertical ? self._options.horizontalOrientation === 'right' : self._options.verticalOrientation === 'bottom';
            return self
        },
        measure: function() {
            var self = this,
                options = self._options,
                minbound,
                maxbound,
                indent;
            self._measureText();
            if (self._vertical) {
                indent = self._textFullHeight;
                if (self._inverted) {
                    minbound = options.x;
                    maxbound = options.x + options.arrowLength + self._textFullWidth
                }
                else {
                    minbound = options.x - options.arrowLength - self._textFullWidth;
                    maxbound = options.x
                }
            }
            else {
                indent = self._textFullWidth;
                if (self._inverted) {
                    minbound = options.y;
                    maxbound = options.y + options.arrowLength + self._textFullHeight
                }
                else {
                    minbound = options.y - options.arrowLength - self._textFullHeight;
                    maxbound = options.y
                }
            }
            return {
                    min: minbound,
                    max: maxbound,
                    indent: indent
                }
        }
    })
})(DevExpress, jQuery);

// Module viz, file circularRangeBar.js

(function(DX, undefined) {
    var getCosAndSin = DX.utils.getCosAndSin,
        convertAngleToRendererSpace = DX.utils.convertAngleToRendererSpace,
        max = Math.max,
        min = Math.min;
    DX.viz.gauges.__internals.CircularRangeBar = DX.viz.gauges.__internals.BaseRangeBar.inherit({
        _isVisible: function() {
            var options = this._options;
            return options.size > 0 && options.radius - options.size > 0
        },
        _createBarItem: function() {
            return this._renderer.createArc().append(this._rootElement)
        },
        _setBarSides: function() {
            var self = this,
                options = self._options;
            self._minSide = options.radius - options.size;
            self._maxSide = options.radius
        },
        _getSpace: function() {
            var options = this._options;
            return options.space > 0 ? options.space * 180 / options.radius / Math.PI : 0
        },
        _isTextVisible: function() {
            var options = this._options.text || {};
            return options.indent > 0
        },
        _getTextAlign: function() {
            return 'center'
        },
        _setTextItemsSides: function() {
            var self = this,
                options = self._options;
            self._lineFrom = options.y - options.radius;
            self._lineTo = self._lineFrom - options.text.indent;
            self._textRadius = options.radius + options.text.indent
        },
        _getPositions: function() {
            var self = this,
                basePosition = self._basePosition,
                actualPosition = self._getActualPosition(),
                mainPosition1,
                mainPosition2,
                space = self._space;
            if (basePosition >= actualPosition) {
                mainPosition1 = basePosition;
                mainPosition2 = actualPosition
            }
            else {
                mainPosition1 = actualPosition;
                mainPosition2 = basePosition
            }
            return {
                    start: self._startPosition,
                    end: self._endPosition,
                    main1: mainPosition1,
                    main2: mainPosition2,
                    back1: min(mainPosition1 + space, self._startPosition),
                    back2: max(mainPosition2 - space, self._endPosition)
                }
        },
        _buildItemSettings: function(from, to) {
            var self = this;
            return {
                    x: self._options.x,
                    y: self._options.y,
                    innerRadius: self._minSide,
                    outerRadius: self._maxSide,
                    startAngle: to,
                    endAngle: from
                }
        },
        _updateTextPosition: function() {
            var self = this,
                cossin = getCosAndSin(self._getActualPosition()),
                x = self._options.x + self._textRadius * cossin.cos,
                y = self._options.y - self._textRadius * cossin.sin;
            x += cossin.cos * self._textWidth / 2;
            y -= cossin.sin * self._textHeight / 2;
            self._text.applySettings({
                x: x,
                y: y + self._textVerticalOffset
            })
        },
        _updateLinePosition: function() {
            var self = this,
                angle = convertAngleToRendererSpace(self._getActualPosition()),
                actualPosition = self._getActualPosition(),
                x = self._options.x,
                x1,
                x2;
            if (self._basePosition > actualPosition) {
                x1 = x - 2;
                x2 = x
            }
            else if (self._basePosition < actualPosition) {
                x1 = x;
                x2 = x + 2
            }
            else {
                x1 = x - 1;
                x2 = x + 1
            }
            self._line.applySettings({points: [x1, self._lineFrom, x1, self._lineTo, x2, self._lineTo, x2, self._lineFrom]});
            self._line.rotate(angle, x, self._options.y)
        },
        measure: function() {
            var self = this,
                options = self._options,
                result = {
                    min: options.radius - options.size || options.radius,
                    max: options.radius
                };
            self._prepare();
            if (self._hasText) {
                result.max += options.text.indent;
                result.horizontalOffset = self._textWidth;
                result.verticalOffset = self._textHeight
            }
            return result
        }
    })
})(DevExpress);

// Module viz, file linearRangeBar.js

(function(DX, undefined) {
    DX.viz.gauges.__internals.LinearRangeBar = DX.viz.gauges.__internals.BaseRangeBar.inherit({
        _isVisible: function() {
            var options = this._options;
            return options.size > 0
        },
        _prepare: function() {
            var self = this;
            self.callBase();
            self._vertical = self._options.orientation === 'vertical';
            self._inverted = self._vertical ? self._options.horizontalOrientation === 'right' : self._options.verticalOrientation === 'bottom'
        },
        _createBarItem: function() {
            return this._renderer.createArea().append(this._rootElement)
        },
        _setBarSides: function() {
            var self = this,
                options = self._options,
                minSide,
                maxSide;
            if (self._vertical)
                if (self._inverted) {
                    minSide = options.x;
                    maxSide = options.x + options.size
                }
                else {
                    minSide = options.x - options.size;
                    maxSide = options.x
                }
            else if (self._inverted) {
                minSide = options.y;
                maxSide = options.y + options.size
            }
            else {
                minSide = options.y - options.size;
                maxSide = options.y
            }
            self._minSide = minSide;
            self._maxSide = maxSide;
            self._minBound = minSide;
            self._maxBound = maxSide
        },
        _getSpace: function() {
            var options = this._options;
            return options.space > 0 ? Number(options.space) : 0
        },
        _isTextVisible: function() {
            var textOptions = this._options.text || {};
            return textOptions.indent > 0 || textOptions.indent < 0
        },
        _getTextAlign: function() {
            return this._vertical ? this._options.text.indent > 0 ? 'left' : 'right' : 'center'
        },
        _setTextItemsSides: function() {
            var self = this,
                indent = Number(self._options.text.indent);
            if (indent > 0) {
                self._lineStart = self._maxSide;
                self._lineEnd = self._maxSide + indent;
                self._textPosition = self._lineEnd + (self._vertical ? 2 : self._textHeight / 2);
                self._maxBound = self._textPosition + (self._vertical ? self._textWidth : self._textHeight / 2)
            }
            else if (indent < 0) {
                self._lineStart = self._minSide;
                self._lineEnd = self._minSide + indent;
                self._textPosition = self._lineEnd - (self._vertical ? 2 : self._textHeight / 2);
                self._minBound = self._textPosition - (self._vertical ? self._textWidth : self._textHeight / 2)
            }
        },
        _getPositions: function() {
            var self = this,
                options = self._options,
                startPosition = self._startPosition,
                endPosition = self._endPosition,
                space = self._space,
                basePosition = self._basePosition,
                actualPosition = self._getActualPosition(),
                mainPosition1,
                mainPosition2,
                backPosition1,
                backPosition2;
            if (startPosition < endPosition) {
                if (basePosition < actualPosition) {
                    mainPosition1 = basePosition;
                    mainPosition2 = actualPosition
                }
                else {
                    mainPosition1 = actualPosition;
                    mainPosition2 = basePosition
                }
                backPosition1 = mainPosition1 - space;
                backPosition2 = mainPosition2 + space
            }
            else {
                if (basePosition > actualPosition) {
                    mainPosition1 = basePosition;
                    mainPosition2 = actualPosition
                }
                else {
                    mainPosition1 = actualPosition;
                    mainPosition2 = basePosition
                }
                backPosition1 = mainPosition1 + space;
                backPosition2 = mainPosition2 - space
            }
            return {
                    start: startPosition,
                    end: endPosition,
                    main1: mainPosition1,
                    main2: mainPosition2,
                    back1: backPosition1,
                    back2: backPosition2
                }
        },
        _buildItemSettings: function(from, to) {
            var self = this,
                side1 = self._minSide,
                side2 = self._maxSide;
            var points = self._vertical ? [side1, from, side1, to, side2, to, side2, from] : [from, side1, from, side2, to, side2, to, side1];
            return {points: points}
        },
        _updateTextPosition: function() {
            var self = this,
                options = self._options,
                position = self._getActualPosition();
            self._text.applySettings(self._vertical ? {
                x: self._textPosition,
                y: position + self._textVerticalOffset
            } : {
                x: position,
                y: self._textPosition + self._textVerticalOffset
            })
        },
        _updateLinePosition: function() {
            var self = this,
                actualPosition = self._getActualPosition(),
                side1,
                side2,
                points;
            if (self._vertical) {
                if (self._basePosition >= actualPosition) {
                    side1 = actualPosition;
                    side2 = actualPosition + 2
                }
                else {
                    side1 = actualPosition - 2;
                    side2 = actualPosition
                }
                points = [self._lineStart, side1, self._lineStart, side2, self._lineEnd, side2, self._lineEnd, side1]
            }
            else {
                if (self._basePosition <= actualPosition) {
                    side1 = actualPosition - 2;
                    side2 = actualPosition
                }
                else {
                    side1 = actualPosition;
                    side2 = actualPosition + 2
                }
                points = [side1, self._lineStart, side1, self._lineEnd, side2, self._lineEnd, side2, self._lineStart]
            }
            self._line.applySettings({points: points})
        },
        measure: function() {
            var self = this,
                options = self._options,
                minbound,
                maxbound,
                indent;
            self._prepare();
            if (self._vertical) {
                minbound = maxbound = options.x;
                if (self._inverted)
                    maxbound = maxbound + options.size || maxbound;
                else
                    minbound = minbound - options.size || minbound;
                if (self._hasText) {
                    indent = self._textHeight / 2;
                    if (options.text.indent > 0)
                        maxbound += options.text.indent + self._textWidth;
                    if (options.text.indent < 0)
                        minbound += options.text.indent - self._textWidth
                }
            }
            else {
                minbound = maxbound = options.y;
                if (self._inverted)
                    maxbound = maxbound + options.size || maxbound;
                else
                    minbound = minbound - options.size || minbound;
                if (self._hasText) {
                    indent = self._textWidth / 2;
                    if (options.text.indent > 0)
                        maxbound += options.text.indent + self._textHeight;
                    if (options.text.indent < 0)
                        minbound += options.text.indent - self._textHeight
                }
            }
            return {
                    min: minbound,
                    max: maxbound,
                    indent: indent
                }
        }
    })
})(DevExpress);

// Module viz, file circularSpindle.js

(function(DX, $, undefined) {
    var min = Math.min,
        $extend = $.extend;
    DX.viz.gauges.__internals.CircularSpindle = DX.Class.inherit({
        setup: function(parameters) {
            this._renderer = parameters.renderer;
            this._owner = parameters.owner;
            return this
        },
        init: function(options) {
            this._options = $extend(true, this._options || {}, options);
            return this
        },
        render: function() {
            var self = this,
                options = self._options;
            if (options.visible !== false && options.size > 0) {
                self._rootElement = self._rootElement || self._renderer.createGroup({'class': 'spindle'});
                self._rootElement.append(self._owner);
                self._element = self._element || self._renderer.createCircle().append(self._rootElement);
                self._element.applySettings({
                    cx: options.x,
                    cy: options.y,
                    r: options.size / 2,
                    fill: options.color || 'none',
                    stroke: 'none',
                    strokeWidth: 0
                });
                if (options.gapSize > 0) {
                    self._gapElement = self._gapElement || self._renderer.createCircle().append(self._rootElement);
                    self._gapElement.applySettings({
                        cx: options.x,
                        cy: options.y,
                        r: min(options.size, options.gapSize) / 2,
                        fill: options.containerBackgroundColor || 'none',
                        stroke: 'none',
                        strokeWidth: 0
                    })
                }
                else {
                    self._gapElement && self._gapElement.remove();
                    delete self._gapElement
                }
            }
            else {
                self._rootElement && self._rootElement.remove();
                delete self._rootElement;
                self._element && self._element.remove();
                delete self._element;
                self._gapElement && self._gapElement.remove();
                delete self._gapElement
            }
            return self
        },
        measure: function() {
            var r = this._options.size / 2 || 0;
            return {
                    inverseHorizontalOffset: r,
                    inverseVerticalOffset: r
                }
        }
    })
})(DevExpress, jQuery);

// Module viz, file rangeContainer.js

(function(DX, $, undefined) {
    var isDefined = DX.utils.isDefined,
        isString = DX.utils.isString,
        isArray = DX.utils.isArray,
        Number = window.Number,
        isFinite = window.isFinite,
        max = Math.max,
        abs = Math.abs,
        $each = $.each,
        $map = $.map,
        $extend = $.extend;
    function subtractSegmentAsc(segmentStart, segmentEnd, otherStart, otherEnd) {
        var result;
        if (otherStart > segmentStart && otherEnd < segmentEnd)
            result = [{
                    start: segmentStart,
                    end: otherStart
                }, {
                    start: otherEnd,
                    end: segmentEnd
                }];
        else if (otherStart >= segmentEnd || otherEnd <= segmentStart)
            result = [{
                    start: segmentStart,
                    end: segmentEnd
                }];
        else if (otherStart <= segmentStart && otherEnd >= segmentEnd)
            result = [];
        else if (otherStart > segmentStart)
            result = [{
                    start: segmentStart,
                    end: otherStart
                }];
        else if (otherEnd < segmentEnd)
            result = [{
                    start: otherEnd,
                    end: segmentEnd
                }];
        return result
    }
    function subtractSegmentDes(segmentStart, segmentEnd, otherStart, otherEnd) {
        var result;
        if (otherStart < segmentStart && otherEnd > segmentEnd)
            result = [{
                    start: segmentStart,
                    end: otherStart
                }, {
                    start: otherEnd,
                    end: segmentEnd
                }];
        else if (otherStart <= segmentEnd || otherEnd >= segmentStart)
            result = [{
                    start: segmentStart,
                    end: segmentEnd
                }];
        else if (otherStart >= segmentStart && otherEnd <= segmentEnd)
            result = [];
        else if (otherStart < segmentStart)
            result = [{
                    start: segmentStart,
                    end: otherStart
                }];
        else if (otherEnd > segmentEnd)
            result = [{
                    start: otherEnd,
                    end: segmentEnd
                }];
        return result
    }
    function isNotEmptySegmentAsc(start, end, threshold) {
        return end - start >= threshold
    }
    function isNotEmptySegmentDes(start, end, threshold) {
        return start - end >= threshold
    }
    DX.viz.gauges.__internals.BaseRangeContainer = DX.Class.inherit({
        setup: function(parameters) {
            var self = this;
            DX.utils.debug.assertParam(parameters.renderer, '"renderer" was not passed');
            DX.utils.debug.assertParam(parameters.owner, '"owner" was not passed');
            DX.utils.debug.assertParam(parameters.incidentOccured, '"incidentOccured" was not passed');
            self._renderer = parameters.renderer;
            self._owner = parameters.owner;
            self._incidentOccured = parameters.incidentOccured;
            return self
        },
        init: function(options) {
            var self = this;
            self._options = $extend(true, self._options || {}, options);
            if (options && isDefined(options.ranges))
                self._options.ranges = isArray(options.ranges) ? options.ranges.slice(0) : null;
            return self
        },
        _getRanges: function() {
            var options = this._options,
                translator = options.translator,
                totalStart = translator.getDomainStart(),
                totalEnd = translator.getDomainEnd(),
                totalDelta = totalEnd - totalStart,
                isNotEmptySegment = totalDelta >= 0 ? isNotEmptySegmentAsc : isNotEmptySegmentDes,
                subtractSegment = totalDelta >= 0 ? subtractSegmentAsc : subtractSegmentDes,
                list = [],
                ranges = [],
                backgroundRanges = [{
                        start: totalStart,
                        end: totalEnd
                    }],
                threshold = abs(totalDelta) / 1E4,
                palette = isArray(options.palette) ? options.palette : [],
                paletteOffset,
                backgroundColor = isString(options.backgroundColor) ? options.backgroundColor : 'none',
                width = options.width || {},
                startWidth = Number(width > 0 ? width : width.start),
                endWidth = Number(width > 0 ? width : width.end),
                deltaWidth = endWidth - startWidth;
            if (!options.ranges) {
                this._incidentOccured('The range container is not rendered because the value of the "ranges" option is not valid');
                return null
            }
            if (!(startWidth >= 0 && endWidth >= 0 && startWidth + endWidth > 0)) {
                this._incidentOccured('The range container is not rendered because the value of the "width" option is not valid');
                return null
            }
            list = $map(options.ranges, function(rangeOptions) {
                rangeOptions = rangeOptions || {};
                var start = translator.adjust(rangeOptions.startValue),
                    end = translator.adjust(rangeOptions.endValue);
                return isFinite(start) && isFinite(end) && isNotEmptySegment(start, end, threshold) ? {
                        start: start,
                        end: end,
                        color: rangeOptions.color
                    } : null
            });
            paletteOffset = max(0, palette.length - list.length);
            $each(list, function(i, item) {
                var color = item.color;
                isString(color) || (color = palette[i + paletteOffset]);
                isString(color) || (color = 'none');
                item.color = color
            });
            $each(list, function(_, item) {
                var i,
                    ii,
                    sub,
                    subs,
                    range,
                    newRanges = [],
                    newBackgroundRanges = [];
                for (i = 0, ii = ranges.length; i < ii; ++i) {
                    range = ranges[i];
                    subs = subtractSegment(range.start, range.end, item.start, item.end);
                    (sub = subs[0]) && (sub.color = range.color) && newRanges.push(sub);
                    (sub = subs[1]) && (sub.color = range.color) && newRanges.push(sub)
                }
                newRanges.push(item);
                ranges = newRanges;
                for (i = 0, ii = backgroundRanges.length; i < ii; ++i) {
                    range = backgroundRanges[i];
                    subs = subtractSegment(range.start, range.end, item.start, item.end);
                    (sub = subs[0]) && newBackgroundRanges.push(sub);
                    (sub = subs[1]) && newBackgroundRanges.push(sub)
                }
                backgroundRanges = newBackgroundRanges
            });
            $each(backgroundRanges, function(_, range) {
                range.color = backgroundColor;
                ranges.push(range)
            });
            $each(ranges, function(_, range) {
                range.startPosition = translator.translate(range.start);
                range.endPosition = translator.translate(range.end);
                range.startWidth = (range.start - totalStart) / totalDelta * deltaWidth + startWidth;
                range.endWidth = (range.end - totalStart) / totalDelta * deltaWidth + startWidth
            });
            return ranges
        },
        render: function() {
            var self = this,
                ranges;
            self._rootElement = self._rootElement || self._renderer.createGroup({'class': 'range-container'});
            self._rootElement.append(self._owner).clear();
            ranges = self._getRanges();
            if (!ranges || !self._renderRanges(ranges)) {
                self._rootElement.remove();
                delete self._rootElement
            }
            return self
        }
    });
    DX.viz.gauges.__internals.CircularRangeContainer = DX.viz.gauges.__internals.BaseRangeContainer.inherit({
        _renderRanges: function(ranges) {
            var self = this,
                options = self._options,
                x = options.x,
                y = options.y,
                r = options.radius,
                renderer = self._renderer,
                root = self._rootElement,
                inner = 0,
                outer = 0,
                width = options.width > 0 ? options.width : max(options.width.start, options.width.end);
            switch (options.orientation) {
                case'inside':
                    inner = 1;
                    break;
                case'outside':
                    outer = 1;
                    break;
                case'center':
                    inner = outer = 0.5;
                    break;
                default:
                    self._incidentOccured('The range container is not rendered because the value of the "orientation" option is not valid');
                    break
            }
            if ((inner || outer) && r + outer * width > 0 && r - inner * width > 0) {
                $each(ranges, function(_, range) {
                    var width = (range.startWidth + range.endWidth) / 2;
                    renderer.createArc(x, y, r + outer * width, r - inner * width, range.endPosition, range.startPosition, {
                        stroke: 'none',
                        strokeWidth: 0,
                        fill: range.color
                    }).append(root)
                });
                return true
            }
            return false
        },
        measure: function() {
            var options = this._options,
                radius = options.radius,
                size = options.width || {},
                result = null;
            size = Number(size) || max(size.start, size.end, 0) || 0;
            switch (options.orientation) {
                case'inside':
                    result = {
                        min: radius - size,
                        max: radius
                    };
                    break;
                case'outside':
                    result = {
                        min: radius,
                        max: radius + size
                    };
                    break;
                case'center':
                    result = {
                        min: radius - size / 2,
                        max: radius + size / 2
                    };
                    break
            }
            return result
        }
    });
    DX.viz.gauges.__internals.LinearRangeContainer = DX.viz.gauges.__internals.BaseRangeContainer.inherit({
        _renderRanges: function(ranges) {
            var self = this,
                options = self._options,
                renderer = self._renderer,
                root = self._rootElement,
                inner = 0,
                outer = 0,
                position;
            if (options.orientation === 'vertical') {
                position = options.x;
                switch (options.horizontalOrientation) {
                    case'left':
                        inner = 1;
                        break;
                    case'right':
                        outer = 1;
                        break;
                    case'center':
                        inner = outer = 0.5;
                        break;
                    default:
                        self._incidentOccured('The range container is not rendered because the value of the "horizontalOrientation" option is not valid');
                        break
                }
                if (inner || outer) {
                    $each(ranges, function(_, range) {
                        renderer.createArea([position - range.startWidth * inner, range.startPosition, position - range.endWidth * inner, range.endPosition, position + range.endWidth * outer, range.endPosition, position + range.startWidth * outer, range.startPosition], {
                            stroke: 'none',
                            strokeWidth: 0,
                            fill: range.color
                        }).append(root)
                    });
                    return true
                }
            }
            else {
                position = options.y;
                switch (options.verticalOrientation) {
                    case'top':
                        inner = 1;
                        break;
                    case'bottom':
                        outer = 1;
                        break;
                    case'middle':
                        inner = outer = 0.5;
                        break;
                    default:
                        self._incidentOccured('The range container is not rendered because the value of the "verticalOrientation" option is not valid');
                        break
                }
                if (inner || outer) {
                    $each(ranges, function(_, range) {
                        renderer.createArea([range.startPosition, position + range.startWidth * outer, range.startPosition, position - range.startWidth * inner, range.endPosition, position - range.endWidth * inner, range.endPosition, position + range.endWidth * outer], {
                            stroke: 'none',
                            strokeWidth: 0,
                            fill: range.color
                        }).append(root)
                    });
                    return true
                }
            }
            return false
        },
        measure: function() {
            var options = this._options,
                size = options.width || {},
                result = null;
            size = Number(size) || max(size.start, size.end, 0) || 0;
            if (options.orientation === 'vertical') {
                result = {
                    min: options.x,
                    max: options.x
                };
                switch (options.horizontalOrientation) {
                    case'left':
                        result.min -= size;
                        break;
                    case'right':
                        result.max += size;
                        break;
                    case'center':
                        result.min -= size / 2;
                        result.max += size / 2;
                        break
                }
            }
            else {
                result = {
                    min: options.y,
                    max: options.y
                };
                switch (options.verticalOrientation) {
                    case'top':
                        result.min -= size;
                        break;
                    case'bottom':
                        result.max += size;
                        break;
                    case'middle':
                        result.min -= size / 2;
                        result.max += size / 2;
                        break
                }
            }
            return result
        }
    })
})(DevExpress, jQuery);

// Module viz, file title.js

(function(DX, $, undefined) {
    var Rectangle = DX.viz.core.Rectangle;
    var isString = DX.utils.isString,
        isDefined = DX.utils.isDefined,
        min = Math.min,
        max = Math.max,
        floor = Math.floor,
        ceil = Math.ceil,
        $extend = $.extend;
    DX.viz.gauges.__internals.Title = DX.Class.inherit({
        ctor: function() {
            this._options = {
                title: {},
                subtitle: {}
            }
        },
        _measureTexts: function() {
            var self = this,
                mainBox = self._mainText ? self._mainText.getBBox() : null,
                subBox = self._subText ? self._subText.getBBox() : null,
                dy;
            self._location = {
                x: 0,
                y: 0
            };
            if (mainBox && subBox) {
                self._subText.applySettings({y: ceil(-subBox.y)});
                self._rect = new Rectangle({
                    left: floor(min(mainBox.x, subBox.x)),
                    right: ceil(max(mainBox.x + mainBox.width, subBox.x + subBox.width)),
                    top: floor(mainBox.y),
                    bottom: ceil(subBox.height)
                })
            }
            else if (mainBox || subBox) {
                mainBox = mainBox || subBox;
                self._rect = new Rectangle({
                    left: floor(mainBox.x),
                    right: ceil(mainBox.x + mainBox.width),
                    top: floor(mainBox.y),
                    bottom: ceil(mainBox.y + mainBox.height)
                })
            }
        },
        render: function(options) {
            var self = this;
            $extend(true, self._options, options);
            self._root = self._root || self._renderer.createGroup().applySettings({'class': 'title'}).append(self._owner);
            if (isString(self._options.title.text)) {
                self._mainText = self._mainText || self._renderer.createText().append(self._root);
                self._mainText.applySettings({
                    x: 0,
                    y: 0,
                    align: 'center',
                    font: self._options.title.font,
                    text: self._options.title.text
                })
            }
            else {
                self._mainText && self._mainText.remove();
                delete self._mainText
            }
            if (isString(self._options.subtitle.text)) {
                self._subText = self._subText || self._renderer.createText().append(self._root);
                self._subText.applySettings({
                    x: 0,
                    y: 0,
                    align: 'center',
                    font: self._options.subtitle.font,
                    text: self._options.subtitle.text
                })
            }
            else {
                self._subText && self._subText.remove();
                delete self._subText
            }
            if (self._mainText || self._subText)
                self._measureTexts();
            else {
                self._root && self._root.remove();
                delete self._root
            }
            return self
        },
        processTitleOptions: function(options) {
            if (isString(options))
                return {text: options};
            else if (!isDefined(options))
                return {text: null};
            else {
                options = $extend({}, options);
                options.layout = $extend({}, options.layout, {position: options.position});
                return options
            }
        },
        processSubtitleOptions: function(options) {
            if (isString(options))
                return {text: options};
            else if (!isDefined(options))
                return {text: null};
            else
                return $extend({}, options)
        },
        isVisible: function() {
            return !!(this._mainText || this._subText)
        },
        getBoundingRect: function() {
            return this._rect.clone()
        },
        getLayoutOptions: function() {
            return this._options.title.layout || {}
        },
        move: function(dx, dy) {
            var self = this;
            self._root.move(self._location.x += dx, self._location.y += dy);
            self._rect = self._rect.move(dx, dy);
            return self
        }
    })
})(DevExpress, jQuery);

// Module viz, file layoutManager.js

(function(DX, undefined) {
    var min = Math.min,
        max = Math.max,
        isString = DX.utils.isString;
    var Rectangle = DX.viz.core.Rectangle;
    function parseLayoutOptions(options) {
        options = options || {};
        var parts = (isString(options) ? options : options.position || '').split('-');
        return {
                primary: isString(parts[0]) ? parts[0].toLowerCase() : '',
                secondary: isString(parts[1]) ? parts[1].toLowerCase() : '',
                overlay: options.overlay > 0 ? Number(options.overlay) : 0
            }
    }
    DX.viz.gauges.__internals.LayoutManager = DX.Class.inherit({
        setRect: function(rect) {
            this._rect = rect.clone();
            return this
        },
        getRect: function() {
            return this._rect.clone()
        },
        applyLayout: function(rect, options) {
            var dx = 0,
                dy = 0,
                availableRect = this._rect,
                resultRect = rect.clone(),
                options_ = parseLayoutOptions(options),
                delta = resultRect.height() - options_.overlay;
            switch (options_.primary) {
                case'top':
                    if (delta >= 0) {
                        dy = availableRect.top - resultRect.top;
                        availableRect.top = min(availableRect.top + delta, availableRect.bottom)
                    }
                    else
                        dy = availableRect.top - resultRect.top - delta;
                    break;
                case'bottom':
                    if (delta >= 0) {
                        dy = availableRect.bottom - resultRect.bottom;
                        availableRect.bottom = max(availableRect.bottom - delta, availableRect.top)
                    }
                    else
                        dy = availableRect.bottom - resultRect.bottom + delta;
                    break
            }
            switch (options_.secondary) {
                case'':
                case'center':
                    dx = availableRect.horizontalMiddle() - resultRect.horizontalMiddle();
                    break;
                case'left':
                    dx = availableRect.left - resultRect.left;
                    break;
                case'right':
                    dx = availableRect.right - resultRect.right;
                    break
            }
            resultRect = resultRect.move(dx, dy);
            return {
                    rect: resultRect,
                    dx: dx,
                    dy: dy
                }
        },
        selectRectByAspectRatio: function(aspectRatio, margins) {
            var rect = this._rect.clone(),
                selfAspectRatio,
                width = 0,
                height = 0;
            margins = margins || {};
            if (aspectRatio > 0) {
                rect.left += margins.left || 0;
                rect.right -= margins.right || 0;
                rect.top += margins.top || 0;
                rect.bottom -= margins.bottom || 0;
                selfAspectRatio = rect.height() / rect.width();
                if (selfAspectRatio > 1)
                    aspectRatio < selfAspectRatio ? width = rect.width() : height = rect.height();
                else
                    aspectRatio > selfAspectRatio ? height = rect.height() : width = rect.width();
                width > 0 || (width = height / aspectRatio);
                height > 0 || (height = width * aspectRatio);
                width = (rect.width() - width) / 2;
                height = (rect.height() - height) / 2;
                rect.left += width;
                rect.right -= width;
                rect.top += height;
                rect.bottom -= height
            }
            return rect
        },
        selectRectBySizes: function(sizes, margins) {
            var rect = this._rect.clone(),
                step;
            margins = margins || {};
            if (sizes) {
                rect.left += margins.left || 0;
                rect.right -= margins.right || 0;
                rect.top += margins.top || 0;
                rect.bottom -= margins.bottom || 0;
                if (sizes.width > 0) {
                    step = (rect.width() - sizes.width) / 2;
                    if (step > 0) {
                        rect.left += step;
                        rect.right -= step
                    }
                }
                if (sizes.height > 0) {
                    step = (rect.height() - sizes.height) / 2;
                    if (step > 0) {
                        rect.top += step;
                        rect.bottom -= step
                    }
                }
            }
            return rect
        }
    })
})(DevExpress, jQuery);

// Module viz, file themeManager.js

(function($, DX, undefined) {
    var defaultFormatText = function(text) {
            if (isString(text))
                return text;
            if (isNumber(text))
                return text.toString();
            return 'N/A'
        };
    DX.viz.gauges.__internals.ThemeManager = DX.viz.core.BaseThemeManager.inherit(function() {
        var ctor = function(userTheme) {
                this.callBase(userTheme, 'gauge');
                this.theme.area.defaultFormatText = defaultFormatText
            };
        var getRangeTheme = function() {
                return this.theme.range || {}
            };
        var getScaleTheme = function() {
                return this.theme.scale || {}
            };
        var getNeedleTheme = function() {
                return this.theme.needle || {}
            };
        var getMarkerTheme = function() {
                return this.theme.marker || {}
            };
        return {
                ctor: ctor,
                getRangeTheme: getRangeTheme,
                getScaleTheme: getScaleTheme,
                getNeedleTheme: getNeedleTheme,
                getMarkerTheme: getMarkerTheme
            }
    }())
})(jQuery, DevExpress);

// Module viz, file presetManager.js

(function(DX, $, undefined) {
    var internals = DX.viz.gauges.__internals;
    var circularPresets = {
            preset1: {
                commonNeedleSettings: {type: 'rectangle'},
                commonMarkerSettings: {type: 'textcloud'}
            },
            preset2: {
                commonNeedleSettings: {type: 'twocolorrectangle'},
                commonMarkerSettings: {
                    offset: 6,
                    type: 'triangle'
                }
            },
            preset3: {
                commonMarkerSettings: {
                    offset: 6,
                    type: 'triangle'
                },
                commonRangeBarSettings: {text: {indent: 70}}
            }
        };
    var linearPresets = {
            preset1: {
                commonNeedleSettings: {type: 'rhombus'},
                commonMarkerSettings: {type: 'textcloud'}
            },
            preset2: {
                commonNeedleSettings: {type: 'circle'},
                commonMarkerSettings: {type: 'triangle'}
            }
        };
    DX.viz.gauges.__internals.PresetManager = DX.Class.inherit({
        setup: function(gaugeType, presetName) {
            var self = this;
            self._activePreset = {};
            self._setPresetsCollection(self._selectPresets(gaugeType), 'preset1');
            return self._setActivePreset(presetName)
        },
        _selectPresets: function(gaugeType) {
            var presets = {};
            switch (gaugeType) {
                case'circular':
                    presets = circularPresets;
                    break;
                case'linear':
                    presets = linearPresets;
                    break
            }
            return presets
        },
        _setActivePreset: function(preset) {
            var currentPreset = {},
                argIsString = !preset || typeof preset === 'string';
            this._presetName = argIsString ? preset : preset.name;
            if (this._presetName !== 'none') {
                if (!argIsString)
                    this._updatePreset(preset);
                this._activePreset = this._getCollectionElement(this._presetName)
            }
            else
                this._activePreset = argIsString ? currentPreset : preset;
            return this._activePreset
        },
        getNeedlePreset: function() {
            return this._activePreset.commonNeedleSettings || {}
        },
        getMarkerPreset: function() {
            return this._activePreset.commonMarkerSettings || {}
        },
        getRangeBarPreset: function() {
            return this._activePreset.commonRangeBarSettings || {}
        },
        getScalePreset: function() {
            return this._activePreset.commonScaleSettings || {}
        },
        getRangePreset: function() {
            return this._activePreset.commonRangeSettings || {}
        },
        getTitlePreset: function() {
            return this._activePreset.title || {}
        },
        getSubtitlePreset: function() {
            return this._activePreset.subtitle || {}
        },
        getIndicatorPreset: function() {
            return this._activePreset.indicator || {}
        },
        getSpindlePreset: function() {
            return this._activePreset.spindle || {}
        },
        _updatePreset: function(preset) {
            if (this._presetsCollection.hasOwnProperty(preset.name))
                $.extend(true, this._presetsCollection[preset.name], preset);
            else
                $.extend(true, this._presetsCollection.defaultPreset, preset)
        },
        _getCollectionElement: function(elementName) {
            var element = {};
            if (this._presetsCollection.hasOwnProperty(elementName))
                element = this._presetsCollection[elementName];
            else
                element = this._presetsCollection.defaultPreset;
            return element
        },
        _setPresetsCollection: function(presetsCollection, defaultPresetName) {
            this._presetsCollection = $.extend(true, {}, presetsCollection || {});
            if (defaultPresetName && this._presetsCollection.hasOwnProperty(defaultPresetName))
                this._presetsCollection.defaultPreset = $.extend({}, this._presetsCollection[defaultPresetName]);
            else
                this._presetsCollection.defaultPreset = {}
        }
    });
    $.extend(DX.viz.gauges.__tests, {
        circularPresets: circularPresets,
        linearPresets: linearPresets
    })
})(DevExpress, jQuery);

// Module viz, file gauge.js

(function(DX, $, undefined) {
    var factory = DX.viz.gauges.__factory;
    var Rectangle = DX.viz.core.Rectangle;
    var isNumber = DX.utils.isNumber,
        isString = DX.utils.isString,
        isFunction = DX.utils.isFunction,
        isFinite = window.isFinite,
        setTimeout = window.setTimeout,
        windowResizeCallbacks = DX.utils.windowResizeCallbacks,
        $extend = $.extend,
        $each = $.each;
    var REDRAW_DELAY = 500;
    var DEFAULT_GAUGE_OPTIONS = {
            size: {
                width: undefined,
                height: undefined
            },
            margin: {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            },
            geometry: {},
            preset: 'preset1',
            containerBackgroundColor: '#FFFFFF',
            animationEnabled: true,
            redrawOnResize: true,
            incidentOccured: $.noop,
            needles: [],
            markers: [],
            rangeBars: [],
            scale: {
                startValue: 0,
                endValue: 100,
                majorTick: {
                    visible: true,
                    type: 'rectangle',
                    tickInterval: undefined,
                    customTickValues: [],
                    length: 5,
                    width: 2,
                    showCalculatedTicks: true,
                    useTicksAutoArrangement: true,
                    color: '#FFFFFF'
                },
                minorTick: {
                    visible: false,
                    type: 'rectangle',
                    tickInterval: undefined,
                    customTickValues: [],
                    length: 3,
                    width: 1,
                    showCalculatedTicks: true,
                    color: '#FFFFFF'
                },
                label: {
                    visible: true,
                    format: '',
                    precision: 2,
                    customizeText: undefined,
                    font: {
                        color: '#7F7F7F',
                        size: 12,
                        family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                        weight: 400
                    }
                }
            },
            rangeContainer: {
                offset: 0,
                width: 5,
                backgroundColor: '#808080',
                palette: ['#AD79CE', '#639EC6', '#A5C763', '#FFB65A', '#E78E94'],
                ranges: []
            },
            commonNeedleSettings: {
                __info: 'needle',
                color: '#C2C2C2'
            },
            commonMarkerSettings: {
                __info: 'marker',
                color: '#679EC5',
                space: 2,
                length: 14,
                width: 13,
                arrowLength: 5,
                horizontalOffset: 6,
                verticalOffset: 3,
                text: {
                    customizeText: undefined,
                    font: {
                        color: '#FFFFFF',
                        size: 18,
                        family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                        weight: 400
                    }
                }
            },
            commonRangeBarSettings: {
                baseValue: undefined,
                color: '#AD79CE',
                backgroundColor: 'none',
                space: 2,
                size: 10,
                text: {
                    indent: 0,
                    customizeText: undefined,
                    font: {
                        size: 14,
                        family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                        weight: 400
                    }
                }
            },
            title: {
                layout: {
                    position: 'top-center',
                    overlay: 0
                },
                font: {
                    size: 18,
                    color: '#232323',
                    family: "'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                    weight: 200
                }
            },
            subtitle: {font: {
                    size: 14,
                    color: '#232323',
                    family: "'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                    weight: 200
                }},
            indicator: {
                hasPositiveMeaning: true,
                text: {
                    format: 'fixedPoint',
                    precision: 0,
                    customizeText: $.none,
                    useDefaultColor: false,
                    font: {
                        color: '#7F7F7F',
                        size: 18,
                        family: "'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                        weight: 400
                    }
                },
                layout: {
                    position: 'bottom-center',
                    overlay: 0
                }
            },
            tooltip: {
                enabled: false,
                format: undefined,
                precision: undefined,
                customizeText: undefined,
                font: {
                    color: '#FFFFFF',
                    size: 26,
                    family: "'SegoeUI-Light', 'Segoe UI Light', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'SegoeUI', 'Segoe UI', 'HelveticaNeue', 'Helvetica Neue', 'Trebuchet MS', Verdana",
                    weight: 200
                },
                horizontalPadding: 22,
                verticalPadding: 6,
                arrowLength: 10
            },
            tracker: {tooltipDelay: 500}
        };
    DX.viz.gauges.Gauge = DX.ui.Component.inherit({
        _defaultOptions: function() {
            return $extend(true, {}, DEFAULT_GAUGE_OPTIONS)
        },
        _initOptions: function(options) {
            var self = this,
                preset;
            self._presetManager = factory.createPresetManager();
            preset = self._presetManager.setup(self._gaugeType(), options ? options.preset : {});
            self.option(preset);
            self.callBase(options)
        },
        _getPresetName: function(options) {
            return options && isString(options.preset) ? options.preset : this.option('preset')
        },
        _init: function() {
            var self = this;
            self._isRendered = false;
            self._canvas = {
                width: 0,
                height: 0,
                marginLeft: 0,
                marginRight: 0,
                marginTop: 0,
                marginBottom: 0
            };
            self._renderer = factory.createRenderer();
            self._tracker = factory.createTracker();
            self._tracker.setup(self);
            self._layoutManager = factory.createLayoutManager();
            self._mainElements = [];
            self._externalElements = [];
            self._defaultOpts = self._defaultOptions();
            self._needles = [];
            self._markers = [];
            self._rangeBars = [];
            if (self.option('redrawOnResize') === true)
                windowResizeCallbacks.add(self.resizeHandler())
        },
        resizeHandler: function() {
            var self = this,
                jqWindow = $(window),
                currentDelayTimeout,
                formatSize = function() {
                    return [jqWindow.width(), jqWindow.height()].join()
                };
            return function() {
                    var prevSize = formatSize(),
                        currentSize;
                    if (currentDelayTimeout) {
                        clearTimeout(currentDelayTimeout);
                        currentDelayTimeout = 0
                    }
                    currentDelayTimeout = setTimeout(function() {
                        currentSize = formatSize();
                        if (currentSize === prevSize)
                            self._render({resize: true})
                    }, REDRAW_DELAY)
                }
        },
        _getIncidentOccured: function() {
            var incidentOccured = this.option('incidentOccured');
            isFunction(incidentOccured) || (incidentOccured = this._defaultOpts.incidentOccured);
            return function() {
                    incidentOccured.apply(null, arguments)
                }
        },
        _getCreationOptions: function() {
            return {
                    renderer: this._renderer,
                    ownerElement: this._rootElement,
                    owner: this._rootElement
                }
        },
        _getCommonOptions: function() {
            var self = this,
                formatOptions = self._getDefaultFormatOptions();
            return {
                    translator: self._area.translator,
                    animationEnabled: self.option('animationEnabled'),
                    containerBackgroundColor: self.option('containerBackgroundColor'),
                    defaultTextFormat: formatOptions.format,
                    defaultTextPrecision: formatOptions.precision
                }
        },
        _getDefaultFormatOptions: function() {
            var area = this._area;
            return DX.utils.getAppropriateFormat(area.startValue, area.endValue, this._getApproximateScreenRange())
        },
        _getCommonNeedleSettings: function() {
            var self = this;
            return $extend(true, {}, self._defaultOpts.commonNeedleSettings, self._presetManager.getNeedlePreset(), self.option('commonNeedleSettings'))
        },
        _getCommonMarkerSettings: function() {
            var self = this;
            return $extend(true, {}, self._defaultOpts.commonMarkerSettings, self._presetManager.getMarkerPreset(), self.option('commonMarkerSettings'))
        },
        _getCommonRangeBarSettings: function() {
            var self = this;
            return $extend(true, self._defaultOpts.commonRangeBarSettings, self._presetManager.getRangeBarPreset(), self.option('commonRangeBarSettings'))
        },
        _hide: function() {
            !this._isHidden && (this._isHidden = true) && this._renderer.getRoot().hide()
        },
        _show: function() {
            this._isHidden && delete this._isHidden && this._renderer.getRoot().show()
        },
        _getCanvas: function() {
            var self = this,
                size = self.option('size') || {},
                margin = self.option('margin') || {},
                container = self.rootElement();
            return {
                    width: size.width > 0 ? Number(size.width) : container.width(),
                    height: size.height > 0 ? Number(size.height) : container.height(),
                    marginLeft: margin.left > 0 ? Number(margin.left) : 0,
                    marginTop: margin.top > 0 ? Number(margin.top) : 0,
                    marginRight: margin.right > 0 ? Number(margin.right) : 0,
                    marginBottom: margin.bottom > 0 ? Number(margin.bottom) : 0
                }
        },
        _updateVisibility: function(canvas, container) {
            var self = this;
            if (canvas.width - canvas.marginLeft - canvas.marginRight >= 2 && canvas.height - canvas.marginTop - canvas.marginBottom >= 2 && container.is(':visible')) {
                self._isRendered && self._show();
                return true
            }
            else {
                self._isRendered && self._hide();
                self._incidentOccured('Gauge cannot be rendered since container is too small or not visible');
                return false
            }
        },
        _getArea: function() {
            var self = this,
                scale = self.option('scale') || {},
                area = {};
            area.startValue = isNumber(scale.startValue) ? Number(scale.startValue) : 0;
            area.endValue = isNumber(scale.endValue) ? Number(scale.endValue) : 100;
            area.baseValue = Math.min(area.startValue, area.endValue);
            self._setupArea(area);
            area.translator = factory.createTranslator(area.startCoord, area.endCoord, area.startValue, area.endValue);
            return area
        },
        _renderTitle: function() {
            var self = this,
                titleOptions = self.option('title'),
                subtitleOptions = self.option('subtitle');
            if (!self._title) {
                self._title = factory.createTitle();
                self._title._renderer = self._renderer;
                self._title._owner = self._rootElement
            }
            titleOptions = $extend(true, {}, self._defaultOpts.title, self._presetManager.getTitlePreset(), self._title.processTitleOptions(titleOptions));
            subtitleOptions = $extend(true, {}, self._defaultOpts.subtitle, self._presetManager.getSubtitlePreset(), self._title.processSubtitleOptions(subtitleOptions));
            self._title.render({
                title: titleOptions,
                subtitle: subtitleOptions
            });
            self._title.isVisible() && self._externalElements.push(self._title)
        },
        _renderDeltaIndicator: function() {
            var self = this,
                options = self.option('indicator');
            if (!self._indicator) {
                self._indicator = factory.createIndicator();
                if (self._indicator) {
                    self._indicator._renderer = self._renderer;
                    self._indicator._owner = self._rootElement
                }
            }
            if (self._indicator) {
                options = $extend(true, {}, self._defaultOpts.indicator, self._presetManager.getIndicatorPreset(), options);
                self._indicator.render(options);
                self._indicator.isVisible() && self._externalElements.push(self._indicator)
            }
        },
        _renderTooltip: function() {
            var self = this,
                options = $extend({}, self._defaultOpts.tooltip, self.option('tooltip'));
            if (!self._tooltip) {
                self._tooltip = factory.createTooltip();
                self._tooltip.setup(self)
            }
            self._tooltip.init($extend(true, {}, self._defaultOpts.tooltip, self.option('tooltip')));
            self._tooltip.render()
        },
        _renderDebugInfo: function() {
            var self = this,
                group = self._debugGroup || self._renderer.createGroup({'class': 'debug-info'}).append(),
                rect;
            group.clear();
            rect = self._rootRect;
            self._renderer.createRect(rect.left, rect.top, rect.width(), rect.height(), 0, {
                stroke: '#000000',
                strokeWidth: 1,
                fill: 'none'
            }).append(group);
            rect = self._mainRect;
            self._renderer.createRect(rect.left, rect.top, rect.width(), rect.height(), 0, {
                stroke: '#0000FF',
                strokeWidth: 1,
                fill: 'none'
            }).append(group);
            rect = self._layoutManager.getRect();
            rect && self._renderer.createRect(rect.left, rect.top, rect.width(), rect.height(), 0, {
                stroke: '#FF0000',
                strokeWidth: 1,
                fill: 'none'
            }).append(group);
            rect = self._title && self._title.isVisible() ? self._title.getBoundingRect() : null;
            rect && self._renderer.createRect(rect.left, rect.top, rect.width(), rect.height(), 0, {
                stroke: '#00FF00',
                strokeWidth: 1,
                fill: 'none'
            }).append(group);
            rect = self._indicator && self._indicator.isVisible() ? self._indicator.getBoundingRect() : null;
            rect && self._renderer.createRect(rect.left, rect.top, rect.width(), rect.height(), 0, {
                stroke: '#00FF00',
                strokeWidth: 1,
                fill: 'none'
            }).append(group)
        },
        _renderCore: function() {
            var self = this;
            self._mainElements.length = 0;
            self._externalElements.length = 0;
            self._renderTitle();
            self._renderDeltaIndicator();
            $each(self._externalElements, function(_, item) {
                var layout = self._layoutManager.applyLayout(item.getBoundingRect(), item.getLayoutOptions());
                item.move(layout.dx, layout.dy)
            });
            self._mainRect = self._layoutManager.getRect();
            self._prepareMainElements();
            self._applyMainLayout(self._measureMainElements());
            self._renderMainElements();
            self._renderTooltip()
        },
        _render: function(parameters) {
            var self = this,
                container = self.rootElement(),
                renderer = self._renderer,
                currentCanvas = self._canvas,
                canvas = self._getCanvas(),
                isFirstTime = !self._isRendered,
                rect;
            parameters = parameters || {};
            self._incidentOccured = self._getIncidentOccured();
            if (!self._updateVisibility(canvas, container))
                return;
            if (isFirstTime) {
                self._isRendered = true;
                renderer.recreateCanvas(canvas.width, canvas.height);
                renderer.draw(container[0]);
                self._rootElement = renderer.getRoot();
                self._trackerGroup = renderer.createGroup({'class': 'tracker'}).append(self._rootElement);
                self._creationOptions = self._getCreationOptions()
            }
            if (!isFirstTime && (canvas.width !== currentCanvas.width || canvas.height !== currentCanvas.height))
                renderer.resize(canvas.width, canvas.height);
            self._canvas = canvas;
            self._rootRect = new Rectangle({
                left: canvas.marginLeft,
                top: canvas.marginTop,
                right: canvas.width - canvas.marginRight,
                bottom: canvas.height - canvas.marginBottom
            });
            self._layoutManager.setRect(self._rootRect);
            self._mainRect = self._rootRect.clone();
            self._area = self._getArea();
            self._commonOptions = self._getCommonOptions();
            self._renderCore();
            parameters.resize || self._updateActiveElements();
            self._tracker.init(self.option('tracker')).activate();
            self.option('debugMode') === true && self._renderDebugInfo()
        },
        _prepareMainElements: function() {
            var self = this;
            self._renderRangeContainer();
            self._renderScale();
            self._renderIndicators('_rangeBars', 'rangeBars', self._getCommonRangeBarSettings(), self._createRangeBar);
            self._renderIndicators('_needles', 'needles', self._getCommonNeedleSettings(), self._createNeedle);
            self._renderIndicators('_markers', 'markers', self._getCommonMarkerSettings(), self._createMarker)
        },
        _updateActiveElements: function() {
            var self = this;
            $each(self._mainElements, function(_, item) {
                item.setCurrentValue && item.setCurrentValue(item._options.value)
            })
        },
        _renderScale: function() {
            var self = this,
                scale = self._scale,
                userOptions = self.option('scale'),
                options;
            if (!scale) {
                scale = self._scale = self._createScale();
                scale.setup({
                    renderer: self._renderer,
                    owner: self._rootElement,
                    incidentOccured: self._incidentOccured
                })
            }
            options = self._combineOptions(self._commonOptions, self._defaultOpts.commonScaleSettings, self._presetManager.getScalePreset(), userOptions, {offset: 0});
            options.majorTick.customTickValues = options.majorTick.customTickValues || [];
            options.minorTick.customTickValues = options.minorTick.customTickValues || [];
            scale.init(options);
            self._mainElements.push(scale)
        },
        _renderRangeContainer: function() {
            var self = this,
                rangeContainer = self._rangeContainer,
                userOptions = self.option('rangeContainer'),
                options;
            if (!rangeContainer) {
                rangeContainer = self._rangeContainer = self._createRangeContainer();
                rangeContainer.setup({
                    renderer: self._renderer,
                    owner: self._rootElement,
                    incidentOccured: self._incidentOccured
                })
            }
            options = self._combineOptions(self._commonOptions, self._defaultOpts.commonRangeSettings, self._presetManager.getRangePreset(), userOptions);
            options.ranges = options.ranges || [];
            rangeContainer.init(options);
            self._mainElements.push(rangeContainer)
        },
        _renderIndicators: function(fieldName, optionName, commonSettings, createHandler) {
            var self = this,
                list = self[fieldName],
                newList = [],
                userOptions = self.option(optionName) || [],
                currentUserOptions,
                i,
                count,
                item,
                newItem;
            for (i = 0, count = list.length; i < count; ++i) {
                item = list[i];
                currentUserOptions = userOptions[i];
                if (currentUserOptions) {
                    newItem = self._renderIndicator(item, commonSettings, currentUserOptions, createHandler);
                    item !== newItem && item.destroy();
                    newItem && newList.push(newItem)
                }
                else
                    item.destroy()
            }
            for (i = count, count = userOptions.length; i < count; ++i) {
                currentUserOptions = userOptions[i];
                if (currentUserOptions) {
                    newItem = self._renderIndicator(undefined, commonSettings, currentUserOptions, createHandler);
                    newItem && newList.push(newItem)
                }
            }
            self[fieldName] = newList
        },
        _renderIndicator: function(indicator, commonSettings, userOptions, createHandler) {
            var self = this,
                options = self._combineOptions(self._commonOptions, commonSettings, userOptions),
                item = indicator;
            self._updateIndicatorOptions(item, options);
            if (options.value !== undefined) {
                if (!item || item._options.type !== options.type) {
                    item = createHandler.call(self, options.type);
                    if (item)
                        item.setup({
                            renderer: self._renderer,
                            owner: self._rootElement,
                            tracker: self._trackerGroup
                        });
                    else
                        self._incidentOccured('Cannot create ' + options.__info + ': type "' + options.type + '" is unknown')
                }
                if (item) {
                    item.init(options);
                    self._mainElements.push(item)
                }
            }
            else
                item = undefined;
            return item
        },
        _updateIndicatorOptions: function(indicator, options) {
            options.baseValue = isFinite(options.translator.translate(options.baseValue)) ? options.baseValue : this._area.baseValue;
            indicator && (options.currentValue = indicator.getCurrentValue());
            isFinite(options.currentValue) || (options.currentValue = options.baseValue);
            options.value = options.translator.adjust(options.value);
            if (options.text && !options.text.format && !options.text.precision) {
                options.text.format = this._commonOptions.defaultTextFormat;
                options.text.precision = this._commonOptions.defaultTextPrecision
            }
        },
        _accessIndicatorValue: function(indicator, value) {
            if (value === undefined)
                return indicator ? indicator.getCurrentValue() : undefined;
            else {
                indicator && indicator.setCurrentValue(value);
                return this
            }
        },
        needleValue: function(name, value) {
            return this._accessIndicatorValue(this._needles[name], value)
        },
        markerValue: function(name, value) {
            return this._accessIndicatorValue(this._markers[name], value)
        },
        rangeBarValue: function(name, value) {
            return this._accessIndicatorValue(this._rangeBars[name], value)
        },
        indicatorValue: function(value) {
            var self = this;
            if (value !== undefined)
                self._indicator && self._indicator.update(value)
        },
        _optionValuesEqual: function(name, oldValue, newValue) {
            if (name === 'rangeContainer')
                oldValue && newValue && newValue.ranges && (oldValue.ranges = null);
            if (name === 'scale') {
                oldValue && oldValue.majorTick && newValue.majorTick && newValue.majorTick.customTickValues && (oldValue.majorTick.customTickValues = null);
                oldValue && oldValue.minorTick && newValue.minorTick && newValue.minorTick.customTickValues && (oldValue.minorTick.customTickValues = null)
            }
            this.callBase.apply(this, arguments)
        }
    });
    DX.viz.gauges.__tests.DEFAULT_GAUGE_OPTIONS = DEFAULT_GAUGE_OPTIONS
})(DevExpress, jQuery);

// Module viz, file circularGauge.js

(function(DX, $, undefined) {
    var factory = DX.viz.gauges.__factory;
    var isNumber = DX.utils.isNumber,
        Number = window.Number,
        normalizeAngle = DX.utils.normalizeAngle,
        getCosAndSin = DX.utils.getCosAndSin,
        max = Math.max,
        min = Math.min,
        round = Math.round,
        slice = Array.prototype.slice,
        $extend = $.extend,
        $each = $.each;
    var PI = Math.PI;
    var DEFAULT_GAUGE_OPTIONS = {
            geometry: {
                startAngle: 225,
                endAngle: 315,
                totalRadius: undefined
            },
            scale: {
                orientation: 'outside',
                label: {indentFromTick: 10}
            },
            rangeContainer: {orientation: 'outside'},
            spindle: {
                visible: true,
                size: 14,
                gapSize: 10,
                color: '#C2C2C2'
            },
            commonNeedleSettings: {
                offset: 20,
                type: 'rectangle',
                indentFromCenter: 0,
                width: 2,
                space: 2,
                secondColor: '#E18E92',
                secondFraction: 0.4
            },
            commonMarkerSettings: {
                offset: -6,
                type: 'textcloud'
            },
            commonRangeBarSettings: {offset: 30}
        };
    function getSides(startAngle, endAngle) {
        var startCosSin = getCosAndSin(startAngle),
            endCosSin = getCosAndSin(endAngle),
            startCos = startCosSin.cos,
            startSin = startCosSin.sin,
            endCos = endCosSin.cos,
            endSin = endCosSin.sin;
        return {
                left: startSin <= 0 && endSin >= 0 || startSin <= 0 && endSin <= 0 && startCos <= endCos || startSin >= 0 && endSin >= 0 && startCos >= endCos ? -1 : min(startCos, endCos, 0),
                right: startSin >= 0 && endSin <= 0 || startSin >= 0 && endSin >= 0 && startCos >= endCos || startSin <= 0 && endSin <= 0 && startCos <= endCos ? 1 : max(startCos, endCos, 0),
                up: startCos <= 0 && endCos >= 0 || startCos <= 0 && endCos <= 0 && startSin >= endSin || startCos >= 0 && endCos >= 0 && startSin <= endSin ? -1 : -max(startSin, endSin, 0),
                down: startCos >= 0 && endCos <= 0 || startCos >= 0 && endCos >= 0 && startSin <= endSin || startCos <= 0 && endCos <= 0 && startSin >= endSin ? 1 : -min(startSin, endSin, 0)
            }
    }
    DX.viz.gauges.CircularGauge = DX.viz.gauges.Gauge.inherit({
        _gaugeType: function() {
            return 'circular'
        },
        _defaultOptions: function() {
            return $extend(true, {}, this.callBase(), DEFAULT_GAUGE_OPTIONS)
        },
        _setupArea: function(area) {
            var self = this,
                geometry = self.option('geometry'),
                startAngle = geometry.startAngle,
                endAngle = geometry.endAngle;
            startAngle = isNumber(startAngle) ? normalizeAngle(startAngle) : self._defaultOpts.geometry.startAngle;
            endAngle = isNumber(endAngle) ? normalizeAngle(endAngle) : self._defaultOpts.geometry.endAngle;
            if (startAngle <= endAngle)
                endAngle -= 360;
            area.x = 0;
            area.y = 0;
            area.radius = 100;
            area.startCoord = startAngle;
            area.endCoord = endAngle;
            area.totalRadius = geometry.totalRadius > 0 ? Number(geometry.totalRadius) : self._defaultOpts.geometry.totalRadius;
            area.sides = getSides(startAngle, endAngle)
        },
        _getCreationOptions: function() {
            var result = this.callBase();
            result.type = 'circular';
            return result
        },
        _getCommonOptions: function() {
            var area = this._area;
            return $extend(true, this.callBase(), {
                    x: area.x,
                    y: area.y,
                    areaRadius: area.radius,
                    type: 'circular'
                })
        },
        _combineOptions: function() {
            var args = [true, {}].concat(slice.apply(arguments)),
                options = $extend.apply($, args);
            options.radius = round(options.areaRadius - Number(options.offset) || options.areaRadius);
            return options
        },
        _measureMainElements: function() {
            var self = this,
                maxRadius = 0,
                minRadius = Infinity,
                maxHorizontalOffset = 0,
                maxVerticalOffset = 0,
                maxInverseHorizontalOffset = 0,
                maxInverseVerticalOffset = 0;
            $each(self._mainElements, function(_, x) {
                var bounds = x.measure();
                bounds.min > 0 && (minRadius = min(minRadius, bounds.min));
                bounds.max > 0 && (maxRadius = max(maxRadius, bounds.max));
                bounds.horizontalOffset > 0 && (maxHorizontalOffset = max(maxHorizontalOffset, bounds.max + bounds.horizontalOffset));
                bounds.verticalOffset > 0 && (maxVerticalOffset = max(maxVerticalOffset, bounds.max + bounds.verticalOffset));
                bounds.inverseHorizontalOffset > 0 && (maxInverseHorizontalOffset = max(maxInverseHorizontalOffset, bounds.inverseHorizontalOffset));
                bounds.inverseVerticalOffset > 0 && (maxInverseVerticalOffset = max(maxInverseVerticalOffset, bounds.inverseVerticalOffset))
            });
            maxHorizontalOffset = max(maxHorizontalOffset - maxRadius, 0);
            maxVerticalOffset = max(maxVerticalOffset - maxRadius, 0);
            return {
                    minRadius: minRadius,
                    maxRadius: maxRadius,
                    horizontalMargin: maxHorizontalOffset,
                    verticalMargin: maxVerticalOffset,
                    inverseHorizontalMargin: maxInverseHorizontalOffset,
                    inverseVerticalMargin: maxInverseVerticalOffset
                }
        },
        _applyMainLayout: function(measurements) {
            var self = this,
                area = self._area,
                sides = area.sides,
                margins = {
                    left: (sides.left < -0.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
                    right: (sides.right > 0.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
                    top: (sides.up < -0.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0,
                    bottom: (sides.down > 0.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0
                },
                rect = self._layoutManager.selectRectByAspectRatio((sides.down - sides.up) / (sides.right - sides.left), margins),
                radius = min(rect.width() / (sides.right - sides.left), rect.height() / (sides.down - sides.up)),
                x,
                y;
            if (radius > area.totalRadius) {
                rect = rect.scale(area.totalRadius / radius);
                radius = area.totalRadius
            }
            radius = radius - measurements.maxRadius + area.radius;
            x = rect.left - rect.width() * sides.left / (sides.right - sides.left);
            y = rect.top - rect.height() * sides.up / (sides.down - sides.up);
            area.x = round(x);
            area.y = round(y);
            area.radius = radius;
            rect.left -= margins.left;
            rect.right += margins.right;
            rect.top -= margins.top;
            rect.bottom += margins.bottom;
            self._layoutManager.setRect(rect)
        },
        _renderMainElements: function() {
            var self = this,
                x = self._area.x,
                y = self._area.y,
                r = self._area.radius;
            $each(self._mainElements, function(_, item) {
                item.init({
                    x: x,
                    y: y,
                    radius: round(r - Number(item._options.offset) || r)
                }).render()
            })
        },
        _createScale: function() {
            return factory.createCircularScale()
        },
        _createRangeContainer: function() {
            return factory.createCircularRangeContainer()
        },
        _createNeedle: function(type) {
            return factory.createCircularNeedle(type)
        },
        _createMarker: function(type) {
            return factory.createCircularMarker(type)
        },
        _createRangeBar: function() {
            return factory.createCircularRangeBar()
        },
        _createSpindle: function() {
            return factory.createCircularSpindle()
        },
        _prepareMainElements: function() {
            this.callBase();
            this._renderSpindle()
        },
        _renderSpindle: function() {
            var self = this;
            if (!self._spindle) {
                self._spindle = self._createSpindle();
                self._spindle.setup({
                    renderer: self._renderer,
                    owner: self._rootElement
                })
            }
            self._spindle.init(self._combineOptions(self._commonOptions, self._defaultOpts.spindle, self._presetManager.getSpindlePreset(), self.option('spindle')));
            self._mainElements.push(self._spindle)
        },
        _getApproximateScreenRange: function() {
            var self = this,
                area = self._area,
                r = min(self._mainRect.width() / (area.sides.right - area.sides.left), self._mainRect.height() / (area.sides.down - area.sides.up));
            r > area.totalRadius && (r = area.totalRadius);
            r = 0.8 * r;
            return -area.translator.getCodomainRange() * r * PI / 180
        }
    });
    DX.viz.gauges.__tests.getSides = getSides;
    DX.viz.gauges.__tests.DEFAULT_CIRCULAR_GAUGE_OPTIONS = DEFAULT_GAUGE_OPTIONS
})(DevExpress, jQuery);

// Module viz, file linearGauge.js

(function(DX, $, undefined) {
    var factory = DX.viz.gauges.__factory;
    var max = Math.max,
        min = Math.min,
        round = Math.round,
        slice = Array.prototype.slice,
        $extend = $.extend,
        $each = $.each;
    var DEFAULT_GAUGE_OPTIONS = {
            geometry: {
                orientation: 'horizontal',
                totalSize: undefined
            },
            scale: {
                horizontalOrientation: 'right',
                verticalOrientation: 'bottom',
                label: {indentFromTick: -10}
            },
            rangeContainer: {
                horizontalOrientation: 'right',
                verticalOrientation: 'bottom'
            },
            commonNeedleSettings: {
                offset: 2.5,
                type: 'rhombus',
                length: 15,
                width: 15
            },
            commonMarkerSettings: {
                offset: -1,
                type: 'textcloud',
                horizontalOrientation: 'left',
                verticalOrientation: 'top'
            },
            commonRangeBarSettings: {
                offset: 10,
                horizontalOrientation: 'right',
                verticalOrientation: 'bottom'
            }
        };
    DX.viz.gauges.LinearGauge = DX.viz.gauges.Gauge.inherit({
        _gaugeType: function() {
            return 'linear'
        },
        _defaultOptions: function() {
            return $extend(true, this.callBase(), DEFAULT_GAUGE_OPTIONS)
        },
        _setupArea: function(area) {
            var geometry = this.option('geometry');
            area.vertical = geometry.orientation === 'vertical';
            area.x = 0;
            area.y = 0;
            area.startCoord = -100;
            area.endCoord = 100;
            area.totalSize = geometry.totalSize > 0 ? Number(geometry.totalSize) : undefined
        },
        _getCreationOptions: function() {
            var result = this.callBase();
            result.type = 'linear';
            return result
        },
        _getCommonOptions: function() {
            var area = this._area;
            return $extend(true, this.callBase(), {
                    baseX: area.x,
                    baseY: area.y,
                    orientation: area.vertical ? 'vertical' : 'horizontal'
                })
        },
        _combineOptions: function() {
            var args = [true, {}].concat(slice.apply(arguments)),
                options = $extend.apply($, args);
            options.x = round(options.baseX + Number(options.offset) || options.baseX);
            options.y = round(options.baseY + Number(options.offset) || options.baseY);
            return options
        },
        _measureMainElements: function() {
            var self = this,
                minBound = 1000,
                maxBound = 0,
                indent = 0;
            $each(self._mainElements, function(_, item) {
                var bounds = item.measure();
                maxBound = max(maxBound, bounds.max);
                minBound = min(minBound, bounds.min);
                if (bounds.indent > 0)
                    indent = max(indent, bounds.indent)
            });
            return {
                    minBound: minBound,
                    maxBound: maxBound,
                    indent: indent
                }
        },
        _applyMainLayout: function(measurements) {
            var self = this,
                area = self._area,
                rect,
                offset;
            if (area.vertical) {
                rect = self._layoutManager.selectRectBySizes({
                    width: measurements.maxBound - measurements.minBound,
                    height: area.totalSize
                });
                offset = rect.horizontalMiddle() - (measurements.minBound + measurements.maxBound) / 2;
                area.startCoord = rect.bottom - measurements.indent;
                area.endCoord = rect.top + measurements.indent;
                area.x = round(area.x + offset)
            }
            else {
                rect = self._layoutManager.selectRectBySizes({
                    height: measurements.maxBound - measurements.minBound,
                    width: area.totalSize
                });
                offset = rect.verticalMiddle() - (measurements.minBound + measurements.maxBound) / 2;
                area.startCoord = rect.left + measurements.indent;
                area.endCoord = rect.right - measurements.indent;
                area.y = round(area.y + offset)
            }
            area.translator = factory.createTranslator(area.startCoord, area.endCoord, area.startValue, area.endValue);
            self._layoutManager.setRect(rect)
        },
        _renderMainElements: function() {
            var self = this,
                x = self._area.x,
                y = self._area.y,
                translator = self._area.translator;
            $each(self._mainElements, function(_, item) {
                item.init({
                    x: round(x + Number(item._options.offset) || x),
                    y: round(y + Number(item._options.offset) || y),
                    translator: translator
                }).render()
            })
        },
        _createScale: function() {
            return factory.createLinearScale()
        },
        _createRangeContainer: function() {
            return factory.createLinearRangeContainer()
        },
        _createNeedle: function(type) {
            return factory.createLinearNeedle(type)
        },
        _createMarker: function(type) {
            return factory.createLinearMarker(type)
        },
        _createRangeBar: function() {
            return factory.createLinearRangeBar()
        },
        _getApproximateScreenRange: function() {
            var self = this,
                area = self._area,
                s = area.vertical ? self._mainRect.height() : self._mainRect.width();
            s > area.totalSize && (s = area.totalSize);
            s = s * 0.8;
            return s
        }
    });
    DX.viz.gauges.__tests.DEFAULT_LINEAR_GAUGE_OPTIONS = DEFAULT_GAUGE_OPTIONS
})(DevExpress, jQuery);

// Module viz, file tooltip.js

(function(DX, $, undefined) {
    var formatHelper = DX.formatHelper;
    var Number = window.Number,
        isFunction = DX.utils.isFunction,
        round = Math.round,
        $extend = $.extend;
    var SHADOW_OFFSET = 4;
    var MASKS = {
            up: [-0.5, -1, -1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, 1],
            down: [0.5, 1, 1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, -1],
            left: [-1, 0.5, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1, 1, 0],
            right: [1, -0.5, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, -1, 0]
        };
    DX.viz.gauges.__internals.Tooltip = DX.Class.inherit({
        setup: function(gauge) {
            var self = this;
            DX.utils.debug.assertParam(gauge, '"gauge" parameter');
            self._gauge = gauge;
            self._renderer = gauge._renderer;
            self._options = {};
            return self
        },
        init: function(options) {
            var self = this;
            $extend(true, self._options, options);
            return self
        },
        render: function() {
            var self = this;
            if (self._options.enabled) {
                self._rootElement = self._rootElement || self._renderer.createGroup({'class': 'tooltip'});
                self._rootElement.append(self._gauge._rootElement);
                self._shadow = self._shadow || self._renderer.createArea().append(self._rootElement);
                self._cloud = self._cloud || self._renderer.createArea().append(self._rootElement);
                self._text = self._text || self._renderer.createText().append(self._rootElement);
                self._measureText();
                self._shadow.applySettings({
                    stroke: 'none',
                    strokeWidth: 0,
                    fill: '#000000',
                    opacity: 0.1
                });
                self._cloud.applySettings({
                    stroke: 'none',
                    strokeWidth: 0
                });
                self._rootElement.applySettings({visibility: 'hidden'});
                self._visible = false
            }
            else if (self._rootElement) {
                self._rootElement.remove();
                delete self._rootElement;
                delete self._shadow;
                delete self._cloud;
                delete self._text
            }
            return self
        },
        _formatValue: function(value) {
            var options = this._options,
                text = formatHelper.format(value, options.format, options.precision),
                obj;
            if (isFunction(options.customizeText)) {
                obj = {
                    value: value,
                    valueText: text
                };
                return options.customizeText.call(obj, obj)
            }
            return text
        },
        _measureText: function() {
            var self = this,
                bbox = self._text.applySettings({
                    text: '0',
                    x: 0,
                    y: 0,
                    align: 'center',
                    font: self._options.font
                }).getBBox();
            self._textHeight = bbox.height;
            self._textUnitWidth = bbox.width;
            self._textVerticalOffset = -bbox.y - bbox.height / 2
        },
        _selectMask: function(x, y, width, height, arrowLength) {
            var rect = this._gauge._rootRect,
                mask;
            if (x + width / 2 > rect.right)
                mask = MASKS.left;
            else if (x - width / 2 < rect.left)
                mask = MASKS.right;
            else if (y - arrowLength - height < rect.top)
                mask = MASKS.down;
            else
                mask = MASKS.up;
            return mask
        },
        _getSettings: function(x, y, textWidth, textHeight, offset) {
            var options = this._options,
                cloudWidth = textWidth + 2 * Number(options.horizontalPadding),
                cloudHeight = textHeight + 2 * Number(options.verticalPadding),
                arrowLength = Number(options.arrowLength),
                mask = this._selectMask(x, y, cloudWidth, cloudHeight, arrowLength),
                i,
                cloudPoints,
                shadowPoints,
                cx,
                cy;
            cloudPoints = [cx = round(x - mask[12] * offset), cy = round(y - mask[13] * offset), cx += round(mask[0] * arrowLength), cy += round(mask[1] * arrowLength), cx += round(mask[2] * (cloudWidth - arrowLength) / 2), cy += round(mask[3] * (cloudHeight - arrowLength) / 2), cx += round(mask[4] * cloudWidth), cy += round(mask[5] * cloudHeight), cx += round(mask[6] * cloudWidth), cy += round(mask[7] * cloudHeight), cx += round(mask[8] * cloudWidth), cy += round(mask[9] * cloudHeight), cx += round(mask[10] * (cloudWidth - arrowLength) / 2), cy += round(mask[11] * (cloudHeight - arrowLength) / 2)];
            shadowPoints = cloudPoints.slice(0);
            cx = round(mask[12] * SHADOW_OFFSET);
            cy = round(mask[13] * SHADOW_OFFSET);
            for (i = 0; i < 14; i += 2) {
                shadowPoints[i] += cx;
                shadowPoints[i + 1] += cy
            }
            cx = round(x - mask[12] * (arrowLength + cloudWidth / 2 + offset));
            cy = round(y - mask[13] * (arrowLength + cloudHeight / 2 + offset)) - 2;
            return {
                    x: cx,
                    y: cy,
                    cloudPoints: cloudPoints,
                    shadowPoints: shadowPoints
                }
        },
        show: function(parameters) {
            parameters = parameters || {};
            var self = this,
                text = self._formatValue(parameters.value),
                settings = self._getSettings(parameters.x, parameters.y, self._textUnitWidth * text.length, self._textHeight, parameters.offset || 0);
            self._shadow.applySettings({points: settings.shadowPoints});
            self._cloud.applySettings({
                points: settings.cloudPoints,
                fill: parameters.color
            });
            self._text.applySettings({
                text: text,
                x: settings.x,
                y: settings.y + self._textVerticalOffset,
                align: 'center'
            });
            !self._visible && self._rootElement.applySettings({visibility: 'visible'}) && (self._visible = true);
            return self
        },
        hide: function() {
            var self = this;
            self._visible && self._rootElement.applySettings({visibility: 'hidden'}) && (self._visible = false);
            return self
        },
        enabled: function() {
            return !!this._rootElement
        }
    })
})(DevExpress, jQuery);

// Module viz, file tracker.js

(function(DX, $, undefined) {
    var setTimeout = window.setTimeout,
        clearTimeout = window.clearTimeout,
        Number = window.Number,
        $extend = $.extend,
        $each = $.each;
    function handleMouseOver(event) {
        var tracker = event.data.tracker;
        if (tracker._context !== null)
            tracker._processLeave();
        tracker._context = event.data.context;
        tracker._processEnter()
    }
    function handleMouseOut(event) {
        var tracker = event.data.tracker;
        if (tracker._context !== null) {
            tracker._processLeave();
            tracker._context = null
        }
    }
    var events = {
            mouseover: handleMouseOver,
            mouseout: handleMouseOut
        };
    DX.viz.gauges.__internals.Tracker = DX.Class.inherit({
        setup: function(gauge) {
            var self = this;
            DX.utils.debug.assertParam(gauge, '"gauge" parameter');
            self._gauge = gauge;
            self._listeners = [];
            self._context = null;
            self._options = {};
            return self
        },
        init: function(options) {
            $extend(true, this._options, options);
            return this
        },
        activate: function() {
            var self = this;
            self._detachListeners();
            if (self._gauge._tooltip.enabled())
                self._attachListeners();
            self._gauge._trackerGroup.toForeground();
            self._tooltipDelay = self._options.tooltipDelay >= 0 ? Number(self._options.tooltipDelay) : 0;
            return self
        },
        _attachListeners: function() {
            var self = this;
            $each(self._gauge._needles, function(_, item) {
                var element;
                if (item.getTrackingElement) {
                    element = item.getTrackingElement();
                    self._listeners.push(element);
                    element.on(events, {
                        tracker: self,
                        context: {
                            element: element,
                            tag: 'needle',
                            target: item
                        }
                    })
                }
            });
            $each(self._gauge._markers, function(_, item) {
                var element;
                if (item.getTrackingElement) {
                    element = item.getTrackingElement();
                    self._listeners.push(element);
                    element.on(events, {
                        tracker: self,
                        context: {
                            element: element,
                            tag: 'marker',
                            target: item
                        }
                    })
                }
            })
        },
        _detachListeners: function() {
            var self = this;
            $each(self._listeners, function(_, item) {
                item.off()
            });
            self._listeners.length = 0
        },
        _processEnter: function(context) {
            var self = this;
            self._timeout = setTimeout(function() {
                delete self._timeout;
                self._showTooltip()
            }, self._tooltipDelay)
        },
        _processLeave: function() {
            var self = this;
            self._timeout && clearTimeout(self._timeout) && delete self._timeout;
            self._hideTooltip()
        },
        _showTooltip: function() {
            var self = this;
            self._gauge._tooltip.show(self._context.target.getTooltipParameters())
        },
        _hideTooltip: function() {
            var self = this;
            self._gauge._tooltip.hide()
        }
    })
})(DevExpress, jQuery);

// Module viz, file namespaces.js

(function(DevExpress) {
    DevExpress.viz.rangeSelector = {utils: {}}
})(DevExpress);

// Module viz, file baseVisualElement.js

(function(DX) {
    DevExpress.viz.rangeSelector.BaseVisualElement = DX.Class.inherit({
        ctor: function(renderer) {
            this._renderer = renderer;
            this._isDrawn = false
        },
        applyOptions: function(options) {
            this._options = options || {};
            this._applyOptions(this._options)
        },
        _applyOptions: function(options){},
        redraw: function(group) {
            var self = this;
            if (!self._isDrawn) {
                self._isDrawn = !(self._draw(group || self._group) === false);
                if (group)
                    self._group = group
            }
            else
                self._update(group || self._group)
        },
        isDrawn: function() {
            return !!this._isDrawn
        },
        isInitialized: function() {
            return !!this._options
        },
        _draw: function(group){},
        _update: function(group) {
            group.clear();
            this._draw(group)
        }
    })
})(DevExpress);

// Module viz, file rangeSelector.js

(function($, DX, undefined) {
    var rangeSelector = DX.viz.rangeSelector,
        core = DX.viz.core,
        utils = DX.utils,
        rangeSelectorUtils = rangeSelector.utils,
        ParseUtils = DX.viz.core.ParseUtils,
        formatHelper = DX.formatHelper;
    var REDRAW_DELAY = 100;
    rangeSelector.consts = {
        fontHeightRatio: 0.55,
        emptySliderMarkerText: '. . .'
    };
    rangeSelector.formatValue = function(value, formatOptions) {
        var formatObject = {
                value: value,
                valueText: formatHelper.format(value, formatOptions.format, formatOptions.precision)
            };
        return String(formatOptions.customizeText ? formatOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText)
    };
    rangeSelector.RangeSelector = DX.ui.Component.inherit(function() {
        var SCALE_TEXT_SPACING = 5;
        var defaultRangeSelectorOptions = {
                size: undefined,
                margin: {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0
                },
                scale: {
                    showCustomBoundaryTicks: true,
                    showMinorTicks: true,
                    startValue: undefined,
                    endValue: undefined,
                    minorTickCount: undefined,
                    minorTickInterval: undefined,
                    majorTickInterval: undefined,
                    useTicksAutoArrangement: true,
                    setTicksAtUnitBeginning: true,
                    minRange: undefined,
                    maxRange: undefined,
                    placeholderHeight: undefined,
                    valueType: undefined,
                    label: {
                        visible: true,
                        format: undefined,
                        precision: undefined,
                        customizeText: undefined
                    },
                    marker: {
                        visible: true,
                        label: {
                            format: undefined,
                            precision: undefined,
                            customizeText: undefined
                        }
                    }
                },
                selectedRange: undefined,
                sliderMarker: {
                    visible: true,
                    format: undefined,
                    precision: undefined,
                    customizeText: undefined,
                    placeholderSize: undefined
                },
                behavior: {
                    snapToTicks: true,
                    animationEnabled: true,
                    moveSelectedRangeByClick: true,
                    manualRangeSelectionEnabled: true,
                    allowSlidersSwap: true,
                    callSelectedRangeChanged: "onMovingComplete"
                },
                background: {
                    color: "#C0BAE1",
                    visible: true,
                    image: {
                        url: undefined,
                        location: 'full'
                    }
                },
                chart: {
                    commonSeriesSettings: {
                        type: 'area',
                        label: {visible: false},
                        hoverMode: 'none'
                    },
                    equalBarWidth: true,
                    topIndent: 0.1,
                    bottomIndent: 0,
                    valueAxis: {
                        min: undefined,
                        max: undefined,
                        inverted: false
                    },
                    series: undefined
                },
                dataSource: undefined,
                dataSourceField: 'arg',
                redrawOnResize: true,
                theme: undefined,
                selectedRangeChanged: null,
                incidentOccured: $.noop
            };
        var calculateMarkerSize = function(renderer, value, sliderMarkerOptions) {
                var formatedText = value === undefined ? rangeSelector.consts.emptySliderMarkerText : rangeSelector.formatValue(value, sliderMarkerOptions);
                var textBBox = rangeSelectorUtils.getTextBBox(renderer, formatedText, sliderMarkerOptions.font);
                return {
                        width: Math.ceil(textBBox.width) + 2 * sliderMarkerOptions.padding,
                        height: Math.ceil(textBBox.height * rangeSelector.consts.fontHeightRatio) + 2 * sliderMarkerOptions.padding + sliderMarkerOptions.pointerSize
                    }
            };
        var calculateScaleLabelHalfWidth = function(renderer, value, scaleOptions) {
                var formatedText,
                    textBBox;
                formatedText = rangeSelector.formatValue(value, scaleOptions.label),
                textBBox = rangeSelectorUtils.getTextBBox(renderer, formatedText, scaleOptions.label.font);
                return Math.ceil(textBBox.width / 2)
            };
        var calculateRangeContainerCanvas = function(size, margin, sliderMarkerSpacing) {
                var canvas = {
                        left: margin.left + sliderMarkerSpacing.left,
                        top: margin.top + sliderMarkerSpacing.top,
                        width: size.width - margin.left - margin.right - sliderMarkerSpacing.left - sliderMarkerSpacing.right,
                        height: size.height - margin.top - margin.bottom - sliderMarkerSpacing.top - sliderMarkerSpacing.bottom
                    };
                if (canvas.width <= 0)
                    canvas.width = 1;
                return canvas
            };
        var parseSliderMarkersPlaceholderSize = function(placeholderSize) {
                var placeholderWidthLeft,
                    placeholderWidthRight,
                    placeholderHeight;
                if (utils.isNumber(placeholderSize))
                    placeholderWidthLeft = placeholderWidthRight = placeholderHeight = placeholderSize;
                else if (placeholderSize) {
                    if (utils.isNumber(placeholderSize.height))
                        placeholderHeight = placeholderSize.height;
                    if (utils.isNumber(placeholderSize.width))
                        placeholderWidthLeft = placeholderWidthRight = placeholderSize.width;
                    else if (placeholderSize.width) {
                        if (utils.isNumber(placeholderSize.width.left))
                            placeholderWidthLeft = placeholderSize.width.left;
                        if (utils.isNumber(placeholderSize.width.right))
                            placeholderWidthRight = placeholderSize.width.right
                    }
                }
                return {
                        widthLeft: placeholderWidthLeft,
                        widthRight: placeholderWidthRight,
                        height: placeholderHeight
                    }
            };
        var calculateSliderMarkersSpacing = function(renderer, size, scale, sliderMarkerOptions) {
                var leftMarkerSize,
                    leftScaleLabelWidth,
                    rightScaleLabelWidth,
                    rightMarkerSize,
                    canvas,
                    placeholderWidthLeft = 0,
                    placeholderWidthRight = 0,
                    placeholderHeight = 0,
                    parsedPlaceholderSize;
                parsedPlaceholderSize = parseSliderMarkersPlaceholderSize(sliderMarkerOptions.placeholderSize);
                placeholderWidthLeft = parsedPlaceholderSize.widthLeft || 0;
                placeholderWidthRight = parsedPlaceholderSize.widthRight || 0;
                placeholderHeight = parsedPlaceholderSize.height || 0;
                if (sliderMarkerOptions.visible) {
                    leftMarkerSize = calculateMarkerSize(renderer, scale.startValue, sliderMarkerOptions);
                    if (!placeholderWidthLeft)
                        placeholderWidthLeft = leftMarkerSize.width;
                    rightMarkerSize = calculateMarkerSize(renderer, scale.endValue, sliderMarkerOptions);
                    if (!placeholderWidthRight)
                        placeholderWidthRight = rightMarkerSize.width;
                    if (!placeholderHeight)
                        placeholderHeight = Math.max(leftMarkerSize.height, rightMarkerSize.height)
                }
                leftScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, scale.startValue, scale);
                rightScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, scale.endValue, scale);
                placeholderWidthLeft = Math.max(placeholderWidthLeft, leftScaleLabelWidth);
                placeholderWidthRight = Math.max(placeholderWidthRight, rightScaleLabelWidth);
                return {
                        left: placeholderWidthLeft,
                        right: placeholderWidthRight,
                        top: placeholderHeight,
                        bottom: 0
                    }
            };
        var clearContainer = function(container) {
                if (container)
                    container.empty()
            };
        var getContainer = function(self) {
                return self.rootElement()
            };
        var createRangeContainer = function(rangeContainerOptions) {
                return rangeSelector.rangeSelectorFactory.createRangeContainer(rangeContainerOptions)
            };
        var createTranslator = function(range, canvas) {
                return rangeSelector.rangeSelectorFactory.createTranslator(range, canvas)
            };
        var createTranslatorCanvas = function(sizeOptions, rangeContainerCanvas, scaleLabelsAreaHeight) {
                return {
                        left: rangeContainerCanvas.left,
                        top: rangeContainerCanvas.top,
                        right: sizeOptions.width - rangeContainerCanvas.width - rangeContainerCanvas.left,
                        bottom: sizeOptions.height - rangeContainerCanvas.height - rangeContainerCanvas.top + scaleLabelsAreaHeight,
                        width: sizeOptions.width,
                        height: sizeOptions.height
                    }
            };
        var createRenderer = function(self) {
                var renderer = self.option('renderer');
                if (renderer)
                    return renderer;
                renderer = rangeSelector.rangeSelectorFactory.createRenderer();
                return renderer
            };
        var createThemeManager = function(theme) {
                return rangeSelector.rangeSelectorFactory.createThemeManager(theme)
            };
        var calculateValueType = function(firstValue, secondValue) {
                var types = [$.type(firstValue), $.type(secondValue)];
                $.inArray();
                return $.inArray('date', types) != -1 ? 'datetime' : $.inArray('number', types) != -1 ? 'numeric' : ''
            };
        var createSeriesDataSource = function(self) {
                var seriesDataSource,
                    dataSource = self._dataSource && self._dataSource.items(),
                    scaleOptions = self.option('scale'),
                    valueType = scaleOptions.valueType;
                if (!valueType)
                    valueType = calculateValueType(scaleOptions.startValue, scaleOptions.endValue);
                if (dataSource || self.option('chart').series)
                    seriesDataSource = new rangeSelector.SeriesDataSource({
                        renderer: self.renderer,
                        dataSource: dataSource,
                        valueType: (valueType || '').toLowerCase(),
                        chart: self.option('chart'),
                        dataSourceField: self.option('dataSourceField'),
                        backgroundColor: self._userBackgroundColor,
                        incidentOccured: self.option('incidentOccured')
                    });
                return seriesDataSource
            };
        var calculateTranslatorRange = function(self, seriesDataSource, scaleOptions) {
                var translatorRange,
                    minValue,
                    maxValue,
                    inverted = false;
                if (utils.isDefined(scaleOptions.startValue) && utils.isDefined(scaleOptions.endValue)) {
                    inverted = scaleOptions.inverted = scaleOptions.startValue > scaleOptions.endValue;
                    minValue = inverted ? scaleOptions.endValue : scaleOptions.startValue;
                    maxValue = inverted ? scaleOptions.startValue : scaleOptions.endValue
                }
                else if (utils.isDefined(scaleOptions.startValue) || utils.isDefined(scaleOptions.endValue)) {
                    minValue = scaleOptions.startValue;
                    maxValue = scaleOptions.endValue
                }
                translatorRange = seriesDataSource ? seriesDataSource.getBoundRange() : new DX.viz.charts.Range;
                if (minValue !== maxValue) {
                    translatorRange.invertX = inverted;
                    translatorRange.getBoundRange({
                        minX: minValue,
                        maxX: maxValue,
                        minVisibleX: minValue,
                        maxVisibleX: maxValue
                    })
                }
                if (!translatorRange.isDefinedX())
                    translatorRange.setStubDataX(scaleOptions.valueType);
                return translatorRange
            };
        var calculateScaleAreaHeight = function(renderer, scaleOptions, visibleMarkers) {
                var textBBox,
                    visibleLabels = scaleOptions.label.visible;
                if (scaleOptions.placeholderHeight)
                    return scaleOptions.placeholderHeight;
                else {
                    textBBox = rangeSelectorUtils.getTextBBox(renderer, '0', scaleOptions.label.font);
                    return (visibleLabels ? scaleOptions.label.topIndent + textBBox.height : 0) + (visibleMarkers ? scaleOptions.marker.topIndent + scaleOptions.marker.separatorHeight : 0)
                }
            };
        var getTicksInfo = function(self, scaleOptions, translator, screenDelta) {
                var isEmpty = scaleOptions.isEmpty,
                    tickProvider = rangeSelector.rangeSelectorFactory.getTickProvider(),
                    minorTicksOptions,
                    majorTicksOptions,
                    startValue,
                    endValue,
                    businessRange = translator.getBusinessRange();
                minorTicksOptions = {
                    tickInterval: isEmpty ? 0 : self.option('scale').minorTickInterval,
                    showCustomBoundaryTicks: scaleOptions.showCustomBoundaryTicks,
                    minorTickCount: scaleOptions.minorTickCount
                };
                majorTicksOptions = {
                    textOptions: {
                        align: 'center',
                        font: scaleOptions.label.font
                    },
                    renderer: self.renderer,
                    getText: function(value) {
                        return rangeSelector.formatValue(value, scaleOptions.label)
                    },
                    translator: translator,
                    isStartTickGenerated: !utils.isDefined(self.option('scale').majorTickInterval),
                    tickInterval: scaleOptions.majorTickInterval,
                    textSpacing: SCALE_TEXT_SPACING,
                    setTicksAtUnitBeginning: scaleOptions.setTicksAtUnitBeginning,
                    useTicksAutoArrangement: scaleOptions.useTicksAutoArrangement,
                    hideLabels: isEmpty
                };
                startValue = isEmpty ? businessRange.minX : scaleOptions.startValue;
                endValue = isEmpty ? businessRange.maxX : scaleOptions.endValue;
                return tickProvider.getFullTicks(startValue, endValue, screenDelta, majorTicksOptions, minorTicksOptions)
            };
        var updateTickIntervals = function(scaleOptions, screenDelta, incidentOccured) {
                var tickProvider = rangeSelector.rangeSelectorFactory.getTickProvider(),
                    tickIntervals = tickProvider.getTickIntervals(scaleOptions.startValue, scaleOptions.endValue, screenDelta, {
                        tickInterval: scaleOptions.majorTickInterval,
                        incidentOccured: incidentOccured
                    }, {
                        tickInterval: scaleOptions.minorTickInterval,
                        incidentOccured: incidentOccured
                    });
                scaleOptions.minorTickInterval = tickIntervals.minorTickInterval;
                scaleOptions.majorTickInterval = tickIntervals.majorTickInterval
            };
        var updateScaleOptions = function(self, seriesDataSource, translatorRange, screenDelta, scaleOptions) {
                var minVisibleX = utils.isDefined(translatorRange.minVisibleX) ? translatorRange.minVisibleX : translatorRange.minX,
                    maxVisibleX = utils.isDefined(translatorRange.maxVisibleX) ? translatorRange.maxVisibleX : translatorRange.maxX;
                if (seriesDataSource && !seriesDataSource.isEmpty()) {
                    scaleOptions.startValue = scaleOptions.inverted ? maxVisibleX : minVisibleX;
                    scaleOptions.endValue = scaleOptions.inverted ? minVisibleX : maxVisibleX
                }
                scaleOptions.isEmpty = !utils.isDefined(scaleOptions.startValue) || !utils.isDefined(scaleOptions.endValue) || scaleOptions.startValue === scaleOptions.endValue || scaleOptions.valueType === 'string';
                if (scaleOptions.isEmpty)
                    scaleOptions.startValue = scaleOptions.endValue = undefined;
                else {
                    updateTickIntervals(scaleOptions, screenDelta, self.option('incidentOccured'));
                    if (scaleOptions.valueType === 'datetime' && !utils.isDefined(scaleOptions.label.format))
                        if (!scaleOptions.marker.visible)
                            scaleOptions.label.format = formatHelper.getDateFormatByTickInterval(scaleOptions.startValue, scaleOptions.endValue, scaleOptions.majorTickInterval);
                        else
                            scaleOptions.label.format = utils.getDateUnitInterval(scaleOptions.majorTickInterval)
                }
            };
        var prepareSliderMarkersOptions = function(self, scaleOptions, screenDelta) {
                var sliderMarkerOptions = $.extend(true, {}, self.option('sliderMarker')),
                    businessInterval;
                if (!sliderMarkerOptions.format) {
                    if (!self.option('behavior').snapToTicks && utils.isNumber(scaleOptions.startValue)) {
                        businessInterval = Math.abs(scaleOptions.endValue - scaleOptions.startValue);
                        sliderMarkerOptions.format = 'fixedPoint';
                        sliderMarkerOptions.precision = utils.getSignificantDigitPosition(businessInterval / screenDelta)
                    }
                    if (scaleOptions.valueType === 'datetime')
                        if (!scaleOptions.marker.visible)
                            sliderMarkerOptions.format = formatHelper.getDateFormatByTickInterval(scaleOptions.startValue, scaleOptions.endValue, scaleOptions.minorTickInterval !== 0 ? scaleOptions.minorTickInterval : scaleOptions.majorTickInterval);
                        else
                            sliderMarkerOptions.format = utils.getDateUnitInterval(utils.isDefined(scaleOptions.minorTickInterval) && scaleOptions.minorTickInterval !== 0 ? scaleOptions.minorTickInterval : scaleOptions.majorTickInterval)
                }
                return sliderMarkerOptions
            };
        var showScaleMarkers = function(scaleOptions) {
                return scaleOptions.valueType == 'datetime' && scaleOptions.marker.visible
            };
        var updateTranslatorRangeInterval = function(translatorRange, scaleOptions) {
                var intervalX = scaleOptions.minorTickInterval || scaleOptions.majorTickInterval;
                translatorRange = translatorRange.getBoundRange({intervalX: intervalX})
            };
        var prepareScaleOptions = function(self, seriesDataSource) {
                var scaleOptions = $.extend(true, {}, self.option('scale')),
                    incidentOccured = self.option('incidentOccured'),
                    parsedValue = 0,
                    parseUtils = new ParseUtils({incidentOccured: incidentOccured}),
                    valueType = parseUtils.correctValueType((scaleOptions.valueType || '').toLowerCase());
                if (seriesDataSource)
                    valueType = seriesDataSource.getCalculatedValueType() || valueType;
                if (!valueType)
                    valueType = calculateValueType(scaleOptions.startValue, scaleOptions.endValue) || 'string';
                scaleOptions.valueType = valueType;
                if (scaleOptions.valueType === 'string') {
                    incidentOccured('The type of the argument values specified in the data source is unsupported.');
                    return scaleOptions
                }
                var parser = parseUtils.getParser(valueType, 'scale');
                if (utils.isDefined(scaleOptions.startValue)) {
                    parsedValue = parser(scaleOptions.startValue);
                    if (utils.isDefined(parsedValue))
                        scaleOptions.startValue = parsedValue;
                    else {
                        scaleOptions.startValue = undefined;
                        incidentOccured.call(null, "Cannot parse the value specified as the startValue property of the scale configuration object.")
                    }
                }
                if (utils.isDefined(scaleOptions.endValue)) {
                    parsedValue = parser(scaleOptions.endValue);
                    if (utils.isDefined(parsedValue))
                        scaleOptions.endValue = parsedValue;
                    else {
                        scaleOptions.endValue = undefined;
                        incidentOccured.call(null, "Cannot parse the value specified as the endValue property of the scale configuration object.")
                    }
                }
                scaleOptions.parser = parser;
                return scaleOptions
            };
        var applyOptions = function(self, isResizing) {
                var rangeContainerCanvas,
                    seriesDataSource,
                    translatorRange,
                    scaleLabelsAreaHeight,
                    sizeOptions,
                    sliderMarkerSpacing,
                    scaleOptions,
                    sliderMarkerOptions,
                    isEmpty;
                self._isUpdating = true;
                sizeOptions = calculateSize(self);
                self._actualSize = sizeOptions;
                if (!sizeOptions.width || !sizeOptions.height) {
                    self.stopRedraw = true;
                    self.option('incidentOccured')('RangeSelector can not be drawn as container is not visible');
                    return
                }
                else
                    self.stopRedraw = false;
                updateRendererSize(self, sizeOptions);
                seriesDataSource = createSeriesDataSource(self);
                scaleOptions = prepareScaleOptions(self, seriesDataSource);
                translatorRange = calculateTranslatorRange(self, seriesDataSource, scaleOptions);
                updateScaleOptions(self, seriesDataSource, translatorRange, sizeOptions.width, scaleOptions);
                updateTranslatorRangeInterval(translatorRange, scaleOptions);
                sliderMarkerOptions = prepareSliderMarkersOptions(self, scaleOptions, sizeOptions.width);
                if (!isResizing)
                    initSelection(self, scaleOptions);
                sliderMarkerSpacing = calculateSliderMarkersSpacing(self.renderer, sizeOptions, scaleOptions, sliderMarkerOptions);
                rangeContainerCanvas = calculateRangeContainerCanvas(sizeOptions, self.option('margin'), sliderMarkerSpacing);
                scaleLabelsAreaHeight = calculateScaleAreaHeight(self.renderer, scaleOptions, showScaleMarkers(scaleOptions));
                self.translator = createTranslator(translatorRange, createTranslatorCanvas(sizeOptions, rangeContainerCanvas, scaleLabelsAreaHeight));
                scaleOptions.ticksInfo = getTicksInfo(self, scaleOptions, self.translator, rangeContainerCanvas.width);
                self._testTicksInfo = scaleOptions.ticksInfo;
                if (seriesDataSource)
                    seriesDataSource.adjustSeriesDimensions(self.translator);
                self.rangeContainer.applyOptions({
                    canvas: rangeContainerCanvas,
                    scaleLabelsAreaHeight: scaleLabelsAreaHeight,
                    sliderMarkerSpacing: sliderMarkerSpacing,
                    translator: self.translator,
                    selectedRange: self.option('selectedRange'),
                    scale: scaleOptions,
                    behavior: self.option('behavior'),
                    background: self.option('background'),
                    chart: self.option('chart'),
                    seriesDataSource: seriesDataSource,
                    sliderMarker: sliderMarkerOptions,
                    sliderHandles: self.option('sliderHandles'),
                    shutter: self.option('shutter'),
                    selectedRangeChanged: createSelectedRangeChangedFunction(self),
                    setSelectedRange: function(selectedRange) {
                        self.setSelectedRange(selectedRange)
                    }
                });
                self._isUpdating = false
            };
        var createSelectedRangeChangedFunction = function(self) {
                return function(e) {
                        var selectedRangeChanged = self.option('selectedRangeChanged');
                        self.option('selectedRange', e);
                        if (selectedRangeChanged)
                            selectedRangeChanged(e)
                    }
            };
        var calculateSize = function(self) {
                var $container = self.container,
                    size = self.option('size') || {},
                    result = {
                        width: size.width,
                        height: size.height
                    };
                if ($container) {
                    if (!result.width)
                        result.width = $container.width();
                    if (!result.height)
                        result.height = $container.height()
                }
                return result
            };
        var updateRendererSize = function(self, size) {
                var renderer = self.renderer;
                if (renderer.isInitialized())
                    renderer.getRoot().applySettings({
                        width: size.width,
                        height: size.height
                    });
                else {
                    renderer.recreateCanvas(size.width, size.height);
                    renderer.draw(self.container[0])
                }
            };
        var prepareChartThemeOptions = function(self, options) {
                var chartTheme;
                if (!self.option('chart').theme && options && options.theme) {
                    chartTheme = options.theme;
                    if (chartTheme) {
                        if (typeof chartTheme === 'object') {
                            chartTheme = chartTheme.chart || {};
                            chartTheme.name = options.theme.name
                        }
                        self.option('chart').theme = chartTheme
                    }
                }
            };
        var initSelection = function(self, scaleOptions) {
                var selectedRangeOptions = self.option('selectedRange'),
                    parser = scaleOptions.parser || function() {
                        return null
                    },
                    parseValue = function(value, entity) {
                        var parsedValue,
                            result = scaleOptions[entity];
                        if (utils.isDefined(value))
                            parsedValue = parser(value);
                        if (!utils.isDefined(parsedValue))
                            self.option('incidentOccured').call(null, "Cannot parse the value specified as the " + entity + " property of the selectedRange configuration object.");
                        else
                            result = parsedValue;
                        return result
                    };
                if (!selectedRangeOptions)
                    self.option('selectedRange', {
                        startValue: scaleOptions.startValue,
                        endValue: scaleOptions.endValue
                    });
                else {
                    selectedRangeOptions.startValue = parseValue(selectedRangeOptions.startValue, 'startValue');
                    selectedRangeOptions.endValue = parseValue(selectedRangeOptions.endValue, 'endValue')
                }
            };
        var _isSizeChanged = function(self) {
                var actualSize = self._actualSize,
                    newSize = calculateSize(self);
                return actualSize && (actualSize.width !== newSize.width || actualSize.height !== newSize.height)
            };
        var _resizeHandler = function(self) {
                var jqWindow = $(window),
                    currentDelayTimeout,
                    formatSize = function() {
                        return [jqWindow.width(), jqWindow.height()].join()
                    };
                return function() {
                        var prevSize = formatSize(),
                            currentSize;
                        if (currentDelayTimeout) {
                            clearTimeout(currentDelayTimeout);
                            currentDelayTimeout = 0
                        }
                        currentDelayTimeout = setTimeout(function() {
                            currentSize = formatSize();
                            if (currentSize === prevSize)
                                if (_isSizeChanged(self))
                                    self._render(true)
                        }, REDRAW_DELAY)
                    }
            };
        return {
                isSizeChanged: function() {
                    return _isSizeChanged(this)
                },
                _defaultOptions: function() {
                    return defaultRangeSelectorOptions
                },
                _dataSourceOptions: function() {
                    return {paginate: false}
                },
                _init: function() {
                    var self = this;
                    self.container = getContainer(self);
                    clearContainer(self.container);
                    self.renderer = createRenderer(self);
                    self.rangeContainer = createRangeContainer(self.renderer);
                    if (self.option('redrawOnResize') === true)
                        utils.windowResizeCallbacks.add(_resizeHandler(self));
                    if (!$.isFunction(self.option('incidentOccured'))) {
                        utils.debug.assert(false, 'Function should be passed as "info" callback');
                        self.option('incidentOccured', $.noop)
                    }
                    if (self.option('incidentOccured') === $.noop)
                        self.option('incidentOccured', utils.logger.warn);
                    self._reinitDataSource()
                },
                _reinitDataSource: function() {
                    this._initDataSource();
                    this._loadDataSource()
                },
                _initOptions: function(options) {
                    var self = this,
                        themeManager;
                    options = options || {};
                    themeManager = createThemeManager(options.theme);
                    themeManager.setBackgroundColor(options.containerBackgroundColor);
                    self.option(themeManager.applyRangeSelectorTheme(options));
                    prepareChartThemeOptions(self, options);
                    if (options.background)
                        self._userBackgroundColor = options.background.color
                },
                _render: function(isResizing) {
                    var self = this,
                        currentAnimationEnabled,
                        behaviorOptions;
                    applyOptions(self, isResizing);
                    if (!self.stopRedraw)
                        if (isResizing) {
                            behaviorOptions = self.option('behavior');
                            currentAnimationEnabled = behaviorOptions.animationEnabled;
                            behaviorOptions.animationEnabled = false;
                            self.rangeContainer.redraw();
                            behaviorOptions.animationEnabled = currentAnimationEnabled
                        }
                        else
                            self.rangeContainer.redraw()
                },
                _optionChanged: function(name) {
                    var self = this;
                    if (name === "dataSource") {
                        self._reinitDataSource();
                        self._invalidate()
                    }
                    else if (name === "selectedRange")
                        self.setSelectedRange(self.option('selectedRange'));
                    else if (name === "selectedRangeChanged")
                        self.rangeContainer.slidersContainer.selectedRangeChanged = createSelectedRangeChangedFunction(self);
                    else
                        self._invalidate()
                },
                _handleDataSourceChanged: function() {
                    var self = this;
                    if (self.renderer.isInitialized())
                        self._render()
                },
                getSelectedRange: function() {
                    var self = this;
                    var selectedRange = self.rangeContainer.slidersContainer.getSelectedRange();
                    return {
                            startValue: selectedRange.startValue,
                            endValue: selectedRange.endValue
                        }
                },
                setSelectedRange: function(selectedRange) {
                    var self = this;
                    if (self._isUpdating || !selectedRange)
                        return;
                    var oldSelectedRange = self.rangeContainer.slidersContainer.getSelectedRange();
                    if (oldSelectedRange && oldSelectedRange.startValue === selectedRange.startValue && oldSelectedRange.endValue === selectedRange.endValue)
                        return;
                    self.rangeContainer.slidersContainer.setSelectedRange(selectedRange)
                }
            }
    }()).include(DX.ui.DataHelperMixin)
})(jQuery, DevExpress);

// Module viz, file rangeContainer.js

(function($, DX, undefined) {
    var rangeSelector = DX.viz.rangeSelector;
    rangeSelector.RangeContainer = rangeSelector.BaseVisualElement.inherit(function() {
        var ctor = function(renderer) {
                this.callBase(renderer);
                this.slidersContainer = createSlidersContainer(renderer);
                this.rangeView = createRangeView(renderer);
                this.scale = createScale(renderer)
            };
        var _applyOptions = function(options) {
                var self = this,
                    isEmpty = options.scale.isEmpty,
                    viewCanvas = {
                        left: options.canvas.left,
                        top: options.canvas.top,
                        width: options.canvas.width,
                        height: options.canvas.height >= options.scaleLabelsAreaHeight ? options.canvas.height - options.scaleLabelsAreaHeight : 0
                    };
                self._viewCanvas = viewCanvas;
                self.slidersContainer.applyOptions({
                    canvas: viewCanvas,
                    translator: options.translator,
                    scale: options.scale,
                    selectedRange: options.selectedRange,
                    sliderMarker: options.sliderMarker,
                    sliderHandles: options.sliderHandles,
                    shutter: options.shutter,
                    behavior: options.behavior,
                    selectedRangeChanged: options.selectedRangeChanged,
                    isEmpty: isEmpty
                });
                self.rangeView.applyOptions({
                    canvas: viewCanvas,
                    translator: options.translator,
                    background: options.background,
                    chart: options.chart,
                    seriesDataSource: options.seriesDataSource,
                    behavior: options.behavior,
                    isEmpty: isEmpty
                });
                self.scale.applyOptions({
                    canvas: options.canvas,
                    translator: options.translator,
                    scale: options.scale,
                    hideLabels: isEmpty,
                    scaleLabelsAreaHeight: options.scaleLabelsAreaHeight,
                    setSelectedRange: options.setSelectedRange
                })
            };
        var createSlidersContainer = function(options) {
                return rangeSelector.rangeSelectorFactory.createSlidersContainer(options)
            };
        var createScale = function(options) {
                return rangeSelector.rangeSelectorFactory.createScale(options)
            };
        var createRangeView = function(options) {
                return rangeSelector.rangeSelectorFactory.createRangeView(options)
            };
        var _createClipRectCanvas = function(canvas, sliderMarkerSpacing) {
                return {
                        left: canvas.left - sliderMarkerSpacing.left,
                        top: canvas.top - sliderMarkerSpacing.top,
                        width: canvas.width + sliderMarkerSpacing.right + sliderMarkerSpacing.left,
                        height: canvas.height + sliderMarkerSpacing.bottom + sliderMarkerSpacing.top
                    }
            };
        var _draw = function() {
                var self = this,
                    containerGroup,
                    rangeViewGroup,
                    slidersContainerGroup,
                    scaleGroup,
                    trackersGroup,
                    size = self._options.size,
                    clipRectCanvas = _createClipRectCanvas(self._options.canvas, self._options.sliderMarkerSpacing),
                    viewCanvas = self._viewCanvas;
                self._clipRect = self._renderer.createClipRect(clipRectCanvas.left, clipRectCanvas.top, clipRectCanvas.width, clipRectCanvas.height);
                containerGroup = self._renderer.drawGroup({
                    'class': 'rangeContainer',
                    clipId: self._clipRect.id
                });
                self._viewClipRect = self._renderer.createClipRect(viewCanvas.left, viewCanvas.top, viewCanvas.width, viewCanvas.height);
                rangeViewGroup = self._renderer.createGroup({
                    'class': 'view',
                    clipId: self._viewClipRect.id
                });
                rangeViewGroup.append(containerGroup);
                self.rangeView.redraw(rangeViewGroup);
                slidersContainerGroup = self._renderer.createGroup({'class': 'slidersContainer'});
                slidersContainerGroup.append(containerGroup);
                self.slidersContainer.redraw(slidersContainerGroup);
                scaleGroup = self._renderer.createGroup({'class': 'scale'});
                scaleGroup.append(containerGroup);
                self.scale.redraw(scaleGroup);
                trackersGroup = self._renderer.createGroup({'class': 'trackers'});
                trackersGroup.append(containerGroup);
                self._trackersGroup = trackersGroup;
                self.slidersContainer.appendTrackers(trackersGroup)
            };
        var _update = function() {
                var self = this,
                    clipRectCanvas = _createClipRectCanvas(self._options.canvas, self._options.sliderMarkerSpacing),
                    viewCanvas = self._viewCanvas;
                self._clipRect.applySettings({
                    x: clipRectCanvas.left,
                    y: clipRectCanvas.top,
                    width: clipRectCanvas.width,
                    height: clipRectCanvas.height
                });
                self._viewClipRect.applySettings({
                    x: viewCanvas.left,
                    y: viewCanvas.top,
                    width: viewCanvas.width,
                    height: viewCanvas.height
                });
                self.rangeView.redraw();
                self.slidersContainer.redraw();
                self.slidersContainer.appendTrackers(self._trackersGroup);
                self.scale.redraw()
            };
        var prototypeObject = {
                createSlidersContainer: createSlidersContainer,
                createScale: createScale,
                ctor: ctor,
                _applyOptions: _applyOptions,
                _draw: _draw,
                _update: _update
            };
        return prototypeObject
    }())
})(jQuery, DevExpress);

// Module viz, file scale.js

(function($, DX, undefined) {
    var rangeSelector = DX.viz.rangeSelector,
        formatHelper = DX.formatHelper,
        utils = DX.utils;
    var SCALE_TEXT_SPACING = 5;
    rangeSelector.Scale = rangeSelector.BaseVisualElement.inherit({
        _setupDateTickInterval: function(majorTickInterval) {
            this.dateUnitInterval = utils.getDateUnitInterval(majorTickInterval);
            this._prepareTickIntervalObject(majorTickInterval, this.dateUnitInterval)
        },
        _prepareTickIntervalObject: function(tickInterval, dateUnitInterval) {
            if (utils.isObject(tickInterval) && utils.isString(dateUnitInterval))
                for (var key in tickInterval) {
                    if (key === dateUnitInterval + 's')
                        continue;
                    delete tickInterval[key]
                }
        },
        _prepareDatesDifferences: function(datesDifferences, tickInterval) {
            var deleteDifferent = tickInterval;
            if (deleteDifferent === 'week')
                deleteDifferent = 'day';
            if (deleteDifferent === 'quarter')
                deleteDifferent = 'month';
            if (datesDifferences[deleteDifferent]) {
                datesDifferences[deleteDifferent] = false;
                datesDifferences.count--
            }
        },
        _getMarkerDate: function(date, tickInterval) {
            var markerDate = new Date(date.getTime()),
                month = 0;
            switch (tickInterval) {
                case'quarter':
                    month = formatHelper.getFirstQuarterMonth(date.getMonth());
                case'month':
                    markerDate.setMonth(month);
                case'week':
                case'day':
                    markerDate.setDate(1);
                case'hour':
                    markerDate.setHours(0, 0, 0, 0);
                    break;
                case'millisecond':
                    markerDate.setMilliseconds(0);
                    break;
                case'second':
                    markerDate.setSeconds(0, 0);
                    break;
                case'minute':
                    markerDate.setMinutes(0, 0, 0);
                    break
            }
            return markerDate
        },
        _drawDateMarker: function(date, options) {
            var labelPosX,
                labelPosY,
                dateFormated,
                scaleOptions;
            if (options.x === null)
                return;
            scaleOptions = this._options.scale;
            this._renderer.createLine(options.x, options.y, options.x, options.y + scaleOptions.marker.separatorHeight, this.lineOptions).append(options.group);
            dateFormated = this._getLabel(date, options.label);
            labelPosX = options.x + scaleOptions.tick.width + scaleOptions.marker.textLeftIndent;
            labelPosY = options.y + scaleOptions.marker.textTopIndent + scaleOptions.label.font.size;
            this.textOptions.align = 'left';
            this._renderer.createText(dateFormated, labelPosX, labelPosY, this.textOptions).append(options.group)
        },
        _drawDateMarkers: function(dates, group) {
            var dateMarker,
                i,
                datesDifferences,
                markerDate,
                posX;
            if (this._options.scale.valueType !== 'datetime' || !this.visibleMarkers)
                return;
            var markerDatePositions = [];
            if (dates.length > 1) {
                for (i = 1; i < dates.length; i++) {
                    datesDifferences = utils.getDatesDifferences(dates[i - 1], dates[i]);
                    this._prepareDatesDifferences(datesDifferences, this.dateUnitInterval);
                    if (datesDifferences.count > 0) {
                        markerDate = this._getMarkerDate(dates[i], this.dateUnitInterval);
                        this.markerDates = this.markerDates || [];
                        this.markerDates.push(markerDate);
                        posX = this.translator.translateX(markerDate);
                        if (posX !== null)
                            markerDatePositions.push({
                                date: markerDate,
                                posX: posX
                            });
                        this._drawDateMarker(markerDate, {
                            group: group,
                            y: this._options.canvas.top + this._options.canvas.height - this.markersAreaHeight + this._options.scale.marker.topIndent,
                            x: posX,
                            label: this._getLabelFormatOptions(formatHelper.getDateFormatByDifferences(datesDifferences))
                        })
                    }
                }
                this._initializeMarkersEvents(markerDatePositions, group)
            }
        },
        _getLabelFormatOptions: function(formatString) {
            if (!utils.isDefined(this._options.scale.marker.label.format))
                return $.extend({}, this._options.scale.marker.label, {format: formatString});
            return this._options.scale.marker.label
        },
        _calculateRangeByMarkerPosition: function(posX, markerDatePositions, scaleOptions) {
            var selectedRange = {},
                index,
                position;
            for (index in markerDatePositions) {
                position = markerDatePositions[index];
                if (!scaleOptions.inverted) {
                    if (posX >= position.posX)
                        selectedRange.startValue = position.date;
                    else if (!selectedRange.endValue)
                        selectedRange.endValue = position.date
                }
                else if (posX < position.posX)
                    selectedRange.endValue = position.date;
                else if (!selectedRange.startValue)
                    selectedRange.startValue = position.date
            }
            selectedRange.startValue = selectedRange.startValue || scaleOptions.startValue;
            selectedRange.endValue = selectedRange.endValue || scaleOptions.endValue;
            return selectedRange
        },
        _initializeMarkersEvents: function(markerDatePositions, group) {
            var self = this,
                markersAreaTop = this._options.canvas.top + this._options.canvas.height - this.markersAreaHeight + this._options.scale.marker.topIndent,
                markersTracker,
                svgOffsetLeft,
                index,
                posX,
                selectedRange;
            if (markerDatePositions.length > 0) {
                markersTracker = self._renderer.createRect(self._options.canvas.left, markersAreaTop, self._options.canvas.width, self._options.scale.marker.separatorHeight, 0, {
                    fill: 'grey',
                    stroke: 'grey',
                    opacity: 0.0001
                });
                markersTracker.append(group);
                markersTracker.on(rangeSelector.events.start, function(e) {
                    svgOffsetLeft = rangeSelector.utils.getRootOffsetLeft(self._renderer);
                    posX = rangeSelector.utils.getEventPageX(e) - svgOffsetLeft;
                    selectedRange = self._calculateRangeByMarkerPosition(posX, markerDatePositions, self._options.scale);
                    self._options.setSelectedRange(selectedRange)
                });
                self._markersTracker = markersTracker
            }
        },
        _getLabel: function(value, options) {
            var formatObject = {
                    value: value,
                    valueText: formatHelper.format(value, options.format, options.precision)
                };
            return String(options.customizeText ? options.customizeText.call(formatObject, formatObject) : formatObject.valueText)
        },
        _drawLabel: function(value, group) {
            var textY = this._options.canvas.top + this._options.canvas.height - this.markersAreaHeight,
                textElement = this._renderer.createText(this._getLabel(value, this._options.scale.label), this.translator.translateX(value), textY, this.textOptions);
            textElement.append(group);
            this.textElements = this.textElements || [];
            this.textElements.push(textElement)
        },
        _drawTick: function(value, group) {
            var secondY = this._options.canvas.top + this._options.canvas.height - this.scaleLabelsAreaHeight,
                posX = this.translator.translateX(value),
                tickElement = this._renderer.createLine(posX, this._options.canvas.top, posX, secondY, this.lineOptions).append(group);
            this.tickElements = this.tickElements || [];
            this.tickElements.push(tickElement)
        },
        _redraw: function(group, isOptimize) {
            var self = this,
                scaleOptions = self._options.scale,
                majorTicks = scaleOptions.ticksInfo.majorTicks,
                minorTicks = scaleOptions.ticksInfo.minorTicks,
                customBoundaryTicks = scaleOptions.ticksInfo.customBoundaryTicks,
                hideLabels = self._options.hideLabels || majorTicks.hideLabels || !scaleOptions.label.visible,
                i;
            for (i = 0; i < majorTicks.length; i++) {
                if (!hideLabels)
                    self._drawLabel(majorTicks[i], group);
                self._drawTick(majorTicks[i], group)
            }
            if (scaleOptions.showMinorTicks)
                for (i = 0; i < minorTicks.length; i++)
                    self._drawTick(minorTicks[i], group);
            for (i = 0; i < customBoundaryTicks.length; i++)
                self._drawTick(customBoundaryTicks[i], group);
            self._drawDateMarkers(majorTicks, group)
        },
        _applyOptions: function(options) {
            var scaleOptions = options.scale,
                labelsAreaHeight;
            this.textOptions = {
                align: 'center',
                font: scaleOptions.label.font,
                style: {'-webkit-user-select': 'none'}
            };
            this.lineOptions = {
                strokeWidth: scaleOptions.tick.width,
                stroke: scaleOptions.tick.color,
                strokeOpacity: scaleOptions.tick.opacity
            };
            this._setupDateTickInterval(scaleOptions.ticksInfo.majorTickInterval);
            this.visibleMarkers = scaleOptions.marker.visible === undefined ? true : scaleOptions.marker.visible;
            labelsAreaHeight = scaleOptions.label.visible ? scaleOptions.label.topIndent + scaleOptions.label.font.size : 0;
            this.scaleLabelsAreaHeight = options.scaleLabelsAreaHeight;
            this.markersAreaHeight = this.scaleLabelsAreaHeight - labelsAreaHeight;
            this.translator = options.translator
        },
        _draw: function(group) {
            var baseGroup = this._renderer.createGroup();
            this._redraw(baseGroup, false);
            baseGroup.append(group)
        },
        _update: function(group) {
            var callBase = this.callBase;
            if (this._markersTracker)
                this._markersTracker.off(rangeSelector.events.start, '**');
            this.callBase = callBase;
            this.callBase(group)
        }
    })
})(jQuery, DevExpress);

// Module viz, file rangeFactory.js

(function($, DX, undefined) {
    var rangeSelector = DX.viz.rangeSelector,
        renderers = DX.viz.renderers;
    rangeSelector.rangeSelectorFactory = function() {
        return {
                createRenderer: function(options) {
                    return new renderers.Renderer(options)
                },
                createTranslator: function(range, canvas) {
                    return new DX.viz.core.LinearTranslator(range, canvas)
                },
                getTickProvider: function() {
                    return DX.viz.core.tickProvider
                },
                createRangeContainer: function(rangeContainerOptions) {
                    return new rangeSelector.RangeContainer(rangeContainerOptions)
                },
                createSlidersContainer: function(options) {
                    return new rangeSelector.SlidersContainer(options)
                },
                createScale: function(options) {
                    return new rangeSelector.Scale(options)
                },
                createSliderMarker: function(options) {
                    return new rangeSelector.SliderMarker(options)
                },
                createRangeView: function(options) {
                    return new rangeSelector.RangeView(options)
                },
                createThemeManager: function(options) {
                    return new rangeSelector.ThemeManager(options)
                },
                createSlider: function(renderer, sliderIndex) {
                    return new rangeSelector.Slider(renderer, sliderIndex)
                },
                createSlidersEventsManager: function(renderer, slidersController, processSelectionChanged) {
                    return new rangeSelector.SlidersEventsManager(renderer, slidersController, processSelectionChanged)
                },
                createSlidersController: function(sliders) {
                    return new rangeSelector.SlidersController(sliders)
                }
            }
    }()
})(jQuery, DevExpress);

// Module viz, file slidersContainer.js

(function($, DX, undefined) {
    var rangeSelector = DX.viz.rangeSelector,
        utils = DX.utils;
    var msPointerEnabled = window.navigator.msPointerEnabled;
    var isNumber = DX.utils.isNumber;
    var isDate = DX.utils.isDate;
    var START_VALUE_INDEX = 0,
        END_VALUE_INDEX = 1;
    rangeSelector.SlidersContainer = rangeSelector.BaseVisualElement.inherit(function() {
        var prototypeObject = {
                getController: function() {
                    return this._controller
                },
                _drawAreaTracker: function(group) {
                    var self = this,
                        areaTracker,
                        selectedAreaTracker;
                    areaTracker = self._renderer.createRect(self._options.canvas.left, self._options.canvas.top, self._options.canvas.width, self._options.canvas.height, 0, {
                        fill: 'grey',
                        stroke: 'grey',
                        opacity: 0.0001
                    });
                    areaTracker.append(group);
                    selectedAreaTracker = self._renderer.createRect(self._options.canvas.left, self._options.canvas.top, self._options.canvas.width, self._options.canvas.height, 0, {
                        fill: 'grey',
                        stroke: 'grey',
                        opacity: 0.0001,
                        style: {cursor: 'pointer'}
                    });
                    selectedAreaTracker.append(group);
                    self._controller.setAreaTrackers(areaTracker, selectedAreaTracker)
                },
                _processSelectionChanged: function(moving) {
                    var self = this,
                        selectedRange = self.getSelectedRange();
                    if ((!moving || (self._options.behavior.callSelectedRangeChanged || '').toLowerCase() === "onmoving") && self._options.selectedRangeChanged && (self._lastSelectedRange.startValue !== selectedRange.startValue || self._lastSelectedRange.endValue !== selectedRange.endValue)) {
                        if (typeof self._options.selectedRangeChanged === 'function')
                            self._options.selectedRangeChanged.call(null, selectedRange);
                        if (!moving && selectedRange && (selectedRange.startValue !== self._options.selectedRange.startValue || selectedRange.endValue !== self._options.selectedRange.endValue))
                            self.setSelectedRange(selectedRange);
                        this._updateLastSelectedRange()
                    }
                },
                _updateLastSelectedRange: function() {
                    var self = this;
                    self._lastSelectedRange = {
                        startValue: self._options.selectedRange.startValue,
                        endValue: self._options.selectedRange.endValue
                    }
                },
                _createSlider: function(sliderIndex) {
                    return rangeSelector.rangeSelectorFactory.createSlider(this._renderer, sliderIndex)
                },
                _createSlidersController: function(sliders) {
                    return rangeSelector.rangeSelectorFactory.createSlidersController(sliders)
                },
                _createSlidersEventsManager: function(controller) {
                    var self = this;
                    return rangeSelector.rangeSelectorFactory.createSlidersEventsManager(self._renderer, controller, function(moving) {
                            self._processSelectionChanged(moving)
                        })
                },
                ctor: function(renderer) {
                    var self = this,
                        sliders;
                    self.callBase(renderer);
                    sliders = [self._createSlider(START_VALUE_INDEX), self._createSlider(END_VALUE_INDEX)];
                    self._controller = self._createSlidersController(sliders);
                    self._eventsManager = self._createSlidersEventsManager(self._controller)
                },
                getSelectedRange: function() {
                    return this._controller.getSelectedRange()
                },
                setSelectedRange: function(selectedRange) {
                    var self = this,
                        scale = self._options.scale,
                        startValue,
                        endValue,
                        currentSelectedRange = self._options.selectedRange;
                    if (selectedRange) {
                        startValue = selectedRange.startValue;
                        endValue = selectedRange.endValue
                    }
                    if (isNumber(scale.startValue) && isNumber(startValue) || isDate(scale.startValue) && isDate(startValue))
                        currentSelectedRange.startValue = startValue;
                    if (isNumber(scale.endValue) && isNumber(endValue) || isDate(scale.endValue) && isDate(endValue))
                        currentSelectedRange.endValue = endValue;
                    self._controller.applySelectedRange(currentSelectedRange);
                    self._controller.applyPosition();
                    self._processSelectionChanged(false)
                },
                appendTrackers: function(group) {
                    this._controller.appendTrackers(group)
                },
                _applyOptions: function(options) {
                    var self = this;
                    self._controller.applyOptions({
                        translator: options.translator,
                        canvas: options.canvas,
                        sliderMarker: options.sliderMarker,
                        sliderHandles: options.sliderHandles,
                        shutter: options.shutter,
                        scale: options.scale,
                        behavior: options.behavior
                    });
                    self._eventsManager.applyOptions({behavior: options.behavior})
                },
                _draw: function(group) {
                    var self = this;
                    if (msPointerEnabled)
                        self._renderer.getRoot().element.style.msTouchAction = "none";
                    self._controller.redraw(group);
                    self._drawAreaTracker(group);
                    self._eventsManager.initialize();
                    self._update()
                },
                _update: function() {
                    var self = this,
                        isEmpty = self._options.isEmpty;
                    self._eventsManager.setEnabled(!isEmpty);
                    self._controller.applySelectedRange(isEmpty ? {} : self._options.selectedRange);
                    self._controller.applyPosition();
                    this._updateLastSelectedRange()
                }
            };
        return prototypeObject
    }())
})(jQuery, DevExpress);

// Module viz, file slidersController.js

(function($, DX, undefined) {
    var rangeSelector = DX.viz.rangeSelector,
        utils = DX.utils;
    var START_VALUE_INDEX = 0,
        END_VALUE_INDEX = 1;
    rangeSelector.SlidersController = DX.Class.inherit(function() {
        return {
                ctor: function(sliders) {
                    this._sliders = sliders;
                    sliders[START_VALUE_INDEX].setAnotherSlider(sliders[END_VALUE_INDEX]);
                    sliders[END_VALUE_INDEX].setAnotherSlider(sliders[START_VALUE_INDEX])
                },
                setAreaTrackers: function(areaTracker, selectedAreaTracker) {
                    this._areaTracker = areaTracker;
                    this._selectedAreaTracker = selectedAreaTracker
                },
                applyOptions: function(options) {
                    var self = this,
                        values;
                    self._options = options;
                    self.getSlider(START_VALUE_INDEX).applyOptions(options);
                    self.getSlider(END_VALUE_INDEX).applyOptions(options);
                    if (options.behavior.snapToTicks) {
                        values = options.scale.ticksInfo.fullTicks;
                        if (values.length > 1 && values[0] > values[values.length - 1])
                            values = values.reverse();
                        self.getSlider(START_VALUE_INDEX).setAvailableValues(values);
                        self.getSlider(END_VALUE_INDEX).setAvailableValues(values)
                    }
                },
                processDocking: function(sliderIndex) {
                    var self = this;
                    if (sliderIndex !== undefined)
                        self.getSlider(sliderIndex).processDocking();
                    else {
                        self.getSlider(START_VALUE_INDEX).processDocking();
                        self.getSlider(END_VALUE_INDEX).processDocking()
                    }
                    self.applyAreaTrackersPosition()
                },
                getSelectedRangeInterval: function() {
                    var self = this;
                    return rangeSelector.utils.getInterval(self.getSlider(START_VALUE_INDEX).getValue(), self.getSlider(END_VALUE_INDEX).getValue())
                },
                moveSliders: function(postitionDelta, selectedRangeInterval) {
                    var self = this;
                    self.getSlider(START_VALUE_INDEX).setPosition(self.getSlider(START_VALUE_INDEX).getPosition() + postitionDelta, false, selectedRangeInterval);
                    self.applyPosition(true)
                },
                moveSlider: function(sliderIndex, fastSwap, position, offsetPosition, startOffsetPosition, startOffsetPositionChangedCallback) {
                    var self = this,
                        slider = self.getSlider(sliderIndex),
                        anotherSlider = slider.getAnotherSlider(),
                        anotherSliderIndex = anotherSlider.getIndex(),
                        doSwap;
                    if (slider.canSwap())
                        if (sliderIndex === START_VALUE_INDEX ? position > anotherSlider.getPosition() : position < anotherSlider.getPosition()) {
                            doSwap = fastSwap;
                            if (!fastSwap)
                                if (Math.abs(offsetPosition) >= Math.abs(startOffsetPosition) && offsetPosition * startOffsetPosition < 0) {
                                    doSwap = true;
                                    position += 2 * startOffsetPosition;
                                    startOffsetPositionChangedCallback(-startOffsetPosition)
                                }
                            if (doSwap) {
                                self.swapSliders();
                                anotherSlider.applyPosition(true)
                            }
                        }
                    slider.setPosition(position, true);
                    slider.applyPosition(true);
                    self.applyAreaTrackersPosition()
                },
                applySelectedAreaCenterPosition: function(pos) {
                    var self = this,
                        slidersContainerHalfWidth = (self.getSlider(END_VALUE_INDEX).getPosition() - self.getSlider(START_VALUE_INDEX).getPosition()) / 2,
                        selectedRangeInterval = self.getSelectedRangeInterval();
                    self.getSlider(START_VALUE_INDEX).setPosition(pos - slidersContainerHalfWidth, false, selectedRangeInterval);
                    self.applyPosition();
                    self.processDocking()
                },
                processManualSelection: function(startPosition, endPosition, eventArgs) {
                    var self = this,
                        animateSliderIndex,
                        movingSliderIndex,
                        positionRange = [Math.min(startPosition, endPosition), Math.max(startPosition, endPosition)];
                    animateSliderIndex = startPosition < endPosition ? START_VALUE_INDEX : END_VALUE_INDEX;
                    movingSliderIndex = startPosition < endPosition ? END_VALUE_INDEX : START_VALUE_INDEX;
                    self.getSlider(movingSliderIndex).setPosition(positionRange[movingSliderIndex]);
                    self.getSlider(animateSliderIndex).setPosition(positionRange[animateSliderIndex]);
                    self.getSlider(movingSliderIndex).setPosition(positionRange[movingSliderIndex], true);
                    self.getSlider(movingSliderIndex).startEventHandler(eventArgs);
                    self.getSlider(animateSliderIndex).processDocking();
                    self.getSlider(movingSliderIndex).applyPosition(true)
                },
                applySelectedRange: function(selectedRange) {
                    var self = this,
                        inverted = self._options.scale.inverted;
                    if (!inverted && selectedRange.startValue > selectedRange.endValue || inverted && selectedRange.startValue < selectedRange.endValue) {
                        self.getSlider(START_VALUE_INDEX).setValue(selectedRange.endValue);
                        self.getSlider(END_VALUE_INDEX).setValue(selectedRange.startValue)
                    }
                    else {
                        self.getSlider(START_VALUE_INDEX).setValue(selectedRange.startValue);
                        self.getSlider(END_VALUE_INDEX).setValue(selectedRange.endValue)
                    }
                },
                getSelectedRange: function() {
                    var self = this;
                    return {
                            startValue: self.getSlider(START_VALUE_INDEX).getValue(),
                            endValue: self.getSlider(END_VALUE_INDEX).getValue()
                        }
                },
                swapSliders: function() {
                    var self = this;
                    self._sliders.reverse();
                    self.getSlider(START_VALUE_INDEX).changeLocation();
                    self.getSlider(END_VALUE_INDEX).changeLocation()
                },
                applyAreaTrackersPosition: function() {
                    var self = this,
                        width = self.getSlider(END_VALUE_INDEX).getPosition() - self.getSlider(START_VALUE_INDEX).getPosition(),
                        options = {
                            x: self.getSlider(START_VALUE_INDEX).getPosition(),
                            width: width < 0 ? 0 : width,
                            y: self._options.canvas.top,
                            height: self._options.canvas.height
                        };
                    self._selectedAreaTracker.applySettings(options);
                    self._areaTracker.applySettings({
                        x: self._options.canvas.left,
                        width: self._options.canvas.width,
                        y: self._options.canvas.top,
                        height: self._options.canvas.height
                    })
                },
                applyPosition: function(disableAnimation) {
                    var self = this;
                    self.getSlider(START_VALUE_INDEX).applyPosition(disableAnimation);
                    self.getSlider(END_VALUE_INDEX).applyPosition(disableAnimation);
                    self.applyAreaTrackersPosition()
                },
                redraw: function(group) {
                    var self = this;
                    self.getSlider(START_VALUE_INDEX).redraw(group);
                    self.getSlider(END_VALUE_INDEX).redraw(group)
                },
                appendTrackers: function(group) {
                    var self = this;
                    if (self._areaTracker && self._selectedAreaTracker) {
                        self._areaTracker.append(group);
                        self._selectedAreaTracker.append(group)
                    }
                    self.getSlider(START_VALUE_INDEX).appendTrackers(group);
                    self.getSlider(END_VALUE_INDEX).appendTrackers(group)
                },
                getSlider: function(sliderIndex) {
                    return this._sliders[sliderIndex]
                },
                getAreaTracker: function() {
                    return this._areaTracker
                },
                getSelectedAreaTracker: function() {
                    return this._selectedAreaTracker
                }
            }
    }())
})(jQuery, DevExpress);

// Module viz, file slidersEventsManager.js

(function($, DX, undefined) {
    var rangeSelector = DX.viz.rangeSelector,
        utils = DX.utils;
    var touchSupport = "ontouchstart" in window;
    var msPointerEnabled = window.navigator.msPointerEnabled;
    rangeSelector.events = {
        start: msPointerEnabled ? "MSPointerDown" : touchSupport ? "touchstart mousedown" : "mousedown",
        move: msPointerEnabled ? "MSPointerMove" : touchSupport ? "touchmove mousemove" : "mousemove",
        end: msPointerEnabled ? "MSPointerUp MSPointerCancel" : touchSupport ? "touchend mouseup" : "mouseup"
    };
    var MIN_MANUAL_SELECTING_WIDTH = 10,
        START_VALUE_INDEX = 0,
        END_VALUE_INDEX = 1;
    rangeSelector.SlidersEventsManager = DX.Class.inherit(function() {
        var getRootOffsetLeft = function(self) {
                return rangeSelector.utils.getRootOffsetLeft(self._renderer)
            };
        var getEventPageX = function(eventArgs) {
                return rangeSelector.utils.getEventPageX(eventArgs)
            };
        var isLeftButtonPressed = function(event) {
                var e = event || window.event,
                    originalEvent = e.originalEvent,
                    touches = e.touches,
                    pointerType = originalEvent ? originalEvent.pointerType : false,
                    eventTouches = originalEvent ? originalEvent.touches : false,
                    isIE8LeftClick = e.which === undefined && e.button === 1,
                    isLeftClick = isIE8LeftClick || e.which === 1,
                    isCorrectPointerType = originalEvent && pointerType !== undefined && (pointerType === originalEvent.MSPOINTER_TYPE_TOUCH || pointerType === originalEvent.MSPOINTER_TYPE_MOUSE),
                    isTouches = touches && touches.length > 0 || eventTouches && eventTouches.length > 0;
                return isLeftClick || isCorrectPointerType || isTouches
            };
        var subscribeEventToDocument = function(event, handler) {
                var currentWindow = window;
                $(document).on(event, handler);
                while (currentWindow.parent && currentWindow.parent !== currentWindow) {
                    currentWindow = currentWindow.parent;
                    $(currentWindow.document).on(event, handler)
                }
            };
        var initializeSliderEvents = function(self, sliderIndex) {
                var renderer = self._renderer,
                    slidersController = self._slidersController,
                    processSelectionChanged = self._processSelectionChanged,
                    slider = slidersController.getSlider(sliderIndex),
                    anotherSlider = slider.getAnotherSlider(),
                    fastSwap,
                    startOffsetPosition,
                    splitterMoving;
                slider.startEventHandler = function(e) {
                    if (!self._enabled || !isLeftButtonPressed(e))
                        return;
                    fastSwap = this === slider.getSliderTracker().element;
                    splitterMoving = true;
                    startOffsetPosition = getEventPageX(e) - slider.getPosition() - getRootOffsetLeft(self);
                    e.stopPropagation();
                    e.preventDefault()
                };
                slider.on(rangeSelector.events.start, slider.startEventHandler);
                subscribeEventToDocument(rangeSelector.events.end, function(e) {
                    if (splitterMoving) {
                        splitterMoving = false;
                        slidersController.processDocking();
                        processSelectionChanged(false)
                    }
                });
                renderer.getRoot().on(rangeSelector.events.move, function(e) {
                    var doSwap,
                        pageX,
                        offsetPosition,
                        svgOffsetLeft = getRootOffsetLeft(self),
                        position,
                        sliderIndex = slider.getIndex();
                    if (!isLeftButtonPressed(e) && splitterMoving) {
                        splitterMoving = false;
                        slidersController.processDocking();
                        processSelectionChanged(false)
                    }
                    else if (splitterMoving) {
                        e.preventDefault();
                        pageX = getEventPageX(e);
                        position = pageX - startOffsetPosition - svgOffsetLeft;
                        offsetPosition = pageX - slider.getPosition() - svgOffsetLeft;
                        slidersController.moveSlider(sliderIndex, fastSwap, position, offsetPosition, startOffsetPosition, function(newStartOffsetPosition) {
                            startOffsetPosition = newStartOffsetPosition
                        });
                        processSelectionChanged(true)
                    }
                })
            };
        var initializeSelectedAreaEvents = function(self) {
                var renderer = self._renderer,
                    slidersController = self._slidersController,
                    processSelectionChanged = self._processSelectionChanged,
                    selectedAreaTracker = slidersController.getSelectedAreaTracker(),
                    selectedAreaMoving = false,
                    offsetStartPosition,
                    selectedRangeInterval;
                selectedAreaTracker.on(rangeSelector.events.start, function(e) {
                    if (!self._enabled || !isLeftButtonPressed(e))
                        return;
                    selectedAreaMoving = true;
                    offsetStartPosition = getEventPageX(e) - slidersController.getSlider(START_VALUE_INDEX).getPosition();
                    selectedRangeInterval = slidersController.getSelectedRangeInterval();
                    e.stopPropagation();
                    e.preventDefault()
                });
                subscribeEventToDocument(rangeSelector.events.end, function(e) {
                    if (selectedAreaMoving) {
                        selectedAreaMoving = false;
                        slidersController.processDocking();
                        processSelectionChanged(false)
                    }
                });
                renderer.getRoot().on(rangeSelector.events.move, function(e) {
                    var positionDelta,
                        pageX;
                    if (selectedAreaMoving && !isLeftButtonPressed(e)) {
                        selectedAreaMoving = false;
                        slidersController.processDocking();
                        processSelectionChanged(false)
                    }
                    if (selectedAreaMoving) {
                        e.preventDefault();
                        pageX = getEventPageX(e);
                        positionDelta = pageX - slidersController.getSlider(START_VALUE_INDEX).getPosition() - offsetStartPosition;
                        slidersController.moveSliders(positionDelta, selectedRangeInterval);
                        processSelectionChanged(true)
                    }
                })
            };
        var initializeAreaEvents = function(self) {
                var renderer = self._renderer,
                    slidersController = self._slidersController,
                    processSelectionChanged = self._processSelectionChanged,
                    areaTracker = slidersController.getAreaTracker(),
                    unselectedAreaProcessing = false,
                    splitterMoving = false,
                    startPageX;
                areaTracker.on(rangeSelector.events.start, function(e) {
                    if (!self._enabled || !isLeftButtonPressed(e))
                        return;
                    unselectedAreaProcessing = true;
                    startPageX = getEventPageX(e)
                });
                subscribeEventToDocument(rangeSelector.events.end, function(e) {
                    var pageX;
                    if (unselectedAreaProcessing) {
                        pageX = getEventPageX(e);
                        if (self._options.behavior.moveSelectedRangeByClick && Math.abs(startPageX - pageX) < MIN_MANUAL_SELECTING_WIDTH)
                            slidersController.applySelectedAreaCenterPosition(pageX - getRootOffsetLeft(self));
                        unselectedAreaProcessing = false;
                        processSelectionChanged(false)
                    }
                });
                renderer.getRoot().on(rangeSelector.events.move, function(e) {
                    var pageX,
                        startPosition,
                        endPosition,
                        svgOffsetLeft = getRootOffsetLeft(self);
                    if (unselectedAreaProcessing && !isLeftButtonPressed(e)) {
                        unselectedAreaProcessing = false;
                        processSelectionChanged(false)
                    }
                    if (unselectedAreaProcessing) {
                        pageX = getEventPageX(e);
                        if (self._options.behavior.manualRangeSelectionEnabled && Math.abs(startPageX - pageX) >= MIN_MANUAL_SELECTING_WIDTH) {
                            startPosition = startPageX - svgOffsetLeft;
                            endPosition = pageX - svgOffsetLeft;
                            slidersController.processManualSelection(startPosition, endPosition, e);
                            unselectedAreaProcessing = false;
                            processSelectionChanged(true)
                        }
                    }
                })
            };
        rangeSelector.getRootOffsetLeft = getRootOffsetLeft;
        return {
                ctor: function(renderer, slidersController, processSelectionChanged) {
                    this._renderer = renderer;
                    this._slidersController = slidersController;
                    this._processSelectionChanged = processSelectionChanged;
                    this._enabled = true
                },
                applyOptions: function(options) {
                    this._options = options
                },
                initialize: function() {
                    var self = this;
                    if (!self._renderer.isInitialized())
                        return;
                    initializeSelectedAreaEvents(self);
                    initializeAreaEvents(self);
                    initializeSliderEvents(self, START_VALUE_INDEX);
                    initializeSliderEvents(self, END_VALUE_INDEX)
                },
                setEnabled: function(enabled) {
                    this._enabled = enabled
                }
            }
    }())
})(jQuery, DevExpress);

// Module viz, file slider.js

(function($, DX, undefined) {
    var rangeSelector = DX.viz.rangeSelector,
        utils = DX.utils;
    var touchSupport = "ontouchstart" in window;
    var msPointerEnabled = window.navigator.msPointerEnabled;
    var animationOptions = {duration: 250};
    var SPLITTER_WIDTH = 8,
        TOUCH_SPLITTER_WIDTH = 20,
        START_VALUE_INDEX = 0,
        END_VALUE_INDEX = 1;
    rangeSelector.Slider = rangeSelector.BaseVisualElement.inherit(function() {
        return {
                getText: function() {
                    if (this._marker)
                        return this._marker.getText()
                },
                getAvailableValues: function() {
                    return this._values
                },
                getShutter: function() {
                    return this._shutter
                },
                getMarker: function() {
                    return this._marker
                },
                _createSlider: function() {
                    var self = this,
                        sliderHandle,
                        sliderGroup;
                    sliderGroup = self._renderer.createGroup({'class': 'slider'});
                    sliderGroup.applySettings({
                        translateX: self._options.canvas.left,
                        translateY: self._options.canvas.top
                    });
                    sliderHandle = self._renderer.createLine(0, 0, 0, self._options.canvas.height, {
                        strokeWidth: self._options.sliderHandles.width,
                        stroke: self._options.sliderHandles.color,
                        strokeOpacity: self._options.sliderHandles.opacity
                    });
                    sliderHandle.append(sliderGroup);
                    sliderGroup.setValid = function(correct) {
                        sliderHandle.applySettings({stroke: correct ? self._options.sliderHandles.color : self._options.sliderMarker.invalidRangeColor})
                    };
                    sliderGroup.updateHeight = function() {
                        sliderHandle.applySettings({points: [0, 0, 0, self._options.canvas.height]})
                    };
                    sliderGroup.__line = sliderHandle;
                    return sliderGroup
                },
                _createSliderTracker: function() {
                    var self = this,
                        sliderWidth = touchSupport || msPointerEnabled ? TOUCH_SPLITTER_WIDTH : SPLITTER_WIDTH,
                        sliderTracker,
                        sliderTrackerGroup;
                    sliderTracker = self._renderer.createRect(-sliderWidth / 2, 0, sliderWidth, self._options.canvas.height, 0, {
                        fill: 'grey',
                        stroke: 'grey',
                        opacity: 0.0001,
                        style: {cursor: 'w-resize'}
                    });
                    sliderTrackerGroup = self._renderer.createGroup({'class': 'sliderTracker'});
                    sliderTrackerGroup.applySettings({
                        translateX: 0,
                        translateY: self._options.canvas.top
                    });
                    sliderTracker.append(sliderTrackerGroup);
                    sliderTrackerGroup.updateHeight = function() {
                        sliderTracker.applySettings({height: self._options.canvas.height})
                    };
                    sliderTrackerGroup.__rect = sliderTracker;
                    return sliderTrackerGroup
                },
                _drawSliderTracker: function(group) {
                    var self = this,
                        sliderTracker = self._createSliderTracker();
                    if (sliderTracker) {
                        sliderTracker.append(group);
                        self._sliderTracker = sliderTracker
                    }
                },
                _createSliderMarker: function(options) {
                    return rangeSelector.rangeSelectorFactory.createSliderMarker(options)
                },
                _setPosition: function(position, correctByMinMaxRange) {
                    var self = this,
                        correctedPosition = self._correctPosition(position),
                        value = self._options.translator.untranslateX(correctedPosition);
                    self.setValue(value, correctByMinMaxRange);
                    self._position = correctedPosition
                },
                _setPositionForBothSliders: function(startPosition, interval) {
                    var self = this,
                        anotherSlider,
                        startValue,
                        endValue,
                        endPosition,
                        inverted = self._options.scale.inverted;
                    anotherSlider = self.getAnotherSlider();
                    startPosition = self._correctBounds(startPosition);
                    startValue = self._options.translator.untranslateX(startPosition);
                    endValue = utils.addInterval(startValue, interval);
                    if (!inverted && endValue > self._options.scale.endValue || inverted && endValue < self._options.scale.endValue) {
                        endValue = self._options.scale.endValue;
                        endPosition = self._options.canvas.left + self._options.canvas.width;
                        startValue = utils.addInterval(endValue, interval, true);
                        startPosition = self._options.translator.translateX(startValue)
                    }
                    else
                        endPosition = self._options.translator.translateX(endValue);
                    if (self._values)
                        if (!inverted ? startValue < self._values[0] : startValue > self._values[self._values.length - 1]) {
                            startValue = self._correctBusinessValueByAvailableValues(startValue);
                            endValue = utils.addInterval(startValue, interval)
                        }
                        else {
                            endValue = self._correctBusinessValueByAvailableValues(endValue);
                            startValue = utils.addInterval(endValue, interval, true)
                        }
                    anotherSlider.setValue(endValue);
                    self.setValue(startValue);
                    self._position = startPosition;
                    anotherSlider._position = endPosition
                },
                _correctPosition: function(position) {
                    var self = this,
                        correctedPosition = self._correctInversion(position);
                    correctedPosition = self._correctBounds(correctedPosition);
                    return correctedPosition
                },
                _correctInversion: function(position) {
                    var self = this,
                        correctedPosition = position,
                        anotherSliderPosition = self.getAnotherSlider().getPosition(),
                        slidersInverted = self.getIndex() === START_VALUE_INDEX ? position > anotherSliderPosition : position < anotherSliderPosition;
                    if (slidersInverted)
                        correctedPosition = anotherSliderPosition;
                    return correctedPosition
                },
                _correctBounds: function(position) {
                    var self = this,
                        correctedPosition = position,
                        canvas = self._options.canvas;
                    if (position < canvas.left)
                        correctedPosition = canvas.left;
                    if (position > canvas.left + canvas.width)
                        correctedPosition = canvas.left + canvas.width;
                    return correctedPosition
                },
                _correctBusinessValue: function(businessValue, correctByMinMaxRange) {
                    var self = this,
                        result = self._correctBusinessValueByAvailableValues(businessValue);
                    if (correctByMinMaxRange)
                        result = self._correctBusinessValueByMinMaxRangeFromAnotherSlider(result);
                    result = self._correctBusinessValueByMinRangeFromStartEndValues(result);
                    return result
                },
                _correctBusinessValueByAvailableValues: function(businessValue) {
                    var values = this._values;
                    if (values)
                        return rangeSelector.utils.findNearValue(values, businessValue);
                    return businessValue
                },
                _correctBusinessValueByMinMaxRangeFromAnotherSlider: function(businessValue) {
                    var self = this,
                        result = businessValue,
                        scale = self._options.scale,
                        values = self._values,
                        sliderIndex = self.getIndex(),
                        anotherBusinessValue = self.getAnotherSlider().getValue(),
                        isValid = true,
                        minValue,
                        maxValue;
                    if (!scale.inverted && sliderIndex === START_VALUE_INDEX || scale.inverted && sliderIndex === END_VALUE_INDEX) {
                        if (scale.maxRange)
                            minValue = utils.addInterval(anotherBusinessValue, scale.maxRange, true);
                        if (scale.minRange)
                            maxValue = utils.addInterval(anotherBusinessValue, scale.minRange, true)
                    }
                    else {
                        if (scale.maxRange)
                            maxValue = utils.addInterval(anotherBusinessValue, scale.maxRange);
                        if (scale.minRange)
                            minValue = utils.addInterval(anotherBusinessValue, scale.minRange)
                    }
                    if (maxValue !== undefined && result > maxValue) {
                        result = values ? rangeSelector.utils.findLessOrEqualValue(values, maxValue) : maxValue;
                        isValid = false
                    }
                    else if (minValue !== undefined && result < minValue) {
                        result = values ? rangeSelector.utils.findGreaterOrEqualValue(values, minValue) : minValue;
                        isValid = false
                    }
                    self._setValid(isValid);
                    return result
                },
                _correctBusinessValueByMinRangeFromStartEndValues: function(businessValue) {
                    var self = this,
                        values = self._values,
                        startValue,
                        endValue,
                        isValid = true,
                        scale = self._options.scale,
                        result = businessValue;
                    if (scale.minRange)
                        if (self.getIndex() === END_VALUE_INDEX) {
                            startValue = utils.addInterval(scale.startValue, scale.minRange, scale.inverted);
                            if (!scale.inverted && result < startValue || scale.inverted && result > startValue)
                                result = startValue
                        }
                        else if (self.getIndex() === START_VALUE_INDEX) {
                            endValue = utils.addInterval(scale.endValue, scale.minRange, !scale.inverted);
                            if (!scale.inverted && result > endValue || scale.inverted && result < endValue)
                                result = endValue
                        }
                    return result
                },
                _applySliderPosition: function(position, disableAnimation) {
                    var self = this,
                        isAnimation = self._options.behavior.animationEnabled && !disableAnimation,
                        top = self._options.canvas.top;
                    if (isAnimation) {
                        self._slider.animate({translate: {
                                x: position,
                                y: top
                            }}, animationOptions);
                        self._sliderTracker.animate({translate: {
                                x: position,
                                y: top
                            }}, animationOptions)
                    }
                    else if (!$(self._slider).is(':animated')) {
                        self._slider.applySettings({
                            translateX: position,
                            translateY: top
                        });
                        self._sliderTracker.applySettings({
                            translateX: position,
                            translateY: top
                        })
                    }
                    self._sliderTracker.updateHeight();
                    self._slider.updateHeight()
                },
                _applyShutterPosition: function(position, disableAnimation) {
                    var self = this,
                        shutterSettings,
                        isAnimation = self._options.behavior.animationEnabled && !disableAnimation,
                        sliderIndex = self.getIndex();
                    if (sliderIndex == START_VALUE_INDEX)
                        shutterSettings = {
                            x: self._options.canvas.left,
                            y: self._options.canvas.top,
                            width: position - self._options.canvas.left,
                            height: self._options.canvas.height
                        };
                    else if (sliderIndex == END_VALUE_INDEX)
                        shutterSettings = {
                            x: position + 1,
                            y: self._options.canvas.top,
                            width: self._options.canvas.left + self._options.canvas.width - position,
                            height: self._options.canvas.height
                        };
                    if (shutterSettings)
                        if (isAnimation)
                            self._shutter.animate(shutterSettings, animationOptions);
                        else if (!$(self._shutter).is(':animated'))
                            self._shutter.applySettings(shutterSettings)
                },
                _setValid: function(isValid) {
                    var self = this;
                    if (self._marker)
                        self._marker.setValid(isValid);
                    self._slider.setValid(isValid)
                },
                _setText: function(text) {
                    var self = this;
                    if (self._marker)
                        self._marker.setText(text)
                },
                ctor: function(renderer, index) {
                    var self = this;
                    self.callBase(renderer);
                    self._index = index
                },
                getIndex: function() {
                    return this._index
                },
                setAvailableValues: function(values) {
                    this._values = values
                },
                setAnotherSlider: function(slider) {
                    this._anotherSlider = slider
                },
                getAnotherSlider: function(slider) {
                    return this._anotherSlider
                },
                appendTrackers: function(group) {
                    var self = this;
                    if (self._sliderTracker)
                        self._sliderTracker.append(group)
                },
                getSliderTracker: function() {
                    return this._sliderTracker
                },
                changeLocation: function() {
                    var self = this;
                    if (self._marker)
                        self._marker.changeLocation();
                    self._index = this._index === START_VALUE_INDEX ? END_VALUE_INDEX : START_VALUE_INDEX
                },
                setPosition: function(position, correctByMinMaxRange, selectedRangeInterval) {
                    var self = this,
                        slider;
                    if (selectedRangeInterval) {
                        slider = self.getIndex() === START_VALUE_INDEX ? self : self.getAnotherSlider();
                        slider._setPositionForBothSliders(position, selectedRangeInterval)
                    }
                    else
                        self._setPosition(position, correctByMinMaxRange)
                },
                getPosition: function() {
                    return this._position
                },
                setValue: function(value, correctByMinMaxRange) {
                    var self = this;
                    if (value === undefined) {
                        self._value = undefined;
                        self._valuePosition = self._position = self.getIndex() === START_VALUE_INDEX ? self._options.canvas.left : self._options.canvas.left + self._options.canvas.width;
                        self._setText(rangeSelector.consts.emptySliderMarkerText)
                    }
                    else {
                        self._value = self._correctBusinessValue(value, correctByMinMaxRange);
                        self._valuePosition = self._position = self._options.translator.translateX(self._value);
                        self._setText(rangeSelector.formatValue(self._value, self._options.sliderMarker))
                    }
                },
                getValue: function() {
                    return this._value
                },
                canSwap: function() {
                    var self = this,
                        scale = self._options.scale,
                        startValue,
                        endValue,
                        anotherSliderValue;
                    if (self._options.behavior.allowSlidersSwap) {
                        if (scale.minRange) {
                            anotherSliderValue = self.getAnotherSlider().getValue();
                            if (self.getIndex() === START_VALUE_INDEX) {
                                endValue = utils.addInterval(scale.endValue, scale.minRange, !scale.inverted);
                                if (!scale.inverted && anotherSliderValue > endValue || scale.inverted && anotherSliderValue < endValue)
                                    return false
                            }
                            else {
                                startValue = utils.addInterval(scale.startValue, scale.minRange, scale.inverted);
                                if (!scale.inverted && anotherSliderValue < startValue || scale.inverted && anotherSliderValue > startValue)
                                    return false
                            }
                        }
                        return true
                    }
                    return false
                },
                processDocking: function() {
                    var self = this;
                    self._position = self._valuePosition;
                    self.applyPosition(false);
                    self._setValid(true)
                },
                applyPosition: function(disableAnimation) {
                    var self = this,
                        position = self.getPosition();
                    self._applySliderPosition(position, disableAnimation);
                    self._applyShutterPosition(position, disableAnimation)
                },
                on: function(event, handler) {
                    var self = this;
                    self._sliderTracker.on(event, handler);
                    if (self._marker)
                        self._marker.getTracker().on(event, handler)
                },
                _update: function(){},
                _draw: function(group) {
                    var self = this,
                        slider,
                        marker,
                        sliderAreaGroup,
                        shutter,
                        startPos,
                        startWidth,
                        shutterOptions = {
                            fill: self._options.shutter.color,
                            fillOpacity: self._options.shutter.opacity
                        },
                        index = self.getIndex();
                    sliderAreaGroup = self._renderer.createGroup({'class': 'sliderArea'});
                    sliderAreaGroup.append(group);
                    if (index === START_VALUE_INDEX)
                        shutter = self._renderer.createRect(self._options.canvas.left, self._options.canvas.top, 0, self._options.canvas.height, 0, shutterOptions);
                    else if (index === END_VALUE_INDEX)
                        shutter = self._renderer.createRect(self._options.canvas.left, self._options.canvas.top, self._options.canvas.width, self._options.canvas.height, 0, shutterOptions);
                    if (shutter) {
                        shutter.append(sliderAreaGroup);
                        slider = self._createSlider();
                        if (slider)
                            slider.append(sliderAreaGroup);
                        if (self._options.sliderMarker.visible) {
                            marker = self._createSliderMarker({
                                renderer: self._renderer,
                                isLeftPointer: index === END_VALUE_INDEX,
                                sliderMarkerOptions: self._options.sliderMarker
                            });
                            marker.draw(slider)
                        }
                        self._shutter = shutter;
                        self._slider = slider;
                        self._marker = marker
                    }
                    self._drawSliderTracker(group)
                }
            }
    }())
})(jQuery, DevExpress);

// Module viz, file sliderMarker.js

(function($, DX, undefined) {
    var rangeSelector = DX.viz.rangeSelector;
    rangeSelector.SliderMarker = DX.Class.inherit(function() {
        var ctor = function(options) {
                this._renderer = options.renderer;
                this._text = options.text;
                this._isLeftPointer = options.isLeftPointer;
                this._options = options.sliderMarkerOptions;
                this._isValid = true;
                initializeAreaPoints(this, {
                    width: 10,
                    height: 10
                })
            };
        var getRectSize = function(self, textSize) {
                return {
                        width: Math.round(2 * self._options.padding + textSize.width),
                        height: Math.round(2 * self._options.padding + textSize.height * rangeSelector.consts.fontHeightRatio)
                    }
            };
        var initializeAreaPoints = function(self, textSize) {
                var rectSize = getRectSize(self, textSize);
                self._points = [];
                if (self._isLeftPointer) {
                    self._points.push({
                        x: 0,
                        y: 0
                    });
                    self._points.push({
                        x: rectSize.width,
                        y: 0
                    });
                    self._points.push({
                        x: rectSize.width,
                        y: rectSize.height
                    });
                    self._points.push({
                        x: self._options.pointerSize,
                        y: rectSize.height
                    });
                    self._points.push({
                        x: 0,
                        y: rectSize.height + self._options.pointerSize
                    })
                }
                else {
                    self._points.push({
                        x: 0,
                        y: 0
                    });
                    self._points.push({
                        x: rectSize.width,
                        y: 0
                    });
                    self._points.push({
                        x: rectSize.width,
                        y: rectSize.height + self._options.pointerSize
                    });
                    self._points.push({
                        x: rectSize.width - self._options.pointerSize,
                        y: rectSize.height
                    });
                    self._points.push({
                        x: 0,
                        y: rectSize.height
                    })
                }
            };
        var getPointerPosition = function(self, textSize) {
                var rectSize = getRectSize(self, textSize);
                if (self._isLeftPointer)
                    return {
                            x: 0,
                            y: rectSize.height + self._options.pointerSize
                        };
                else
                    return {
                            x: rectSize.width - 1,
                            y: rectSize.height + self._options.pointerSize
                        }
            };
        var draw = function(group) {
                var self = this;
                var padding = self._options.padding;
                self._sliderMarkerGroup = self._renderer.createGroup({'class': 'sliderMarker'});
                self._sliderMarkerGroup.append(group);
                self._area = self._renderer.createArea(self.points, {fill: self._options.color});
                self._area.append(self._sliderMarkerGroup);
                self._label = self._renderer.createText(self._text, padding, padding, {
                    font: self._options.font,
                    style: {'-webkit-user-select': 'none'}
                });
                self._label.append(self._sliderMarkerGroup);
                self._tracker = self._renderer.createRect(0, 0, 2 * padding, 2 * padding + self._options.pointerSize, 0, {
                    fill: 'grey',
                    stroke: 'grey',
                    opacity: 0.0001,
                    style: {cursor: 'pointer'}
                });
                self._tracker.append(self._sliderMarkerGroup);
                self._drawn = true;
                self.update()
            };
        var getTextSize = function(self) {
                var textSize = self._label.getBBox();
                if (!self._textHeight && isFinite(textSize.height))
                    self._textHeight = textSize.height;
                return {
                        width: textSize.width,
                        height: self._textHeight
                    }
            };
        var update = function(stop) {
                var self = this,
                    textSize,
                    rectSize,
                    pointerPosition;
                self._interval && clearInterval(self._interval);
                delete self._interval;
                if (!self._drawn)
                    return;
                self._label.updateText(self._text);
                textSize = getTextSize(self);
                if (!stop) {
                    self._textSize = self._textSize || textSize;
                    self._textSize = textSize.width > self._textSize.width || textSize.height > self._textSize.height ? textSize : self._textSize;
                    textSize = self._textSize;
                    self._interval = setInterval(function() {
                        update.call(self, [true])
                    }, 75)
                }
                else {
                    delete self._textSize;
                    self._textSize = textSize
                }
                rectSize = getRectSize(self, textSize);
                pointerPosition = getPointerPosition(self, textSize);
                self._sliderMarkerGroup.applySettings({
                    translateX: -pointerPosition.x,
                    translateY: -pointerPosition.y
                });
                initializeAreaPoints(self, textSize);
                self._area.applySettings({
                    points: self._points,
                    fill: self._isValid ? self._options.color : self._options.invalidRangeColor
                });
                self._tracker.applySettings({
                    width: rectSize.width,
                    height: rectSize.height + self._options.pointerSize
                });
                self._label.applySettings({
                    x: self._options.padding,
                    y: rectSize.height - self._options.padding
                })
            };
        var getText = function() {
                var self = this;
                return self._text
            };
        var setText = function(value) {
                var self = this;
                if (self._text !== value) {
                    self._text = value;
                    self.update()
                }
            };
        var setValid = function(isValid) {
                var self = this;
                self._isValid = isValid;
                self.update()
            };
        var changeLocation = function() {
                var self = this;
                self._isLeftPointer = !self._isLeftPointer;
                self.update()
            };
        var getTracker = function() {
                var self = this;
                return self._tracker
            };
        return {
                ctor: ctor,
                draw: draw,
                update: update,
                getText: getText,
                setText: setText,
                changeLocation: changeLocation,
                getTracker: getTracker,
                setValid: setValid
            }
    }())
})(jQuery, DevExpress);

// Module viz, file rangeView.js

(function($, DX, undefined) {
    var rangeSelector = DX.viz.rangeSelector;
    rangeSelector.RangeView = rangeSelector.BaseVisualElement.inherit(function() {
        var createThemeManager = function(self) {
                return DX.viz.charts.factory.createThemeManager(self.chart.theme)
            };
        return {_draw: function(group) {
                    var self = this,
                        viewRect,
                        viewImage,
                        backgroundColor,
                        series,
                        i,
                        showChart,
                        canvas,
                        isEmpty = self._options.isEmpty;
                    showChart = self._options.seriesDataSource && self._options.seriesDataSource.isShowChart() && !isEmpty;
                    canvas = self._options.canvas;
                    if (showChart)
                        backgroundColor = self._options.seriesDataSource.getBackgroundColor();
                    else if (!isEmpty && self._options.background.visible)
                        backgroundColor = self._options.background.color;
                    if (backgroundColor) {
                        viewRect = self._renderer.createRect(canvas.left, canvas.top, canvas.width + 1, canvas.height, 0, {fill: backgroundColor});
                        viewRect.append(group)
                    }
                    if (self._options.background.visible && self._options.background.image && self._options.background.image.url) {
                        viewImage = self._renderer.createImage(canvas.left, canvas.top, canvas.width + 1, canvas.height, self._options.background.image.url, {location: self._options.background.image.location});
                        viewImage.append(group)
                    }
                    if (showChart) {
                        series = self._options.seriesDataSource.getSeries();
                        for (i = 0; i < series.length; i++) {
                            series[i].options.seriesGroup = group;
                            series[i].options.seriesLabelsGroup = group;
                            series[i].options.trackerGroup = group;
                            series[i].draw(self._options.translator);
                            if (self._options.behavior && self._options.behavior.animationEnabled)
                                series[i].animate()
                        }
                    }
                }}
    }())
})(jQuery, DevExpress);

// Module viz, file seriesDataSource.js

(function($, DX, undefined) {
    var rangeSelector = DX.viz.rangeSelector,
        charts = DX.viz.charts;
    rangeSelector.SeriesDataSource = DX.Class.inherit(function() {
        var createThemeManager = function(chartOptions) {
                return charts.factory.createThemeManager(chartOptions, 'rangeSelector.chart')
            };
        var isArrayOfSimpleTypes = function(data) {
                return $.isArray(data) && data.length > 0 && (DX.utils.isNumber(data[0]) || DX.utils.isDate(data[0]))
            };
        var convertToArrayOfObjects = function(data) {
                return $.map(data, function(item, i) {
                        return {
                                arg: item,
                                val: i
                            }
                    })
            };
        var calculateSeries = function(self, options) {
                var series = [],
                    particularSeriesOptions,
                    seriesTheme,
                    data,
                    chartThemeManager = createThemeManager(options.chart),
                    allSeriesOptions = options.chart.series,
                    dataSourceField,
                    chartOptions,
                    i;
                if (options.dataSource && !allSeriesOptions) {
                    if (isArrayOfSimpleTypes(options.dataSource))
                        options.dataSource = convertToArrayOfObjects(options.dataSource);
                    dataSourceField = options.dataSourceField || 'arg';
                    allSeriesOptions = {
                        argumentField: dataSourceField,
                        valueField: dataSourceField
                    };
                    self._hideChart = true
                }
                allSeriesOptions = $.isArray(allSeriesOptions) ? allSeriesOptions : allSeriesOptions ? [allSeriesOptions] : [];
                chartOptions = chartThemeManager.applyTheme(chartThemeManager.getTheme(), options.chart);
                chartOptions.commonSeriesSettings.argumentType = options.valueType;
                chartOptions.commonSeriesSettings.incidentOccured = options.incidentOccured;
                self._backgroundColor = options.backgroundColor !== undefined ? options.backgroundColor : chartOptions.backgroundColor;
                for (i = 0; i < allSeriesOptions.length; i++) {
                    particularSeriesOptions = allSeriesOptions[i];
                    data = particularSeriesOptions.data || options.dataSource;
                    seriesTheme = chartThemeManager.applyNextSeriesTheme(particularSeriesOptions, chartOptions.commonSeriesSettings);
                    if (data && data.length > 0) {
                        var newSeries = charts.factory.createSeries(particularSeriesOptions.type || chartOptions.commonSeriesSettings.type, options.renderer, data, seriesTheme);
                        newSeries._suppressTrackers = true;
                        series.push(newSeries)
                    }
                }
                return series
            };
        var processSeriesFamilies = function(series, equalBarWidth) {
                var families = [],
                    types = [];
                $.each(series, function(i, item) {
                    if ($.inArray(item.type, types) === -1)
                        types.push(item.type)
                });
                $.each(types, function(_, type) {
                    var family = new charts.factory.createSeriesFamily({
                            type: type,
                            equalBarWidth: equalBarWidth
                        });
                    family.add(series);
                    family.adjustSeriesValues();
                    families.push(family)
                });
                return families
            };
        var prototypeObject = {
                ctor: function(options) {
                    var self = this;
                    self._indent = {
                        top: options.chart.topIndent || 0,
                        bottom: options.chart.bottomIndent || 0
                    };
                    self._valueAxis = options.chart.valueAxis || {};
                    self._hideChart = false;
                    self._series = calculateSeries(self, options);
                    self._seriesFamilies = processSeriesFamilies(self._series, options.chart.equalBarWidth)
                },
                adjustSeriesDimensions: function(translator) {
                    var self = this;
                    $.each(self._seriesFamilies, function() {
                        this.adjustSeriesDimensions(translator)
                    })
                },
                getBoundRange: function() {
                    var self = this,
                        seriesElement,
                        rangeData,
                        range = new DX.viz.charts.Range({
                            minY: self._valueAxis.min,
                            minVisibleY: self._valueAxis.min,
                            maxY: self._valueAxis.max,
                            maxVisibleY: self._valueAxis.max
                        }),
                        rangeYSize,
                        i,
                        minIndent,
                        maxIndent;
                    for (i = 0; i < self._series.length; i++) {
                        rangeData = self._series[i].getRangeData();
                        range = range.getBoundRange(rangeData)
                    }
                    if (range.isDefined()) {
                        minIndent = self._valueAxis.inverted ? self._indent.top : self._indent.bottom;
                        maxIndent = self._valueAxis.inverted ? self._indent.bottom : self._indent.top;
                        rangeYSize = range.maxY - range.minY;
                        range.minY -= rangeYSize * minIndent;
                        range.maxY += rangeYSize * maxIndent;
                        range.invertY = self._valueAxis.inverted
                    }
                    return range
                },
                getSeries: function() {
                    var self = this;
                    return self._series
                },
                getBackgroundColor: function() {
                    var self = this;
                    return self._backgroundColor
                },
                isEmpty: function() {
                    var self = this;
                    return self.getSeries().length === 0
                },
                isShowChart: function() {
                    var self = this;
                    return !self.isEmpty() && !self._hideChart
                },
                getCalculatedValueType: function() {
                    var self = this,
                        result;
                    if (self._series.length)
                        result = self._series[0].options.argumentType;
                    return result
                }
            };
        return prototypeObject
    }())
})(jQuery, DevExpress);

// Module viz, file utils.js

(function($, DX, undefined) {
    var rangeSelector = DX.viz.rangeSelector,
        utils = rangeSelector.utils,
        dxUtils = DX.utils;
    var INVISIBLE_POS = -1000;
    var findLessOrEqualValueIndex = function(values, value) {
            if (!values || values.length === 0)
                return -1;
            var minIndex = 0,
                maxIndex = values.length - 1,
                index = 0;
            while (maxIndex - minIndex > 1) {
                var index = minIndex + maxIndex >> 1;
                if (values[index] > value)
                    maxIndex = index;
                else
                    minIndex = index
            }
            return values[maxIndex] <= value ? maxIndex : minIndex
        };
    var findLessOrEqualValue = function(values, value) {
            var index = findLessOrEqualValueIndex(values, value);
            if (values && index >= 0 && index < values.length)
                return values[index];
            return value
        };
    var findNearValue = function(values, value) {
            var index = findLessOrEqualValueIndex(values, value);
            if (values && index >= 0 && index < values.length) {
                if (index + 1 < values.length)
                    if (dxUtils.isDate(value)) {
                        if (values[index + 1].getTime() - value.getTime() < value.getTime() - values[index].getTime())
                            index++
                    }
                    else if (values[index + 1] - value < value - values[index])
                        index++;
                return values[index]
            }
            return value
        };
    var findGreaterOrEqualValue = function(values, value) {
            var index = findLessOrEqualValueIndex(values, value);
            if (values && index >= 0 && index < values.length) {
                if (values[index] < value && index + 1 < values.length)
                    index++;
                return values[index]
            }
            return value
        };
    var getInterval = function(valueMin, valueMax, delta) {
            var result,
                minDateDaysCount,
                maxDateDaysCount,
                daysCount,
                prevMaxDaysCount;
            if (dxUtils.isDate(valueMin)) {
                if (delta === 'year' || delta === 'quarter' || delta === 'month')
                    return {months: valueMax.getFullYear() * 12 + valueMax.getMonth() - valueMin.getFullYear() * 12 - valueMin.getMonth()};
                else
                    return {milliseconds: valueMax.valueOf() - valueMin.valueOf()};
                return result
            }
            else
                return valueMax - valueMin
        };
    var getRootOffsetLeft = function(renderer) {
            var node,
                result = 0,
                root = renderer.getRoot();
            if (root)
                for (node = root.element.parentNode; node && node.offsetLeft !== undefined; node = node.offsetParent)
                    result += node.offsetLeft;
            return result
        };
    var getEventPageX = function(eventArgs) {
            var result = 0;
            if (eventArgs.pageX)
                result = eventArgs.pageX;
            else if (eventArgs.originalEvent && eventArgs.originalEvent.pageX)
                result = eventArgs.originalEvent.pageX;
            if (eventArgs.originalEvent && eventArgs.originalEvent.touches)
                if (eventArgs.originalEvent.touches.length > 0)
                    result = eventArgs.originalEvent.touches[0].pageX;
                else if (eventArgs.originalEvent.changedTouches.length > 0)
                    result = eventArgs.originalEvent.changedTouches[0].pageX;
            return result
        };
    var getTextBBox = function(renderer, text, fontOptions) {
            var textElement = renderer.drawText(text, INVISIBLE_POS, INVISIBLE_POS, {font: fontOptions});
            var textBBox = textElement.getBBox();
            textElement.remove();
            return textBBox
        };
    utils.findLessOrEqualValue = findLessOrEqualValue;
    utils.findNearValue = findNearValue;
    utils.findGreaterOrEqualValue = findGreaterOrEqualValue;
    utils.getInterval = getInterval;
    utils.getRootOffsetLeft = getRootOffsetLeft;
    utils.getEventPageX = getEventPageX;
    utils.getTextBBox = getTextBBox
})(jQuery, DevExpress);

// Module viz, file themeManager.js

(function($, DX, undefined) {
    DX.viz.rangeSelector = DX.viz.rangeSelector;
    DX.viz.rangeSelector.ThemeManager = DX.viz.core.BaseThemeManager.inherit({
        ctor: function(userTheme) {
            var self = this;
            self.callBase(userTheme, 'rangeSelector');
            self.initializeFont(self.theme.scale.label.font);
            self.initializeFont(self.theme.sliderMarker.font)
        },
        applyRangeSelectorTheme: function(userOptions) {
            var self = this,
                refs = {dataSource: userOptions.dataSource},
                result;
            delete userOptions.dataSource;
            result = self.applyTheme(self.theme, userOptions);
            result.dataSource = refs.dataSource;
            return result
        },
        setBackgroundColor: function(containerBackgroundColor) {
            var theme = this.theme;
            if (containerBackgroundColor)
                theme.containerBackgroundColor = containerBackgroundColor;
            theme.shutter.color = theme.shutter.color || theme.containerBackgroundColor
        }
    })
})(jQuery, DevExpress);

// Module viz, file viz.js

(function(DevExpress) {
    var viz = DevExpress.viz;
    viz.Chart = viz.charts.Chart;
    viz.PieChart = viz.charts.PieChart;
    viz.RangeSelector = viz.rangeSelector.RangeSelector;
    viz.CircularGauge = viz.gauges.CircularGauge;
    viz.LinearGauge = viz.gauges.LinearGauge
})(DevExpress);

// Module viz, file dxChart.js

(function($, DX, undefined) {
    var ui = DX.ui,
        viz = DX.viz;
    ui.registerComponent("dxChart", viz.Chart)
})(jQuery, DevExpress);

// Module viz, file dxPieChart.js

(function($, DX, undefined) {
    var ui = DX.ui,
        viz = DX.viz;
    ui.registerComponent("dxPieChart", viz.PieChart)
})(jQuery, DevExpress);

// Module viz, file dxCircularGauge.js

(function(DX, undefined) {
    DX.ui.registerComponent("dxCircularGauge", DX.viz.CircularGauge)
})(DevExpress);

// Module viz, file dxLinearGauge.js

(function(DX, undefined) {
    DX.ui.registerComponent("dxLinearGauge", DX.viz.LinearGauge)
})(DevExpress);

// Module viz, file dxRangeSelector.js

(function($, DX, undefined) {
    var ui = DX.ui,
        viz = DX.viz;
    ui.registerComponent("dxRangeSelector", viz.RangeSelector)
})(jQuery, DevExpress);


